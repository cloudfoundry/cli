// Code generated by counterfeiter. DO NOT EDIT.
package actorsfakes

import (
	"os"
	"sync"

	"code.cloudfoundry.org/cli/cf/actors"
	"code.cloudfoundry.org/cli/cf/api/resources"
	"code.cloudfoundry.org/cli/cf/models"
)

type FakePushActor struct {
	GatherFilesStub        func([]models.AppFileFields, string, string, bool) ([]resources.AppFileResource, bool, error)
	gatherFilesMutex       sync.RWMutex
	gatherFilesArgsForCall []struct {
		arg1 []models.AppFileFields
		arg2 string
		arg3 string
		arg4 bool
	}
	gatherFilesReturns struct {
		result1 []resources.AppFileResource
		result2 bool
		result3 error
	}
	gatherFilesReturnsOnCall map[int]struct {
		result1 []resources.AppFileResource
		result2 bool
		result3 error
	}
	MapManifestRouteStub        func(string, models.Application, models.AppParams) error
	mapManifestRouteMutex       sync.RWMutex
	mapManifestRouteArgsForCall []struct {
		arg1 string
		arg2 models.Application
		arg3 models.AppParams
	}
	mapManifestRouteReturns struct {
		result1 error
	}
	mapManifestRouteReturnsOnCall map[int]struct {
		result1 error
	}
	ProcessPathStub        func(string, func(string) error) error
	processPathMutex       sync.RWMutex
	processPathArgsForCall []struct {
		arg1 string
		arg2 func(string) error
	}
	processPathReturns struct {
		result1 error
	}
	processPathReturnsOnCall map[int]struct {
		result1 error
	}
	UploadAppStub        func(string, *os.File, []resources.AppFileResource) error
	uploadAppMutex       sync.RWMutex
	uploadAppArgsForCall []struct {
		arg1 string
		arg2 *os.File
		arg3 []resources.AppFileResource
	}
	uploadAppReturns struct {
		result1 error
	}
	uploadAppReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateAppParamsStub        func([]models.AppParams) []error
	validateAppParamsMutex       sync.RWMutex
	validateAppParamsArgsForCall []struct {
		arg1 []models.AppParams
	}
	validateAppParamsReturns struct {
		result1 []error
	}
	validateAppParamsReturnsOnCall map[int]struct {
		result1 []error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePushActor) GatherFiles(arg1 []models.AppFileFields, arg2 string, arg3 string, arg4 bool) ([]resources.AppFileResource, bool, error) {
	var arg1Copy []models.AppFileFields
	if arg1 != nil {
		arg1Copy = make([]models.AppFileFields, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.gatherFilesMutex.Lock()
	ret, specificReturn := fake.gatherFilesReturnsOnCall[len(fake.gatherFilesArgsForCall)]
	fake.gatherFilesArgsForCall = append(fake.gatherFilesArgsForCall, struct {
		arg1 []models.AppFileFields
		arg2 string
		arg3 string
		arg4 bool
	}{arg1Copy, arg2, arg3, arg4})
	fake.recordInvocation("GatherFiles", []interface{}{arg1Copy, arg2, arg3, arg4})
	fake.gatherFilesMutex.Unlock()
	if fake.GatherFilesStub != nil {
		return fake.GatherFilesStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.gatherFilesReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePushActor) GatherFilesCallCount() int {
	fake.gatherFilesMutex.RLock()
	defer fake.gatherFilesMutex.RUnlock()
	return len(fake.gatherFilesArgsForCall)
}

func (fake *FakePushActor) GatherFilesCalls(stub func([]models.AppFileFields, string, string, bool) ([]resources.AppFileResource, bool, error)) {
	fake.gatherFilesMutex.Lock()
	defer fake.gatherFilesMutex.Unlock()
	fake.GatherFilesStub = stub
}

func (fake *FakePushActor) GatherFilesArgsForCall(i int) ([]models.AppFileFields, string, string, bool) {
	fake.gatherFilesMutex.RLock()
	defer fake.gatherFilesMutex.RUnlock()
	argsForCall := fake.gatherFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakePushActor) GatherFilesReturns(result1 []resources.AppFileResource, result2 bool, result3 error) {
	fake.gatherFilesMutex.Lock()
	defer fake.gatherFilesMutex.Unlock()
	fake.GatherFilesStub = nil
	fake.gatherFilesReturns = struct {
		result1 []resources.AppFileResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePushActor) GatherFilesReturnsOnCall(i int, result1 []resources.AppFileResource, result2 bool, result3 error) {
	fake.gatherFilesMutex.Lock()
	defer fake.gatherFilesMutex.Unlock()
	fake.GatherFilesStub = nil
	if fake.gatherFilesReturnsOnCall == nil {
		fake.gatherFilesReturnsOnCall = make(map[int]struct {
			result1 []resources.AppFileResource
			result2 bool
			result3 error
		})
	}
	fake.gatherFilesReturnsOnCall[i] = struct {
		result1 []resources.AppFileResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePushActor) MapManifestRoute(arg1 string, arg2 models.Application, arg3 models.AppParams) error {
	fake.mapManifestRouteMutex.Lock()
	ret, specificReturn := fake.mapManifestRouteReturnsOnCall[len(fake.mapManifestRouteArgsForCall)]
	fake.mapManifestRouteArgsForCall = append(fake.mapManifestRouteArgsForCall, struct {
		arg1 string
		arg2 models.Application
		arg3 models.AppParams
	}{arg1, arg2, arg3})
	fake.recordInvocation("MapManifestRoute", []interface{}{arg1, arg2, arg3})
	fake.mapManifestRouteMutex.Unlock()
	if fake.MapManifestRouteStub != nil {
		return fake.MapManifestRouteStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.mapManifestRouteReturns
	return fakeReturns.result1
}

func (fake *FakePushActor) MapManifestRouteCallCount() int {
	fake.mapManifestRouteMutex.RLock()
	defer fake.mapManifestRouteMutex.RUnlock()
	return len(fake.mapManifestRouteArgsForCall)
}

func (fake *FakePushActor) MapManifestRouteCalls(stub func(string, models.Application, models.AppParams) error) {
	fake.mapManifestRouteMutex.Lock()
	defer fake.mapManifestRouteMutex.Unlock()
	fake.MapManifestRouteStub = stub
}

func (fake *FakePushActor) MapManifestRouteArgsForCall(i int) (string, models.Application, models.AppParams) {
	fake.mapManifestRouteMutex.RLock()
	defer fake.mapManifestRouteMutex.RUnlock()
	argsForCall := fake.mapManifestRouteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePushActor) MapManifestRouteReturns(result1 error) {
	fake.mapManifestRouteMutex.Lock()
	defer fake.mapManifestRouteMutex.Unlock()
	fake.MapManifestRouteStub = nil
	fake.mapManifestRouteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePushActor) MapManifestRouteReturnsOnCall(i int, result1 error) {
	fake.mapManifestRouteMutex.Lock()
	defer fake.mapManifestRouteMutex.Unlock()
	fake.MapManifestRouteStub = nil
	if fake.mapManifestRouteReturnsOnCall == nil {
		fake.mapManifestRouteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mapManifestRouteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePushActor) ProcessPath(arg1 string, arg2 func(string) error) error {
	fake.processPathMutex.Lock()
	ret, specificReturn := fake.processPathReturnsOnCall[len(fake.processPathArgsForCall)]
	fake.processPathArgsForCall = append(fake.processPathArgsForCall, struct {
		arg1 string
		arg2 func(string) error
	}{arg1, arg2})
	fake.recordInvocation("ProcessPath", []interface{}{arg1, arg2})
	fake.processPathMutex.Unlock()
	if fake.ProcessPathStub != nil {
		return fake.ProcessPathStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.processPathReturns
	return fakeReturns.result1
}

func (fake *FakePushActor) ProcessPathCallCount() int {
	fake.processPathMutex.RLock()
	defer fake.processPathMutex.RUnlock()
	return len(fake.processPathArgsForCall)
}

func (fake *FakePushActor) ProcessPathCalls(stub func(string, func(string) error) error) {
	fake.processPathMutex.Lock()
	defer fake.processPathMutex.Unlock()
	fake.ProcessPathStub = stub
}

func (fake *FakePushActor) ProcessPathArgsForCall(i int) (string, func(string) error) {
	fake.processPathMutex.RLock()
	defer fake.processPathMutex.RUnlock()
	argsForCall := fake.processPathArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePushActor) ProcessPathReturns(result1 error) {
	fake.processPathMutex.Lock()
	defer fake.processPathMutex.Unlock()
	fake.ProcessPathStub = nil
	fake.processPathReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePushActor) ProcessPathReturnsOnCall(i int, result1 error) {
	fake.processPathMutex.Lock()
	defer fake.processPathMutex.Unlock()
	fake.ProcessPathStub = nil
	if fake.processPathReturnsOnCall == nil {
		fake.processPathReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.processPathReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePushActor) UploadApp(arg1 string, arg2 *os.File, arg3 []resources.AppFileResource) error {
	var arg3Copy []resources.AppFileResource
	if arg3 != nil {
		arg3Copy = make([]resources.AppFileResource, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.uploadAppMutex.Lock()
	ret, specificReturn := fake.uploadAppReturnsOnCall[len(fake.uploadAppArgsForCall)]
	fake.uploadAppArgsForCall = append(fake.uploadAppArgsForCall, struct {
		arg1 string
		arg2 *os.File
		arg3 []resources.AppFileResource
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("UploadApp", []interface{}{arg1, arg2, arg3Copy})
	fake.uploadAppMutex.Unlock()
	if fake.UploadAppStub != nil {
		return fake.UploadAppStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uploadAppReturns
	return fakeReturns.result1
}

func (fake *FakePushActor) UploadAppCallCount() int {
	fake.uploadAppMutex.RLock()
	defer fake.uploadAppMutex.RUnlock()
	return len(fake.uploadAppArgsForCall)
}

func (fake *FakePushActor) UploadAppCalls(stub func(string, *os.File, []resources.AppFileResource) error) {
	fake.uploadAppMutex.Lock()
	defer fake.uploadAppMutex.Unlock()
	fake.UploadAppStub = stub
}

func (fake *FakePushActor) UploadAppArgsForCall(i int) (string, *os.File, []resources.AppFileResource) {
	fake.uploadAppMutex.RLock()
	defer fake.uploadAppMutex.RUnlock()
	argsForCall := fake.uploadAppArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePushActor) UploadAppReturns(result1 error) {
	fake.uploadAppMutex.Lock()
	defer fake.uploadAppMutex.Unlock()
	fake.UploadAppStub = nil
	fake.uploadAppReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePushActor) UploadAppReturnsOnCall(i int, result1 error) {
	fake.uploadAppMutex.Lock()
	defer fake.uploadAppMutex.Unlock()
	fake.UploadAppStub = nil
	if fake.uploadAppReturnsOnCall == nil {
		fake.uploadAppReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadAppReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePushActor) ValidateAppParams(arg1 []models.AppParams) []error {
	var arg1Copy []models.AppParams
	if arg1 != nil {
		arg1Copy = make([]models.AppParams, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.validateAppParamsMutex.Lock()
	ret, specificReturn := fake.validateAppParamsReturnsOnCall[len(fake.validateAppParamsArgsForCall)]
	fake.validateAppParamsArgsForCall = append(fake.validateAppParamsArgsForCall, struct {
		arg1 []models.AppParams
	}{arg1Copy})
	fake.recordInvocation("ValidateAppParams", []interface{}{arg1Copy})
	fake.validateAppParamsMutex.Unlock()
	if fake.ValidateAppParamsStub != nil {
		return fake.ValidateAppParamsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.validateAppParamsReturns
	return fakeReturns.result1
}

func (fake *FakePushActor) ValidateAppParamsCallCount() int {
	fake.validateAppParamsMutex.RLock()
	defer fake.validateAppParamsMutex.RUnlock()
	return len(fake.validateAppParamsArgsForCall)
}

func (fake *FakePushActor) ValidateAppParamsCalls(stub func([]models.AppParams) []error) {
	fake.validateAppParamsMutex.Lock()
	defer fake.validateAppParamsMutex.Unlock()
	fake.ValidateAppParamsStub = stub
}

func (fake *FakePushActor) ValidateAppParamsArgsForCall(i int) []models.AppParams {
	fake.validateAppParamsMutex.RLock()
	defer fake.validateAppParamsMutex.RUnlock()
	argsForCall := fake.validateAppParamsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePushActor) ValidateAppParamsReturns(result1 []error) {
	fake.validateAppParamsMutex.Lock()
	defer fake.validateAppParamsMutex.Unlock()
	fake.ValidateAppParamsStub = nil
	fake.validateAppParamsReturns = struct {
		result1 []error
	}{result1}
}

func (fake *FakePushActor) ValidateAppParamsReturnsOnCall(i int, result1 []error) {
	fake.validateAppParamsMutex.Lock()
	defer fake.validateAppParamsMutex.Unlock()
	fake.ValidateAppParamsStub = nil
	if fake.validateAppParamsReturnsOnCall == nil {
		fake.validateAppParamsReturnsOnCall = make(map[int]struct {
			result1 []error
		})
	}
	fake.validateAppParamsReturnsOnCall[i] = struct {
		result1 []error
	}{result1}
}

func (fake *FakePushActor) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.gatherFilesMutex.RLock()
	defer fake.gatherFilesMutex.RUnlock()
	fake.mapManifestRouteMutex.RLock()
	defer fake.mapManifestRouteMutex.RUnlock()
	fake.processPathMutex.RLock()
	defer fake.processPathMutex.RUnlock()
	fake.uploadAppMutex.RLock()
	defer fake.uploadAppMutex.RUnlock()
	fake.validateAppParamsMutex.RLock()
	defer fake.validateAppParamsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePushActor) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ actors.PushActor = new(FakePushActor)
