// Code generated by counterfeiter. DO NOT EDIT.
package pluginconfigfakes

import (
	"sync"

	"code.cloudfoundry.org/cli/cf/configuration/pluginconfig"
)

type FakePluginConfiguration struct {
	GetPluginPathStub        func() string
	getPluginPathMutex       sync.RWMutex
	getPluginPathArgsForCall []struct {
	}
	getPluginPathReturns struct {
		result1 string
	}
	getPluginPathReturnsOnCall map[int]struct {
		result1 string
	}
	ListCommandsStub        func() []string
	listCommandsMutex       sync.RWMutex
	listCommandsArgsForCall []struct {
	}
	listCommandsReturns struct {
		result1 []string
	}
	listCommandsReturnsOnCall map[int]struct {
		result1 []string
	}
	PluginsStub        func() map[string]pluginconfig.PluginMetadata
	pluginsMutex       sync.RWMutex
	pluginsArgsForCall []struct {
	}
	pluginsReturns struct {
		result1 map[string]pluginconfig.PluginMetadata
	}
	pluginsReturnsOnCall map[int]struct {
		result1 map[string]pluginconfig.PluginMetadata
	}
	RemovePluginStub        func(string)
	removePluginMutex       sync.RWMutex
	removePluginArgsForCall []struct {
		arg1 string
	}
	SetPluginStub        func(string, pluginconfig.PluginMetadata)
	setPluginMutex       sync.RWMutex
	setPluginArgsForCall []struct {
		arg1 string
		arg2 pluginconfig.PluginMetadata
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePluginConfiguration) GetPluginPath() string {
	fake.getPluginPathMutex.Lock()
	ret, specificReturn := fake.getPluginPathReturnsOnCall[len(fake.getPluginPathArgsForCall)]
	fake.getPluginPathArgsForCall = append(fake.getPluginPathArgsForCall, struct {
	}{})
	fake.recordInvocation("GetPluginPath", []interface{}{})
	fake.getPluginPathMutex.Unlock()
	if fake.GetPluginPathStub != nil {
		return fake.GetPluginPathStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getPluginPathReturns
	return fakeReturns.result1
}

func (fake *FakePluginConfiguration) GetPluginPathCallCount() int {
	fake.getPluginPathMutex.RLock()
	defer fake.getPluginPathMutex.RUnlock()
	return len(fake.getPluginPathArgsForCall)
}

func (fake *FakePluginConfiguration) GetPluginPathCalls(stub func() string) {
	fake.getPluginPathMutex.Lock()
	defer fake.getPluginPathMutex.Unlock()
	fake.GetPluginPathStub = stub
}

func (fake *FakePluginConfiguration) GetPluginPathReturns(result1 string) {
	fake.getPluginPathMutex.Lock()
	defer fake.getPluginPathMutex.Unlock()
	fake.GetPluginPathStub = nil
	fake.getPluginPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginConfiguration) GetPluginPathReturnsOnCall(i int, result1 string) {
	fake.getPluginPathMutex.Lock()
	defer fake.getPluginPathMutex.Unlock()
	fake.GetPluginPathStub = nil
	if fake.getPluginPathReturnsOnCall == nil {
		fake.getPluginPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getPluginPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginConfiguration) ListCommands() []string {
	fake.listCommandsMutex.Lock()
	ret, specificReturn := fake.listCommandsReturnsOnCall[len(fake.listCommandsArgsForCall)]
	fake.listCommandsArgsForCall = append(fake.listCommandsArgsForCall, struct {
	}{})
	fake.recordInvocation("ListCommands", []interface{}{})
	fake.listCommandsMutex.Unlock()
	if fake.ListCommandsStub != nil {
		return fake.ListCommandsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.listCommandsReturns
	return fakeReturns.result1
}

func (fake *FakePluginConfiguration) ListCommandsCallCount() int {
	fake.listCommandsMutex.RLock()
	defer fake.listCommandsMutex.RUnlock()
	return len(fake.listCommandsArgsForCall)
}

func (fake *FakePluginConfiguration) ListCommandsCalls(stub func() []string) {
	fake.listCommandsMutex.Lock()
	defer fake.listCommandsMutex.Unlock()
	fake.ListCommandsStub = stub
}

func (fake *FakePluginConfiguration) ListCommandsReturns(result1 []string) {
	fake.listCommandsMutex.Lock()
	defer fake.listCommandsMutex.Unlock()
	fake.ListCommandsStub = nil
	fake.listCommandsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakePluginConfiguration) ListCommandsReturnsOnCall(i int, result1 []string) {
	fake.listCommandsMutex.Lock()
	defer fake.listCommandsMutex.Unlock()
	fake.ListCommandsStub = nil
	if fake.listCommandsReturnsOnCall == nil {
		fake.listCommandsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.listCommandsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakePluginConfiguration) Plugins() map[string]pluginconfig.PluginMetadata {
	fake.pluginsMutex.Lock()
	ret, specificReturn := fake.pluginsReturnsOnCall[len(fake.pluginsArgsForCall)]
	fake.pluginsArgsForCall = append(fake.pluginsArgsForCall, struct {
	}{})
	fake.recordInvocation("Plugins", []interface{}{})
	fake.pluginsMutex.Unlock()
	if fake.PluginsStub != nil {
		return fake.PluginsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pluginsReturns
	return fakeReturns.result1
}

func (fake *FakePluginConfiguration) PluginsCallCount() int {
	fake.pluginsMutex.RLock()
	defer fake.pluginsMutex.RUnlock()
	return len(fake.pluginsArgsForCall)
}

func (fake *FakePluginConfiguration) PluginsCalls(stub func() map[string]pluginconfig.PluginMetadata) {
	fake.pluginsMutex.Lock()
	defer fake.pluginsMutex.Unlock()
	fake.PluginsStub = stub
}

func (fake *FakePluginConfiguration) PluginsReturns(result1 map[string]pluginconfig.PluginMetadata) {
	fake.pluginsMutex.Lock()
	defer fake.pluginsMutex.Unlock()
	fake.PluginsStub = nil
	fake.pluginsReturns = struct {
		result1 map[string]pluginconfig.PluginMetadata
	}{result1}
}

func (fake *FakePluginConfiguration) PluginsReturnsOnCall(i int, result1 map[string]pluginconfig.PluginMetadata) {
	fake.pluginsMutex.Lock()
	defer fake.pluginsMutex.Unlock()
	fake.PluginsStub = nil
	if fake.pluginsReturnsOnCall == nil {
		fake.pluginsReturnsOnCall = make(map[int]struct {
			result1 map[string]pluginconfig.PluginMetadata
		})
	}
	fake.pluginsReturnsOnCall[i] = struct {
		result1 map[string]pluginconfig.PluginMetadata
	}{result1}
}

func (fake *FakePluginConfiguration) RemovePlugin(arg1 string) {
	fake.removePluginMutex.Lock()
	fake.removePluginArgsForCall = append(fake.removePluginArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("RemovePlugin", []interface{}{arg1})
	fake.removePluginMutex.Unlock()
	if fake.RemovePluginStub != nil {
		fake.RemovePluginStub(arg1)
	}
}

func (fake *FakePluginConfiguration) RemovePluginCallCount() int {
	fake.removePluginMutex.RLock()
	defer fake.removePluginMutex.RUnlock()
	return len(fake.removePluginArgsForCall)
}

func (fake *FakePluginConfiguration) RemovePluginCalls(stub func(string)) {
	fake.removePluginMutex.Lock()
	defer fake.removePluginMutex.Unlock()
	fake.RemovePluginStub = stub
}

func (fake *FakePluginConfiguration) RemovePluginArgsForCall(i int) string {
	fake.removePluginMutex.RLock()
	defer fake.removePluginMutex.RUnlock()
	argsForCall := fake.removePluginArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePluginConfiguration) SetPlugin(arg1 string, arg2 pluginconfig.PluginMetadata) {
	fake.setPluginMutex.Lock()
	fake.setPluginArgsForCall = append(fake.setPluginArgsForCall, struct {
		arg1 string
		arg2 pluginconfig.PluginMetadata
	}{arg1, arg2})
	fake.recordInvocation("SetPlugin", []interface{}{arg1, arg2})
	fake.setPluginMutex.Unlock()
	if fake.SetPluginStub != nil {
		fake.SetPluginStub(arg1, arg2)
	}
}

func (fake *FakePluginConfiguration) SetPluginCallCount() int {
	fake.setPluginMutex.RLock()
	defer fake.setPluginMutex.RUnlock()
	return len(fake.setPluginArgsForCall)
}

func (fake *FakePluginConfiguration) SetPluginCalls(stub func(string, pluginconfig.PluginMetadata)) {
	fake.setPluginMutex.Lock()
	defer fake.setPluginMutex.Unlock()
	fake.SetPluginStub = stub
}

func (fake *FakePluginConfiguration) SetPluginArgsForCall(i int) (string, pluginconfig.PluginMetadata) {
	fake.setPluginMutex.RLock()
	defer fake.setPluginMutex.RUnlock()
	argsForCall := fake.setPluginArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePluginConfiguration) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getPluginPathMutex.RLock()
	defer fake.getPluginPathMutex.RUnlock()
	fake.listCommandsMutex.RLock()
	defer fake.listCommandsMutex.RUnlock()
	fake.pluginsMutex.RLock()
	defer fake.pluginsMutex.RUnlock()
	fake.removePluginMutex.RLock()
	defer fake.removePluginMutex.RUnlock()
	fake.setPluginMutex.RLock()
	defer fake.setPluginMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePluginConfiguration) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pluginconfig.PluginConfiguration = new(FakePluginConfiguration)
