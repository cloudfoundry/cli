// Code generated by counterfeiter. DO NOT EDIT.
package manifestfakes

import (
	"io"
	"sync"

	"code.cloudfoundry.org/cli/cf/manifest"
	"code.cloudfoundry.org/cli/cf/models"
)

type FakeApp struct {
	BuildpackURLStub        func(string, string)
	buildpackURLMutex       sync.RWMutex
	buildpackURLArgsForCall []struct {
		arg1 string
		arg2 string
	}
	DiskQuotaStub        func(string, int64)
	diskQuotaMutex       sync.RWMutex
	diskQuotaArgsForCall []struct {
		arg1 string
		arg2 int64
	}
	EnvironmentVarsStub        func(string, string, string)
	environmentVarsMutex       sync.RWMutex
	environmentVarsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	GetContentsStub        func() []models.Application
	getContentsMutex       sync.RWMutex
	getContentsArgsForCall []struct {
	}
	getContentsReturns struct {
		result1 []models.Application
	}
	getContentsReturnsOnCall map[int]struct {
		result1 []models.Application
	}
	HealthCheckHTTPEndpointStub        func(string, string)
	healthCheckHTTPEndpointMutex       sync.RWMutex
	healthCheckHTTPEndpointArgsForCall []struct {
		arg1 string
		arg2 string
	}
	HealthCheckTimeoutStub        func(string, int)
	healthCheckTimeoutMutex       sync.RWMutex
	healthCheckTimeoutArgsForCall []struct {
		arg1 string
		arg2 int
	}
	HealthCheckTypeStub        func(string, string)
	healthCheckTypeMutex       sync.RWMutex
	healthCheckTypeArgsForCall []struct {
		arg1 string
		arg2 string
	}
	InstancesStub        func(string, int)
	instancesMutex       sync.RWMutex
	instancesArgsForCall []struct {
		arg1 string
		arg2 int
	}
	MemoryStub        func(string, int64)
	memoryMutex       sync.RWMutex
	memoryArgsForCall []struct {
		arg1 string
		arg2 int64
	}
	RouteStub        func(string, string, string, string, int)
	routeMutex       sync.RWMutex
	routeArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 int
	}
	SaveStub        func(io.Writer) error
	saveMutex       sync.RWMutex
	saveArgsForCall []struct {
		arg1 io.Writer
	}
	saveReturns struct {
		result1 error
	}
	saveReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceStub        func(string, string)
	serviceMutex       sync.RWMutex
	serviceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	StackStub        func(string, string)
	stackMutex       sync.RWMutex
	stackArgsForCall []struct {
		arg1 string
		arg2 string
	}
	StartCommandStub        func(string, string)
	startCommandMutex       sync.RWMutex
	startCommandArgsForCall []struct {
		arg1 string
		arg2 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeApp) BuildpackURL(arg1 string, arg2 string) {
	fake.buildpackURLMutex.Lock()
	fake.buildpackURLArgsForCall = append(fake.buildpackURLArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("BuildpackURL", []interface{}{arg1, arg2})
	fake.buildpackURLMutex.Unlock()
	if fake.BuildpackURLStub != nil {
		fake.BuildpackURLStub(arg1, arg2)
	}
}

func (fake *FakeApp) BuildpackURLCallCount() int {
	fake.buildpackURLMutex.RLock()
	defer fake.buildpackURLMutex.RUnlock()
	return len(fake.buildpackURLArgsForCall)
}

func (fake *FakeApp) BuildpackURLCalls(stub func(string, string)) {
	fake.buildpackURLMutex.Lock()
	defer fake.buildpackURLMutex.Unlock()
	fake.BuildpackURLStub = stub
}

func (fake *FakeApp) BuildpackURLArgsForCall(i int) (string, string) {
	fake.buildpackURLMutex.RLock()
	defer fake.buildpackURLMutex.RUnlock()
	argsForCall := fake.buildpackURLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApp) DiskQuota(arg1 string, arg2 int64) {
	fake.diskQuotaMutex.Lock()
	fake.diskQuotaArgsForCall = append(fake.diskQuotaArgsForCall, struct {
		arg1 string
		arg2 int64
	}{arg1, arg2})
	fake.recordInvocation("DiskQuota", []interface{}{arg1, arg2})
	fake.diskQuotaMutex.Unlock()
	if fake.DiskQuotaStub != nil {
		fake.DiskQuotaStub(arg1, arg2)
	}
}

func (fake *FakeApp) DiskQuotaCallCount() int {
	fake.diskQuotaMutex.RLock()
	defer fake.diskQuotaMutex.RUnlock()
	return len(fake.diskQuotaArgsForCall)
}

func (fake *FakeApp) DiskQuotaCalls(stub func(string, int64)) {
	fake.diskQuotaMutex.Lock()
	defer fake.diskQuotaMutex.Unlock()
	fake.DiskQuotaStub = stub
}

func (fake *FakeApp) DiskQuotaArgsForCall(i int) (string, int64) {
	fake.diskQuotaMutex.RLock()
	defer fake.diskQuotaMutex.RUnlock()
	argsForCall := fake.diskQuotaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApp) EnvironmentVars(arg1 string, arg2 string, arg3 string) {
	fake.environmentVarsMutex.Lock()
	fake.environmentVarsArgsForCall = append(fake.environmentVarsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("EnvironmentVars", []interface{}{arg1, arg2, arg3})
	fake.environmentVarsMutex.Unlock()
	if fake.EnvironmentVarsStub != nil {
		fake.EnvironmentVarsStub(arg1, arg2, arg3)
	}
}

func (fake *FakeApp) EnvironmentVarsCallCount() int {
	fake.environmentVarsMutex.RLock()
	defer fake.environmentVarsMutex.RUnlock()
	return len(fake.environmentVarsArgsForCall)
}

func (fake *FakeApp) EnvironmentVarsCalls(stub func(string, string, string)) {
	fake.environmentVarsMutex.Lock()
	defer fake.environmentVarsMutex.Unlock()
	fake.EnvironmentVarsStub = stub
}

func (fake *FakeApp) EnvironmentVarsArgsForCall(i int) (string, string, string) {
	fake.environmentVarsMutex.RLock()
	defer fake.environmentVarsMutex.RUnlock()
	argsForCall := fake.environmentVarsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeApp) GetContents() []models.Application {
	fake.getContentsMutex.Lock()
	ret, specificReturn := fake.getContentsReturnsOnCall[len(fake.getContentsArgsForCall)]
	fake.getContentsArgsForCall = append(fake.getContentsArgsForCall, struct {
	}{})
	fake.recordInvocation("GetContents", []interface{}{})
	fake.getContentsMutex.Unlock()
	if fake.GetContentsStub != nil {
		return fake.GetContentsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getContentsReturns
	return fakeReturns.result1
}

func (fake *FakeApp) GetContentsCallCount() int {
	fake.getContentsMutex.RLock()
	defer fake.getContentsMutex.RUnlock()
	return len(fake.getContentsArgsForCall)
}

func (fake *FakeApp) GetContentsCalls(stub func() []models.Application) {
	fake.getContentsMutex.Lock()
	defer fake.getContentsMutex.Unlock()
	fake.GetContentsStub = stub
}

func (fake *FakeApp) GetContentsReturns(result1 []models.Application) {
	fake.getContentsMutex.Lock()
	defer fake.getContentsMutex.Unlock()
	fake.GetContentsStub = nil
	fake.getContentsReturns = struct {
		result1 []models.Application
	}{result1}
}

func (fake *FakeApp) GetContentsReturnsOnCall(i int, result1 []models.Application) {
	fake.getContentsMutex.Lock()
	defer fake.getContentsMutex.Unlock()
	fake.GetContentsStub = nil
	if fake.getContentsReturnsOnCall == nil {
		fake.getContentsReturnsOnCall = make(map[int]struct {
			result1 []models.Application
		})
	}
	fake.getContentsReturnsOnCall[i] = struct {
		result1 []models.Application
	}{result1}
}

func (fake *FakeApp) HealthCheckHTTPEndpoint(arg1 string, arg2 string) {
	fake.healthCheckHTTPEndpointMutex.Lock()
	fake.healthCheckHTTPEndpointArgsForCall = append(fake.healthCheckHTTPEndpointArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("HealthCheckHTTPEndpoint", []interface{}{arg1, arg2})
	fake.healthCheckHTTPEndpointMutex.Unlock()
	if fake.HealthCheckHTTPEndpointStub != nil {
		fake.HealthCheckHTTPEndpointStub(arg1, arg2)
	}
}

func (fake *FakeApp) HealthCheckHTTPEndpointCallCount() int {
	fake.healthCheckHTTPEndpointMutex.RLock()
	defer fake.healthCheckHTTPEndpointMutex.RUnlock()
	return len(fake.healthCheckHTTPEndpointArgsForCall)
}

func (fake *FakeApp) HealthCheckHTTPEndpointCalls(stub func(string, string)) {
	fake.healthCheckHTTPEndpointMutex.Lock()
	defer fake.healthCheckHTTPEndpointMutex.Unlock()
	fake.HealthCheckHTTPEndpointStub = stub
}

func (fake *FakeApp) HealthCheckHTTPEndpointArgsForCall(i int) (string, string) {
	fake.healthCheckHTTPEndpointMutex.RLock()
	defer fake.healthCheckHTTPEndpointMutex.RUnlock()
	argsForCall := fake.healthCheckHTTPEndpointArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApp) HealthCheckTimeout(arg1 string, arg2 int) {
	fake.healthCheckTimeoutMutex.Lock()
	fake.healthCheckTimeoutArgsForCall = append(fake.healthCheckTimeoutArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("HealthCheckTimeout", []interface{}{arg1, arg2})
	fake.healthCheckTimeoutMutex.Unlock()
	if fake.HealthCheckTimeoutStub != nil {
		fake.HealthCheckTimeoutStub(arg1, arg2)
	}
}

func (fake *FakeApp) HealthCheckTimeoutCallCount() int {
	fake.healthCheckTimeoutMutex.RLock()
	defer fake.healthCheckTimeoutMutex.RUnlock()
	return len(fake.healthCheckTimeoutArgsForCall)
}

func (fake *FakeApp) HealthCheckTimeoutCalls(stub func(string, int)) {
	fake.healthCheckTimeoutMutex.Lock()
	defer fake.healthCheckTimeoutMutex.Unlock()
	fake.HealthCheckTimeoutStub = stub
}

func (fake *FakeApp) HealthCheckTimeoutArgsForCall(i int) (string, int) {
	fake.healthCheckTimeoutMutex.RLock()
	defer fake.healthCheckTimeoutMutex.RUnlock()
	argsForCall := fake.healthCheckTimeoutArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApp) HealthCheckType(arg1 string, arg2 string) {
	fake.healthCheckTypeMutex.Lock()
	fake.healthCheckTypeArgsForCall = append(fake.healthCheckTypeArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("HealthCheckType", []interface{}{arg1, arg2})
	fake.healthCheckTypeMutex.Unlock()
	if fake.HealthCheckTypeStub != nil {
		fake.HealthCheckTypeStub(arg1, arg2)
	}
}

func (fake *FakeApp) HealthCheckTypeCallCount() int {
	fake.healthCheckTypeMutex.RLock()
	defer fake.healthCheckTypeMutex.RUnlock()
	return len(fake.healthCheckTypeArgsForCall)
}

func (fake *FakeApp) HealthCheckTypeCalls(stub func(string, string)) {
	fake.healthCheckTypeMutex.Lock()
	defer fake.healthCheckTypeMutex.Unlock()
	fake.HealthCheckTypeStub = stub
}

func (fake *FakeApp) HealthCheckTypeArgsForCall(i int) (string, string) {
	fake.healthCheckTypeMutex.RLock()
	defer fake.healthCheckTypeMutex.RUnlock()
	argsForCall := fake.healthCheckTypeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApp) Instances(arg1 string, arg2 int) {
	fake.instancesMutex.Lock()
	fake.instancesArgsForCall = append(fake.instancesArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("Instances", []interface{}{arg1, arg2})
	fake.instancesMutex.Unlock()
	if fake.InstancesStub != nil {
		fake.InstancesStub(arg1, arg2)
	}
}

func (fake *FakeApp) InstancesCallCount() int {
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	return len(fake.instancesArgsForCall)
}

func (fake *FakeApp) InstancesCalls(stub func(string, int)) {
	fake.instancesMutex.Lock()
	defer fake.instancesMutex.Unlock()
	fake.InstancesStub = stub
}

func (fake *FakeApp) InstancesArgsForCall(i int) (string, int) {
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	argsForCall := fake.instancesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApp) Memory(arg1 string, arg2 int64) {
	fake.memoryMutex.Lock()
	fake.memoryArgsForCall = append(fake.memoryArgsForCall, struct {
		arg1 string
		arg2 int64
	}{arg1, arg2})
	fake.recordInvocation("Memory", []interface{}{arg1, arg2})
	fake.memoryMutex.Unlock()
	if fake.MemoryStub != nil {
		fake.MemoryStub(arg1, arg2)
	}
}

func (fake *FakeApp) MemoryCallCount() int {
	fake.memoryMutex.RLock()
	defer fake.memoryMutex.RUnlock()
	return len(fake.memoryArgsForCall)
}

func (fake *FakeApp) MemoryCalls(stub func(string, int64)) {
	fake.memoryMutex.Lock()
	defer fake.memoryMutex.Unlock()
	fake.MemoryStub = stub
}

func (fake *FakeApp) MemoryArgsForCall(i int) (string, int64) {
	fake.memoryMutex.RLock()
	defer fake.memoryMutex.RUnlock()
	argsForCall := fake.memoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApp) Route(arg1 string, arg2 string, arg3 string, arg4 string, arg5 int) {
	fake.routeMutex.Lock()
	fake.routeArgsForCall = append(fake.routeArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 int
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("Route", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.routeMutex.Unlock()
	if fake.RouteStub != nil {
		fake.RouteStub(arg1, arg2, arg3, arg4, arg5)
	}
}

func (fake *FakeApp) RouteCallCount() int {
	fake.routeMutex.RLock()
	defer fake.routeMutex.RUnlock()
	return len(fake.routeArgsForCall)
}

func (fake *FakeApp) RouteCalls(stub func(string, string, string, string, int)) {
	fake.routeMutex.Lock()
	defer fake.routeMutex.Unlock()
	fake.RouteStub = stub
}

func (fake *FakeApp) RouteArgsForCall(i int) (string, string, string, string, int) {
	fake.routeMutex.RLock()
	defer fake.routeMutex.RUnlock()
	argsForCall := fake.routeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeApp) Save(arg1 io.Writer) error {
	fake.saveMutex.Lock()
	ret, specificReturn := fake.saveReturnsOnCall[len(fake.saveArgsForCall)]
	fake.saveArgsForCall = append(fake.saveArgsForCall, struct {
		arg1 io.Writer
	}{arg1})
	fake.recordInvocation("Save", []interface{}{arg1})
	fake.saveMutex.Unlock()
	if fake.SaveStub != nil {
		return fake.SaveStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveReturns
	return fakeReturns.result1
}

func (fake *FakeApp) SaveCallCount() int {
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	return len(fake.saveArgsForCall)
}

func (fake *FakeApp) SaveCalls(stub func(io.Writer) error) {
	fake.saveMutex.Lock()
	defer fake.saveMutex.Unlock()
	fake.SaveStub = stub
}

func (fake *FakeApp) SaveArgsForCall(i int) io.Writer {
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	argsForCall := fake.saveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApp) SaveReturns(result1 error) {
	fake.saveMutex.Lock()
	defer fake.saveMutex.Unlock()
	fake.SaveStub = nil
	fake.saveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApp) SaveReturnsOnCall(i int, result1 error) {
	fake.saveMutex.Lock()
	defer fake.saveMutex.Unlock()
	fake.SaveStub = nil
	if fake.saveReturnsOnCall == nil {
		fake.saveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApp) Service(arg1 string, arg2 string) {
	fake.serviceMutex.Lock()
	fake.serviceArgsForCall = append(fake.serviceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Service", []interface{}{arg1, arg2})
	fake.serviceMutex.Unlock()
	if fake.ServiceStub != nil {
		fake.ServiceStub(arg1, arg2)
	}
}

func (fake *FakeApp) ServiceCallCount() int {
	fake.serviceMutex.RLock()
	defer fake.serviceMutex.RUnlock()
	return len(fake.serviceArgsForCall)
}

func (fake *FakeApp) ServiceCalls(stub func(string, string)) {
	fake.serviceMutex.Lock()
	defer fake.serviceMutex.Unlock()
	fake.ServiceStub = stub
}

func (fake *FakeApp) ServiceArgsForCall(i int) (string, string) {
	fake.serviceMutex.RLock()
	defer fake.serviceMutex.RUnlock()
	argsForCall := fake.serviceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApp) Stack(arg1 string, arg2 string) {
	fake.stackMutex.Lock()
	fake.stackArgsForCall = append(fake.stackArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Stack", []interface{}{arg1, arg2})
	fake.stackMutex.Unlock()
	if fake.StackStub != nil {
		fake.StackStub(arg1, arg2)
	}
}

func (fake *FakeApp) StackCallCount() int {
	fake.stackMutex.RLock()
	defer fake.stackMutex.RUnlock()
	return len(fake.stackArgsForCall)
}

func (fake *FakeApp) StackCalls(stub func(string, string)) {
	fake.stackMutex.Lock()
	defer fake.stackMutex.Unlock()
	fake.StackStub = stub
}

func (fake *FakeApp) StackArgsForCall(i int) (string, string) {
	fake.stackMutex.RLock()
	defer fake.stackMutex.RUnlock()
	argsForCall := fake.stackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApp) StartCommand(arg1 string, arg2 string) {
	fake.startCommandMutex.Lock()
	fake.startCommandArgsForCall = append(fake.startCommandArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("StartCommand", []interface{}{arg1, arg2})
	fake.startCommandMutex.Unlock()
	if fake.StartCommandStub != nil {
		fake.StartCommandStub(arg1, arg2)
	}
}

func (fake *FakeApp) StartCommandCallCount() int {
	fake.startCommandMutex.RLock()
	defer fake.startCommandMutex.RUnlock()
	return len(fake.startCommandArgsForCall)
}

func (fake *FakeApp) StartCommandCalls(stub func(string, string)) {
	fake.startCommandMutex.Lock()
	defer fake.startCommandMutex.Unlock()
	fake.StartCommandStub = stub
}

func (fake *FakeApp) StartCommandArgsForCall(i int) (string, string) {
	fake.startCommandMutex.RLock()
	defer fake.startCommandMutex.RUnlock()
	argsForCall := fake.startCommandArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApp) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.buildpackURLMutex.RLock()
	defer fake.buildpackURLMutex.RUnlock()
	fake.diskQuotaMutex.RLock()
	defer fake.diskQuotaMutex.RUnlock()
	fake.environmentVarsMutex.RLock()
	defer fake.environmentVarsMutex.RUnlock()
	fake.getContentsMutex.RLock()
	defer fake.getContentsMutex.RUnlock()
	fake.healthCheckHTTPEndpointMutex.RLock()
	defer fake.healthCheckHTTPEndpointMutex.RUnlock()
	fake.healthCheckTimeoutMutex.RLock()
	defer fake.healthCheckTimeoutMutex.RUnlock()
	fake.healthCheckTypeMutex.RLock()
	defer fake.healthCheckTypeMutex.RUnlock()
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	fake.memoryMutex.RLock()
	defer fake.memoryMutex.RUnlock()
	fake.routeMutex.RLock()
	defer fake.routeMutex.RUnlock()
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	fake.serviceMutex.RLock()
	defer fake.serviceMutex.RUnlock()
	fake.stackMutex.RLock()
	defer fake.stackMutex.RUnlock()
	fake.startCommandMutex.RLock()
	defer fake.startCommandMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeApp) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ manifest.App = new(FakeApp)
