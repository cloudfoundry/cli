// Code generated by counterfeiter. DO NOT EDIT.
package apifakes

import (
	"sync"

	"code.cloudfoundry.org/cli/cf/api"
	"code.cloudfoundry.org/cli/cf/models"
)

type FakeUserRepository struct {
	CreateStub        func(string, string) error
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createReturns struct {
		result1 error
	}
	createReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(string) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 string
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	FindAllByUsernameStub        func(string) ([]models.UserFields, error)
	findAllByUsernameMutex       sync.RWMutex
	findAllByUsernameArgsForCall []struct {
		arg1 string
	}
	findAllByUsernameReturns struct {
		result1 []models.UserFields
		result2 error
	}
	findAllByUsernameReturnsOnCall map[int]struct {
		result1 []models.UserFields
		result2 error
	}
	FindByUsernameStub        func(string) (models.UserFields, error)
	findByUsernameMutex       sync.RWMutex
	findByUsernameArgsForCall []struct {
		arg1 string
	}
	findByUsernameReturns struct {
		result1 models.UserFields
		result2 error
	}
	findByUsernameReturnsOnCall map[int]struct {
		result1 models.UserFields
		result2 error
	}
	ListUsersInOrgForRoleWithNoUAAStub        func(string, models.Role) ([]models.UserFields, error)
	listUsersInOrgForRoleWithNoUAAMutex       sync.RWMutex
	listUsersInOrgForRoleWithNoUAAArgsForCall []struct {
		arg1 string
		arg2 models.Role
	}
	listUsersInOrgForRoleWithNoUAAReturns struct {
		result1 []models.UserFields
		result2 error
	}
	listUsersInOrgForRoleWithNoUAAReturnsOnCall map[int]struct {
		result1 []models.UserFields
		result2 error
	}
	ListUsersInSpaceForRoleWithNoUAAStub        func(string, models.Role) ([]models.UserFields, error)
	listUsersInSpaceForRoleWithNoUAAMutex       sync.RWMutex
	listUsersInSpaceForRoleWithNoUAAArgsForCall []struct {
		arg1 string
		arg2 models.Role
	}
	listUsersInSpaceForRoleWithNoUAAReturns struct {
		result1 []models.UserFields
		result2 error
	}
	listUsersInSpaceForRoleWithNoUAAReturnsOnCall map[int]struct {
		result1 []models.UserFields
		result2 error
	}
	SetOrgRoleByGUIDStub        func(string, string, models.Role) error
	setOrgRoleByGUIDMutex       sync.RWMutex
	setOrgRoleByGUIDArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 models.Role
	}
	setOrgRoleByGUIDReturns struct {
		result1 error
	}
	setOrgRoleByGUIDReturnsOnCall map[int]struct {
		result1 error
	}
	SetOrgRoleByUsernameStub        func(string, string, models.Role) error
	setOrgRoleByUsernameMutex       sync.RWMutex
	setOrgRoleByUsernameArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 models.Role
	}
	setOrgRoleByUsernameReturns struct {
		result1 error
	}
	setOrgRoleByUsernameReturnsOnCall map[int]struct {
		result1 error
	}
	SetSpaceRoleByGUIDStub        func(string, string, string, models.Role) error
	setSpaceRoleByGUIDMutex       sync.RWMutex
	setSpaceRoleByGUIDArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 models.Role
	}
	setSpaceRoleByGUIDReturns struct {
		result1 error
	}
	setSpaceRoleByGUIDReturnsOnCall map[int]struct {
		result1 error
	}
	SetSpaceRoleByUsernameStub        func(string, string, string, models.Role) error
	setSpaceRoleByUsernameMutex       sync.RWMutex
	setSpaceRoleByUsernameArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 models.Role
	}
	setSpaceRoleByUsernameReturns struct {
		result1 error
	}
	setSpaceRoleByUsernameReturnsOnCall map[int]struct {
		result1 error
	}
	UnsetOrgRoleByGUIDStub        func(string, string, models.Role) error
	unsetOrgRoleByGUIDMutex       sync.RWMutex
	unsetOrgRoleByGUIDArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 models.Role
	}
	unsetOrgRoleByGUIDReturns struct {
		result1 error
	}
	unsetOrgRoleByGUIDReturnsOnCall map[int]struct {
		result1 error
	}
	UnsetOrgRoleByUsernameStub        func(string, string, models.Role) error
	unsetOrgRoleByUsernameMutex       sync.RWMutex
	unsetOrgRoleByUsernameArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 models.Role
	}
	unsetOrgRoleByUsernameReturns struct {
		result1 error
	}
	unsetOrgRoleByUsernameReturnsOnCall map[int]struct {
		result1 error
	}
	UnsetSpaceRoleByGUIDStub        func(string, string, models.Role) error
	unsetSpaceRoleByGUIDMutex       sync.RWMutex
	unsetSpaceRoleByGUIDArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 models.Role
	}
	unsetSpaceRoleByGUIDReturns struct {
		result1 error
	}
	unsetSpaceRoleByGUIDReturnsOnCall map[int]struct {
		result1 error
	}
	UnsetSpaceRoleByUsernameStub        func(string, string, models.Role) error
	unsetSpaceRoleByUsernameMutex       sync.RWMutex
	unsetSpaceRoleByUsernameArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 models.Role
	}
	unsetSpaceRoleByUsernameReturns struct {
		result1 error
	}
	unsetSpaceRoleByUsernameReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUserRepository) Create(arg1 string, arg2 string) error {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Create", []interface{}{arg1, arg2})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createReturns
	return fakeReturns.result1
}

func (fake *FakeUserRepository) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeUserRepository) CreateCalls(stub func(string, string) error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeUserRepository) CreateArgsForCall(i int) (string, string) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) CreateReturns(result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) CreateReturnsOnCall(i int, result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) Delete(arg1 string) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteReturns
	return fakeReturns.result1
}

func (fake *FakeUserRepository) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeUserRepository) DeleteCalls(stub func(string) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeUserRepository) DeleteArgsForCall(i int) string {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) FindAllByUsername(arg1 string) ([]models.UserFields, error) {
	fake.findAllByUsernameMutex.Lock()
	ret, specificReturn := fake.findAllByUsernameReturnsOnCall[len(fake.findAllByUsernameArgsForCall)]
	fake.findAllByUsernameArgsForCall = append(fake.findAllByUsernameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindAllByUsername", []interface{}{arg1})
	fake.findAllByUsernameMutex.Unlock()
	if fake.FindAllByUsernameStub != nil {
		return fake.FindAllByUsernameStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findAllByUsernameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) FindAllByUsernameCallCount() int {
	fake.findAllByUsernameMutex.RLock()
	defer fake.findAllByUsernameMutex.RUnlock()
	return len(fake.findAllByUsernameArgsForCall)
}

func (fake *FakeUserRepository) FindAllByUsernameCalls(stub func(string) ([]models.UserFields, error)) {
	fake.findAllByUsernameMutex.Lock()
	defer fake.findAllByUsernameMutex.Unlock()
	fake.FindAllByUsernameStub = stub
}

func (fake *FakeUserRepository) FindAllByUsernameArgsForCall(i int) string {
	fake.findAllByUsernameMutex.RLock()
	defer fake.findAllByUsernameMutex.RUnlock()
	argsForCall := fake.findAllByUsernameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) FindAllByUsernameReturns(result1 []models.UserFields, result2 error) {
	fake.findAllByUsernameMutex.Lock()
	defer fake.findAllByUsernameMutex.Unlock()
	fake.FindAllByUsernameStub = nil
	fake.findAllByUsernameReturns = struct {
		result1 []models.UserFields
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) FindAllByUsernameReturnsOnCall(i int, result1 []models.UserFields, result2 error) {
	fake.findAllByUsernameMutex.Lock()
	defer fake.findAllByUsernameMutex.Unlock()
	fake.FindAllByUsernameStub = nil
	if fake.findAllByUsernameReturnsOnCall == nil {
		fake.findAllByUsernameReturnsOnCall = make(map[int]struct {
			result1 []models.UserFields
			result2 error
		})
	}
	fake.findAllByUsernameReturnsOnCall[i] = struct {
		result1 []models.UserFields
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) FindByUsername(arg1 string) (models.UserFields, error) {
	fake.findByUsernameMutex.Lock()
	ret, specificReturn := fake.findByUsernameReturnsOnCall[len(fake.findByUsernameArgsForCall)]
	fake.findByUsernameArgsForCall = append(fake.findByUsernameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindByUsername", []interface{}{arg1})
	fake.findByUsernameMutex.Unlock()
	if fake.FindByUsernameStub != nil {
		return fake.FindByUsernameStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findByUsernameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) FindByUsernameCallCount() int {
	fake.findByUsernameMutex.RLock()
	defer fake.findByUsernameMutex.RUnlock()
	return len(fake.findByUsernameArgsForCall)
}

func (fake *FakeUserRepository) FindByUsernameCalls(stub func(string) (models.UserFields, error)) {
	fake.findByUsernameMutex.Lock()
	defer fake.findByUsernameMutex.Unlock()
	fake.FindByUsernameStub = stub
}

func (fake *FakeUserRepository) FindByUsernameArgsForCall(i int) string {
	fake.findByUsernameMutex.RLock()
	defer fake.findByUsernameMutex.RUnlock()
	argsForCall := fake.findByUsernameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) FindByUsernameReturns(result1 models.UserFields, result2 error) {
	fake.findByUsernameMutex.Lock()
	defer fake.findByUsernameMutex.Unlock()
	fake.FindByUsernameStub = nil
	fake.findByUsernameReturns = struct {
		result1 models.UserFields
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) FindByUsernameReturnsOnCall(i int, result1 models.UserFields, result2 error) {
	fake.findByUsernameMutex.Lock()
	defer fake.findByUsernameMutex.Unlock()
	fake.FindByUsernameStub = nil
	if fake.findByUsernameReturnsOnCall == nil {
		fake.findByUsernameReturnsOnCall = make(map[int]struct {
			result1 models.UserFields
			result2 error
		})
	}
	fake.findByUsernameReturnsOnCall[i] = struct {
		result1 models.UserFields
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) ListUsersInOrgForRoleWithNoUAA(arg1 string, arg2 models.Role) ([]models.UserFields, error) {
	fake.listUsersInOrgForRoleWithNoUAAMutex.Lock()
	ret, specificReturn := fake.listUsersInOrgForRoleWithNoUAAReturnsOnCall[len(fake.listUsersInOrgForRoleWithNoUAAArgsForCall)]
	fake.listUsersInOrgForRoleWithNoUAAArgsForCall = append(fake.listUsersInOrgForRoleWithNoUAAArgsForCall, struct {
		arg1 string
		arg2 models.Role
	}{arg1, arg2})
	fake.recordInvocation("ListUsersInOrgForRoleWithNoUAA", []interface{}{arg1, arg2})
	fake.listUsersInOrgForRoleWithNoUAAMutex.Unlock()
	if fake.ListUsersInOrgForRoleWithNoUAAStub != nil {
		return fake.ListUsersInOrgForRoleWithNoUAAStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listUsersInOrgForRoleWithNoUAAReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) ListUsersInOrgForRoleWithNoUAACallCount() int {
	fake.listUsersInOrgForRoleWithNoUAAMutex.RLock()
	defer fake.listUsersInOrgForRoleWithNoUAAMutex.RUnlock()
	return len(fake.listUsersInOrgForRoleWithNoUAAArgsForCall)
}

func (fake *FakeUserRepository) ListUsersInOrgForRoleWithNoUAACalls(stub func(string, models.Role) ([]models.UserFields, error)) {
	fake.listUsersInOrgForRoleWithNoUAAMutex.Lock()
	defer fake.listUsersInOrgForRoleWithNoUAAMutex.Unlock()
	fake.ListUsersInOrgForRoleWithNoUAAStub = stub
}

func (fake *FakeUserRepository) ListUsersInOrgForRoleWithNoUAAArgsForCall(i int) (string, models.Role) {
	fake.listUsersInOrgForRoleWithNoUAAMutex.RLock()
	defer fake.listUsersInOrgForRoleWithNoUAAMutex.RUnlock()
	argsForCall := fake.listUsersInOrgForRoleWithNoUAAArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) ListUsersInOrgForRoleWithNoUAAReturns(result1 []models.UserFields, result2 error) {
	fake.listUsersInOrgForRoleWithNoUAAMutex.Lock()
	defer fake.listUsersInOrgForRoleWithNoUAAMutex.Unlock()
	fake.ListUsersInOrgForRoleWithNoUAAStub = nil
	fake.listUsersInOrgForRoleWithNoUAAReturns = struct {
		result1 []models.UserFields
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) ListUsersInOrgForRoleWithNoUAAReturnsOnCall(i int, result1 []models.UserFields, result2 error) {
	fake.listUsersInOrgForRoleWithNoUAAMutex.Lock()
	defer fake.listUsersInOrgForRoleWithNoUAAMutex.Unlock()
	fake.ListUsersInOrgForRoleWithNoUAAStub = nil
	if fake.listUsersInOrgForRoleWithNoUAAReturnsOnCall == nil {
		fake.listUsersInOrgForRoleWithNoUAAReturnsOnCall = make(map[int]struct {
			result1 []models.UserFields
			result2 error
		})
	}
	fake.listUsersInOrgForRoleWithNoUAAReturnsOnCall[i] = struct {
		result1 []models.UserFields
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) ListUsersInSpaceForRoleWithNoUAA(arg1 string, arg2 models.Role) ([]models.UserFields, error) {
	fake.listUsersInSpaceForRoleWithNoUAAMutex.Lock()
	ret, specificReturn := fake.listUsersInSpaceForRoleWithNoUAAReturnsOnCall[len(fake.listUsersInSpaceForRoleWithNoUAAArgsForCall)]
	fake.listUsersInSpaceForRoleWithNoUAAArgsForCall = append(fake.listUsersInSpaceForRoleWithNoUAAArgsForCall, struct {
		arg1 string
		arg2 models.Role
	}{arg1, arg2})
	fake.recordInvocation("ListUsersInSpaceForRoleWithNoUAA", []interface{}{arg1, arg2})
	fake.listUsersInSpaceForRoleWithNoUAAMutex.Unlock()
	if fake.ListUsersInSpaceForRoleWithNoUAAStub != nil {
		return fake.ListUsersInSpaceForRoleWithNoUAAStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listUsersInSpaceForRoleWithNoUAAReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) ListUsersInSpaceForRoleWithNoUAACallCount() int {
	fake.listUsersInSpaceForRoleWithNoUAAMutex.RLock()
	defer fake.listUsersInSpaceForRoleWithNoUAAMutex.RUnlock()
	return len(fake.listUsersInSpaceForRoleWithNoUAAArgsForCall)
}

func (fake *FakeUserRepository) ListUsersInSpaceForRoleWithNoUAACalls(stub func(string, models.Role) ([]models.UserFields, error)) {
	fake.listUsersInSpaceForRoleWithNoUAAMutex.Lock()
	defer fake.listUsersInSpaceForRoleWithNoUAAMutex.Unlock()
	fake.ListUsersInSpaceForRoleWithNoUAAStub = stub
}

func (fake *FakeUserRepository) ListUsersInSpaceForRoleWithNoUAAArgsForCall(i int) (string, models.Role) {
	fake.listUsersInSpaceForRoleWithNoUAAMutex.RLock()
	defer fake.listUsersInSpaceForRoleWithNoUAAMutex.RUnlock()
	argsForCall := fake.listUsersInSpaceForRoleWithNoUAAArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) ListUsersInSpaceForRoleWithNoUAAReturns(result1 []models.UserFields, result2 error) {
	fake.listUsersInSpaceForRoleWithNoUAAMutex.Lock()
	defer fake.listUsersInSpaceForRoleWithNoUAAMutex.Unlock()
	fake.ListUsersInSpaceForRoleWithNoUAAStub = nil
	fake.listUsersInSpaceForRoleWithNoUAAReturns = struct {
		result1 []models.UserFields
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) ListUsersInSpaceForRoleWithNoUAAReturnsOnCall(i int, result1 []models.UserFields, result2 error) {
	fake.listUsersInSpaceForRoleWithNoUAAMutex.Lock()
	defer fake.listUsersInSpaceForRoleWithNoUAAMutex.Unlock()
	fake.ListUsersInSpaceForRoleWithNoUAAStub = nil
	if fake.listUsersInSpaceForRoleWithNoUAAReturnsOnCall == nil {
		fake.listUsersInSpaceForRoleWithNoUAAReturnsOnCall = make(map[int]struct {
			result1 []models.UserFields
			result2 error
		})
	}
	fake.listUsersInSpaceForRoleWithNoUAAReturnsOnCall[i] = struct {
		result1 []models.UserFields
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) SetOrgRoleByGUID(arg1 string, arg2 string, arg3 models.Role) error {
	fake.setOrgRoleByGUIDMutex.Lock()
	ret, specificReturn := fake.setOrgRoleByGUIDReturnsOnCall[len(fake.setOrgRoleByGUIDArgsForCall)]
	fake.setOrgRoleByGUIDArgsForCall = append(fake.setOrgRoleByGUIDArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 models.Role
	}{arg1, arg2, arg3})
	fake.recordInvocation("SetOrgRoleByGUID", []interface{}{arg1, arg2, arg3})
	fake.setOrgRoleByGUIDMutex.Unlock()
	if fake.SetOrgRoleByGUIDStub != nil {
		return fake.SetOrgRoleByGUIDStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setOrgRoleByGUIDReturns
	return fakeReturns.result1
}

func (fake *FakeUserRepository) SetOrgRoleByGUIDCallCount() int {
	fake.setOrgRoleByGUIDMutex.RLock()
	defer fake.setOrgRoleByGUIDMutex.RUnlock()
	return len(fake.setOrgRoleByGUIDArgsForCall)
}

func (fake *FakeUserRepository) SetOrgRoleByGUIDCalls(stub func(string, string, models.Role) error) {
	fake.setOrgRoleByGUIDMutex.Lock()
	defer fake.setOrgRoleByGUIDMutex.Unlock()
	fake.SetOrgRoleByGUIDStub = stub
}

func (fake *FakeUserRepository) SetOrgRoleByGUIDArgsForCall(i int) (string, string, models.Role) {
	fake.setOrgRoleByGUIDMutex.RLock()
	defer fake.setOrgRoleByGUIDMutex.RUnlock()
	argsForCall := fake.setOrgRoleByGUIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserRepository) SetOrgRoleByGUIDReturns(result1 error) {
	fake.setOrgRoleByGUIDMutex.Lock()
	defer fake.setOrgRoleByGUIDMutex.Unlock()
	fake.SetOrgRoleByGUIDStub = nil
	fake.setOrgRoleByGUIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) SetOrgRoleByGUIDReturnsOnCall(i int, result1 error) {
	fake.setOrgRoleByGUIDMutex.Lock()
	defer fake.setOrgRoleByGUIDMutex.Unlock()
	fake.SetOrgRoleByGUIDStub = nil
	if fake.setOrgRoleByGUIDReturnsOnCall == nil {
		fake.setOrgRoleByGUIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setOrgRoleByGUIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) SetOrgRoleByUsername(arg1 string, arg2 string, arg3 models.Role) error {
	fake.setOrgRoleByUsernameMutex.Lock()
	ret, specificReturn := fake.setOrgRoleByUsernameReturnsOnCall[len(fake.setOrgRoleByUsernameArgsForCall)]
	fake.setOrgRoleByUsernameArgsForCall = append(fake.setOrgRoleByUsernameArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 models.Role
	}{arg1, arg2, arg3})
	fake.recordInvocation("SetOrgRoleByUsername", []interface{}{arg1, arg2, arg3})
	fake.setOrgRoleByUsernameMutex.Unlock()
	if fake.SetOrgRoleByUsernameStub != nil {
		return fake.SetOrgRoleByUsernameStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setOrgRoleByUsernameReturns
	return fakeReturns.result1
}

func (fake *FakeUserRepository) SetOrgRoleByUsernameCallCount() int {
	fake.setOrgRoleByUsernameMutex.RLock()
	defer fake.setOrgRoleByUsernameMutex.RUnlock()
	return len(fake.setOrgRoleByUsernameArgsForCall)
}

func (fake *FakeUserRepository) SetOrgRoleByUsernameCalls(stub func(string, string, models.Role) error) {
	fake.setOrgRoleByUsernameMutex.Lock()
	defer fake.setOrgRoleByUsernameMutex.Unlock()
	fake.SetOrgRoleByUsernameStub = stub
}

func (fake *FakeUserRepository) SetOrgRoleByUsernameArgsForCall(i int) (string, string, models.Role) {
	fake.setOrgRoleByUsernameMutex.RLock()
	defer fake.setOrgRoleByUsernameMutex.RUnlock()
	argsForCall := fake.setOrgRoleByUsernameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserRepository) SetOrgRoleByUsernameReturns(result1 error) {
	fake.setOrgRoleByUsernameMutex.Lock()
	defer fake.setOrgRoleByUsernameMutex.Unlock()
	fake.SetOrgRoleByUsernameStub = nil
	fake.setOrgRoleByUsernameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) SetOrgRoleByUsernameReturnsOnCall(i int, result1 error) {
	fake.setOrgRoleByUsernameMutex.Lock()
	defer fake.setOrgRoleByUsernameMutex.Unlock()
	fake.SetOrgRoleByUsernameStub = nil
	if fake.setOrgRoleByUsernameReturnsOnCall == nil {
		fake.setOrgRoleByUsernameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setOrgRoleByUsernameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) SetSpaceRoleByGUID(arg1 string, arg2 string, arg3 string, arg4 models.Role) error {
	fake.setSpaceRoleByGUIDMutex.Lock()
	ret, specificReturn := fake.setSpaceRoleByGUIDReturnsOnCall[len(fake.setSpaceRoleByGUIDArgsForCall)]
	fake.setSpaceRoleByGUIDArgsForCall = append(fake.setSpaceRoleByGUIDArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 models.Role
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("SetSpaceRoleByGUID", []interface{}{arg1, arg2, arg3, arg4})
	fake.setSpaceRoleByGUIDMutex.Unlock()
	if fake.SetSpaceRoleByGUIDStub != nil {
		return fake.SetSpaceRoleByGUIDStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setSpaceRoleByGUIDReturns
	return fakeReturns.result1
}

func (fake *FakeUserRepository) SetSpaceRoleByGUIDCallCount() int {
	fake.setSpaceRoleByGUIDMutex.RLock()
	defer fake.setSpaceRoleByGUIDMutex.RUnlock()
	return len(fake.setSpaceRoleByGUIDArgsForCall)
}

func (fake *FakeUserRepository) SetSpaceRoleByGUIDCalls(stub func(string, string, string, models.Role) error) {
	fake.setSpaceRoleByGUIDMutex.Lock()
	defer fake.setSpaceRoleByGUIDMutex.Unlock()
	fake.SetSpaceRoleByGUIDStub = stub
}

func (fake *FakeUserRepository) SetSpaceRoleByGUIDArgsForCall(i int) (string, string, string, models.Role) {
	fake.setSpaceRoleByGUIDMutex.RLock()
	defer fake.setSpaceRoleByGUIDMutex.RUnlock()
	argsForCall := fake.setSpaceRoleByGUIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeUserRepository) SetSpaceRoleByGUIDReturns(result1 error) {
	fake.setSpaceRoleByGUIDMutex.Lock()
	defer fake.setSpaceRoleByGUIDMutex.Unlock()
	fake.SetSpaceRoleByGUIDStub = nil
	fake.setSpaceRoleByGUIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) SetSpaceRoleByGUIDReturnsOnCall(i int, result1 error) {
	fake.setSpaceRoleByGUIDMutex.Lock()
	defer fake.setSpaceRoleByGUIDMutex.Unlock()
	fake.SetSpaceRoleByGUIDStub = nil
	if fake.setSpaceRoleByGUIDReturnsOnCall == nil {
		fake.setSpaceRoleByGUIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setSpaceRoleByGUIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) SetSpaceRoleByUsername(arg1 string, arg2 string, arg3 string, arg4 models.Role) error {
	fake.setSpaceRoleByUsernameMutex.Lock()
	ret, specificReturn := fake.setSpaceRoleByUsernameReturnsOnCall[len(fake.setSpaceRoleByUsernameArgsForCall)]
	fake.setSpaceRoleByUsernameArgsForCall = append(fake.setSpaceRoleByUsernameArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 models.Role
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("SetSpaceRoleByUsername", []interface{}{arg1, arg2, arg3, arg4})
	fake.setSpaceRoleByUsernameMutex.Unlock()
	if fake.SetSpaceRoleByUsernameStub != nil {
		return fake.SetSpaceRoleByUsernameStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setSpaceRoleByUsernameReturns
	return fakeReturns.result1
}

func (fake *FakeUserRepository) SetSpaceRoleByUsernameCallCount() int {
	fake.setSpaceRoleByUsernameMutex.RLock()
	defer fake.setSpaceRoleByUsernameMutex.RUnlock()
	return len(fake.setSpaceRoleByUsernameArgsForCall)
}

func (fake *FakeUserRepository) SetSpaceRoleByUsernameCalls(stub func(string, string, string, models.Role) error) {
	fake.setSpaceRoleByUsernameMutex.Lock()
	defer fake.setSpaceRoleByUsernameMutex.Unlock()
	fake.SetSpaceRoleByUsernameStub = stub
}

func (fake *FakeUserRepository) SetSpaceRoleByUsernameArgsForCall(i int) (string, string, string, models.Role) {
	fake.setSpaceRoleByUsernameMutex.RLock()
	defer fake.setSpaceRoleByUsernameMutex.RUnlock()
	argsForCall := fake.setSpaceRoleByUsernameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeUserRepository) SetSpaceRoleByUsernameReturns(result1 error) {
	fake.setSpaceRoleByUsernameMutex.Lock()
	defer fake.setSpaceRoleByUsernameMutex.Unlock()
	fake.SetSpaceRoleByUsernameStub = nil
	fake.setSpaceRoleByUsernameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) SetSpaceRoleByUsernameReturnsOnCall(i int, result1 error) {
	fake.setSpaceRoleByUsernameMutex.Lock()
	defer fake.setSpaceRoleByUsernameMutex.Unlock()
	fake.SetSpaceRoleByUsernameStub = nil
	if fake.setSpaceRoleByUsernameReturnsOnCall == nil {
		fake.setSpaceRoleByUsernameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setSpaceRoleByUsernameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) UnsetOrgRoleByGUID(arg1 string, arg2 string, arg3 models.Role) error {
	fake.unsetOrgRoleByGUIDMutex.Lock()
	ret, specificReturn := fake.unsetOrgRoleByGUIDReturnsOnCall[len(fake.unsetOrgRoleByGUIDArgsForCall)]
	fake.unsetOrgRoleByGUIDArgsForCall = append(fake.unsetOrgRoleByGUIDArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 models.Role
	}{arg1, arg2, arg3})
	fake.recordInvocation("UnsetOrgRoleByGUID", []interface{}{arg1, arg2, arg3})
	fake.unsetOrgRoleByGUIDMutex.Unlock()
	if fake.UnsetOrgRoleByGUIDStub != nil {
		return fake.UnsetOrgRoleByGUIDStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.unsetOrgRoleByGUIDReturns
	return fakeReturns.result1
}

func (fake *FakeUserRepository) UnsetOrgRoleByGUIDCallCount() int {
	fake.unsetOrgRoleByGUIDMutex.RLock()
	defer fake.unsetOrgRoleByGUIDMutex.RUnlock()
	return len(fake.unsetOrgRoleByGUIDArgsForCall)
}

func (fake *FakeUserRepository) UnsetOrgRoleByGUIDCalls(stub func(string, string, models.Role) error) {
	fake.unsetOrgRoleByGUIDMutex.Lock()
	defer fake.unsetOrgRoleByGUIDMutex.Unlock()
	fake.UnsetOrgRoleByGUIDStub = stub
}

func (fake *FakeUserRepository) UnsetOrgRoleByGUIDArgsForCall(i int) (string, string, models.Role) {
	fake.unsetOrgRoleByGUIDMutex.RLock()
	defer fake.unsetOrgRoleByGUIDMutex.RUnlock()
	argsForCall := fake.unsetOrgRoleByGUIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserRepository) UnsetOrgRoleByGUIDReturns(result1 error) {
	fake.unsetOrgRoleByGUIDMutex.Lock()
	defer fake.unsetOrgRoleByGUIDMutex.Unlock()
	fake.UnsetOrgRoleByGUIDStub = nil
	fake.unsetOrgRoleByGUIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) UnsetOrgRoleByGUIDReturnsOnCall(i int, result1 error) {
	fake.unsetOrgRoleByGUIDMutex.Lock()
	defer fake.unsetOrgRoleByGUIDMutex.Unlock()
	fake.UnsetOrgRoleByGUIDStub = nil
	if fake.unsetOrgRoleByGUIDReturnsOnCall == nil {
		fake.unsetOrgRoleByGUIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unsetOrgRoleByGUIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) UnsetOrgRoleByUsername(arg1 string, arg2 string, arg3 models.Role) error {
	fake.unsetOrgRoleByUsernameMutex.Lock()
	ret, specificReturn := fake.unsetOrgRoleByUsernameReturnsOnCall[len(fake.unsetOrgRoleByUsernameArgsForCall)]
	fake.unsetOrgRoleByUsernameArgsForCall = append(fake.unsetOrgRoleByUsernameArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 models.Role
	}{arg1, arg2, arg3})
	fake.recordInvocation("UnsetOrgRoleByUsername", []interface{}{arg1, arg2, arg3})
	fake.unsetOrgRoleByUsernameMutex.Unlock()
	if fake.UnsetOrgRoleByUsernameStub != nil {
		return fake.UnsetOrgRoleByUsernameStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.unsetOrgRoleByUsernameReturns
	return fakeReturns.result1
}

func (fake *FakeUserRepository) UnsetOrgRoleByUsernameCallCount() int {
	fake.unsetOrgRoleByUsernameMutex.RLock()
	defer fake.unsetOrgRoleByUsernameMutex.RUnlock()
	return len(fake.unsetOrgRoleByUsernameArgsForCall)
}

func (fake *FakeUserRepository) UnsetOrgRoleByUsernameCalls(stub func(string, string, models.Role) error) {
	fake.unsetOrgRoleByUsernameMutex.Lock()
	defer fake.unsetOrgRoleByUsernameMutex.Unlock()
	fake.UnsetOrgRoleByUsernameStub = stub
}

func (fake *FakeUserRepository) UnsetOrgRoleByUsernameArgsForCall(i int) (string, string, models.Role) {
	fake.unsetOrgRoleByUsernameMutex.RLock()
	defer fake.unsetOrgRoleByUsernameMutex.RUnlock()
	argsForCall := fake.unsetOrgRoleByUsernameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserRepository) UnsetOrgRoleByUsernameReturns(result1 error) {
	fake.unsetOrgRoleByUsernameMutex.Lock()
	defer fake.unsetOrgRoleByUsernameMutex.Unlock()
	fake.UnsetOrgRoleByUsernameStub = nil
	fake.unsetOrgRoleByUsernameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) UnsetOrgRoleByUsernameReturnsOnCall(i int, result1 error) {
	fake.unsetOrgRoleByUsernameMutex.Lock()
	defer fake.unsetOrgRoleByUsernameMutex.Unlock()
	fake.UnsetOrgRoleByUsernameStub = nil
	if fake.unsetOrgRoleByUsernameReturnsOnCall == nil {
		fake.unsetOrgRoleByUsernameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unsetOrgRoleByUsernameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) UnsetSpaceRoleByGUID(arg1 string, arg2 string, arg3 models.Role) error {
	fake.unsetSpaceRoleByGUIDMutex.Lock()
	ret, specificReturn := fake.unsetSpaceRoleByGUIDReturnsOnCall[len(fake.unsetSpaceRoleByGUIDArgsForCall)]
	fake.unsetSpaceRoleByGUIDArgsForCall = append(fake.unsetSpaceRoleByGUIDArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 models.Role
	}{arg1, arg2, arg3})
	fake.recordInvocation("UnsetSpaceRoleByGUID", []interface{}{arg1, arg2, arg3})
	fake.unsetSpaceRoleByGUIDMutex.Unlock()
	if fake.UnsetSpaceRoleByGUIDStub != nil {
		return fake.UnsetSpaceRoleByGUIDStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.unsetSpaceRoleByGUIDReturns
	return fakeReturns.result1
}

func (fake *FakeUserRepository) UnsetSpaceRoleByGUIDCallCount() int {
	fake.unsetSpaceRoleByGUIDMutex.RLock()
	defer fake.unsetSpaceRoleByGUIDMutex.RUnlock()
	return len(fake.unsetSpaceRoleByGUIDArgsForCall)
}

func (fake *FakeUserRepository) UnsetSpaceRoleByGUIDCalls(stub func(string, string, models.Role) error) {
	fake.unsetSpaceRoleByGUIDMutex.Lock()
	defer fake.unsetSpaceRoleByGUIDMutex.Unlock()
	fake.UnsetSpaceRoleByGUIDStub = stub
}

func (fake *FakeUserRepository) UnsetSpaceRoleByGUIDArgsForCall(i int) (string, string, models.Role) {
	fake.unsetSpaceRoleByGUIDMutex.RLock()
	defer fake.unsetSpaceRoleByGUIDMutex.RUnlock()
	argsForCall := fake.unsetSpaceRoleByGUIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserRepository) UnsetSpaceRoleByGUIDReturns(result1 error) {
	fake.unsetSpaceRoleByGUIDMutex.Lock()
	defer fake.unsetSpaceRoleByGUIDMutex.Unlock()
	fake.UnsetSpaceRoleByGUIDStub = nil
	fake.unsetSpaceRoleByGUIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) UnsetSpaceRoleByGUIDReturnsOnCall(i int, result1 error) {
	fake.unsetSpaceRoleByGUIDMutex.Lock()
	defer fake.unsetSpaceRoleByGUIDMutex.Unlock()
	fake.UnsetSpaceRoleByGUIDStub = nil
	if fake.unsetSpaceRoleByGUIDReturnsOnCall == nil {
		fake.unsetSpaceRoleByGUIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unsetSpaceRoleByGUIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) UnsetSpaceRoleByUsername(arg1 string, arg2 string, arg3 models.Role) error {
	fake.unsetSpaceRoleByUsernameMutex.Lock()
	ret, specificReturn := fake.unsetSpaceRoleByUsernameReturnsOnCall[len(fake.unsetSpaceRoleByUsernameArgsForCall)]
	fake.unsetSpaceRoleByUsernameArgsForCall = append(fake.unsetSpaceRoleByUsernameArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 models.Role
	}{arg1, arg2, arg3})
	fake.recordInvocation("UnsetSpaceRoleByUsername", []interface{}{arg1, arg2, arg3})
	fake.unsetSpaceRoleByUsernameMutex.Unlock()
	if fake.UnsetSpaceRoleByUsernameStub != nil {
		return fake.UnsetSpaceRoleByUsernameStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.unsetSpaceRoleByUsernameReturns
	return fakeReturns.result1
}

func (fake *FakeUserRepository) UnsetSpaceRoleByUsernameCallCount() int {
	fake.unsetSpaceRoleByUsernameMutex.RLock()
	defer fake.unsetSpaceRoleByUsernameMutex.RUnlock()
	return len(fake.unsetSpaceRoleByUsernameArgsForCall)
}

func (fake *FakeUserRepository) UnsetSpaceRoleByUsernameCalls(stub func(string, string, models.Role) error) {
	fake.unsetSpaceRoleByUsernameMutex.Lock()
	defer fake.unsetSpaceRoleByUsernameMutex.Unlock()
	fake.UnsetSpaceRoleByUsernameStub = stub
}

func (fake *FakeUserRepository) UnsetSpaceRoleByUsernameArgsForCall(i int) (string, string, models.Role) {
	fake.unsetSpaceRoleByUsernameMutex.RLock()
	defer fake.unsetSpaceRoleByUsernameMutex.RUnlock()
	argsForCall := fake.unsetSpaceRoleByUsernameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserRepository) UnsetSpaceRoleByUsernameReturns(result1 error) {
	fake.unsetSpaceRoleByUsernameMutex.Lock()
	defer fake.unsetSpaceRoleByUsernameMutex.Unlock()
	fake.UnsetSpaceRoleByUsernameStub = nil
	fake.unsetSpaceRoleByUsernameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) UnsetSpaceRoleByUsernameReturnsOnCall(i int, result1 error) {
	fake.unsetSpaceRoleByUsernameMutex.Lock()
	defer fake.unsetSpaceRoleByUsernameMutex.Unlock()
	fake.UnsetSpaceRoleByUsernameStub = nil
	if fake.unsetSpaceRoleByUsernameReturnsOnCall == nil {
		fake.unsetSpaceRoleByUsernameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unsetSpaceRoleByUsernameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.findAllByUsernameMutex.RLock()
	defer fake.findAllByUsernameMutex.RUnlock()
	fake.findByUsernameMutex.RLock()
	defer fake.findByUsernameMutex.RUnlock()
	fake.listUsersInOrgForRoleWithNoUAAMutex.RLock()
	defer fake.listUsersInOrgForRoleWithNoUAAMutex.RUnlock()
	fake.listUsersInSpaceForRoleWithNoUAAMutex.RLock()
	defer fake.listUsersInSpaceForRoleWithNoUAAMutex.RUnlock()
	fake.setOrgRoleByGUIDMutex.RLock()
	defer fake.setOrgRoleByGUIDMutex.RUnlock()
	fake.setOrgRoleByUsernameMutex.RLock()
	defer fake.setOrgRoleByUsernameMutex.RUnlock()
	fake.setSpaceRoleByGUIDMutex.RLock()
	defer fake.setSpaceRoleByGUIDMutex.RUnlock()
	fake.setSpaceRoleByUsernameMutex.RLock()
	defer fake.setSpaceRoleByUsernameMutex.RUnlock()
	fake.unsetOrgRoleByGUIDMutex.RLock()
	defer fake.unsetOrgRoleByGUIDMutex.RUnlock()
	fake.unsetOrgRoleByUsernameMutex.RLock()
	defer fake.unsetOrgRoleByUsernameMutex.RUnlock()
	fake.unsetSpaceRoleByGUIDMutex.RLock()
	defer fake.unsetSpaceRoleByGUIDMutex.RUnlock()
	fake.unsetSpaceRoleByUsernameMutex.RLock()
	defer fake.unsetSpaceRoleByUsernameMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUserRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.UserRepository = new(FakeUserRepository)
