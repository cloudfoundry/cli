// Code generated by counterfeiter. DO NOT EDIT.
package apifakes

import (
	"sync"

	"code.cloudfoundry.org/cli/cf/api"
	"code.cloudfoundry.org/cli/cf/models"
)

type FakeDomainRepository struct {
	CreateStub        func(string, string) (models.DomainFields, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createReturns struct {
		result1 models.DomainFields
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 models.DomainFields
		result2 error
	}
	CreateSharedDomainStub        func(string, string) error
	createSharedDomainMutex       sync.RWMutex
	createSharedDomainArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createSharedDomainReturns struct {
		result1 error
	}
	createSharedDomainReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(string) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 string
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteSharedDomainStub        func(string) error
	deleteSharedDomainMutex       sync.RWMutex
	deleteSharedDomainArgsForCall []struct {
		arg1 string
	}
	deleteSharedDomainReturns struct {
		result1 error
	}
	deleteSharedDomainReturnsOnCall map[int]struct {
		result1 error
	}
	FindByNameInOrgStub        func(string, string) (models.DomainFields, error)
	findByNameInOrgMutex       sync.RWMutex
	findByNameInOrgArgsForCall []struct {
		arg1 string
		arg2 string
	}
	findByNameInOrgReturns struct {
		result1 models.DomainFields
		result2 error
	}
	findByNameInOrgReturnsOnCall map[int]struct {
		result1 models.DomainFields
		result2 error
	}
	FindPrivateByNameStub        func(string) (models.DomainFields, error)
	findPrivateByNameMutex       sync.RWMutex
	findPrivateByNameArgsForCall []struct {
		arg1 string
	}
	findPrivateByNameReturns struct {
		result1 models.DomainFields
		result2 error
	}
	findPrivateByNameReturnsOnCall map[int]struct {
		result1 models.DomainFields
		result2 error
	}
	FindSharedByNameStub        func(string) (models.DomainFields, error)
	findSharedByNameMutex       sync.RWMutex
	findSharedByNameArgsForCall []struct {
		arg1 string
	}
	findSharedByNameReturns struct {
		result1 models.DomainFields
		result2 error
	}
	findSharedByNameReturnsOnCall map[int]struct {
		result1 models.DomainFields
		result2 error
	}
	FirstOrDefaultStub        func(string, *string) (models.DomainFields, error)
	firstOrDefaultMutex       sync.RWMutex
	firstOrDefaultArgsForCall []struct {
		arg1 string
		arg2 *string
	}
	firstOrDefaultReturns struct {
		result1 models.DomainFields
		result2 error
	}
	firstOrDefaultReturnsOnCall map[int]struct {
		result1 models.DomainFields
		result2 error
	}
	ListDomainsForOrgStub        func(string, func(models.DomainFields) bool) error
	listDomainsForOrgMutex       sync.RWMutex
	listDomainsForOrgArgsForCall []struct {
		arg1 string
		arg2 func(models.DomainFields) bool
	}
	listDomainsForOrgReturns struct {
		result1 error
	}
	listDomainsForOrgReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDomainRepository) Create(arg1 string, arg2 string) (models.DomainFields, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Create", []interface{}{arg1, arg2})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDomainRepository) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeDomainRepository) CreateCalls(stub func(string, string) (models.DomainFields, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeDomainRepository) CreateArgsForCall(i int) (string, string) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDomainRepository) CreateReturns(result1 models.DomainFields, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 models.DomainFields
		result2 error
	}{result1, result2}
}

func (fake *FakeDomainRepository) CreateReturnsOnCall(i int, result1 models.DomainFields, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 models.DomainFields
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 models.DomainFields
		result2 error
	}{result1, result2}
}

func (fake *FakeDomainRepository) CreateSharedDomain(arg1 string, arg2 string) error {
	fake.createSharedDomainMutex.Lock()
	ret, specificReturn := fake.createSharedDomainReturnsOnCall[len(fake.createSharedDomainArgsForCall)]
	fake.createSharedDomainArgsForCall = append(fake.createSharedDomainArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("CreateSharedDomain", []interface{}{arg1, arg2})
	fake.createSharedDomainMutex.Unlock()
	if fake.CreateSharedDomainStub != nil {
		return fake.CreateSharedDomainStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createSharedDomainReturns
	return fakeReturns.result1
}

func (fake *FakeDomainRepository) CreateSharedDomainCallCount() int {
	fake.createSharedDomainMutex.RLock()
	defer fake.createSharedDomainMutex.RUnlock()
	return len(fake.createSharedDomainArgsForCall)
}

func (fake *FakeDomainRepository) CreateSharedDomainCalls(stub func(string, string) error) {
	fake.createSharedDomainMutex.Lock()
	defer fake.createSharedDomainMutex.Unlock()
	fake.CreateSharedDomainStub = stub
}

func (fake *FakeDomainRepository) CreateSharedDomainArgsForCall(i int) (string, string) {
	fake.createSharedDomainMutex.RLock()
	defer fake.createSharedDomainMutex.RUnlock()
	argsForCall := fake.createSharedDomainArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDomainRepository) CreateSharedDomainReturns(result1 error) {
	fake.createSharedDomainMutex.Lock()
	defer fake.createSharedDomainMutex.Unlock()
	fake.CreateSharedDomainStub = nil
	fake.createSharedDomainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDomainRepository) CreateSharedDomainReturnsOnCall(i int, result1 error) {
	fake.createSharedDomainMutex.Lock()
	defer fake.createSharedDomainMutex.Unlock()
	fake.CreateSharedDomainStub = nil
	if fake.createSharedDomainReturnsOnCall == nil {
		fake.createSharedDomainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createSharedDomainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDomainRepository) Delete(arg1 string) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteReturns
	return fakeReturns.result1
}

func (fake *FakeDomainRepository) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeDomainRepository) DeleteCalls(stub func(string) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeDomainRepository) DeleteArgsForCall(i int) string {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDomainRepository) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDomainRepository) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDomainRepository) DeleteSharedDomain(arg1 string) error {
	fake.deleteSharedDomainMutex.Lock()
	ret, specificReturn := fake.deleteSharedDomainReturnsOnCall[len(fake.deleteSharedDomainArgsForCall)]
	fake.deleteSharedDomainArgsForCall = append(fake.deleteSharedDomainArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteSharedDomain", []interface{}{arg1})
	fake.deleteSharedDomainMutex.Unlock()
	if fake.DeleteSharedDomainStub != nil {
		return fake.DeleteSharedDomainStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteSharedDomainReturns
	return fakeReturns.result1
}

func (fake *FakeDomainRepository) DeleteSharedDomainCallCount() int {
	fake.deleteSharedDomainMutex.RLock()
	defer fake.deleteSharedDomainMutex.RUnlock()
	return len(fake.deleteSharedDomainArgsForCall)
}

func (fake *FakeDomainRepository) DeleteSharedDomainCalls(stub func(string) error) {
	fake.deleteSharedDomainMutex.Lock()
	defer fake.deleteSharedDomainMutex.Unlock()
	fake.DeleteSharedDomainStub = stub
}

func (fake *FakeDomainRepository) DeleteSharedDomainArgsForCall(i int) string {
	fake.deleteSharedDomainMutex.RLock()
	defer fake.deleteSharedDomainMutex.RUnlock()
	argsForCall := fake.deleteSharedDomainArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDomainRepository) DeleteSharedDomainReturns(result1 error) {
	fake.deleteSharedDomainMutex.Lock()
	defer fake.deleteSharedDomainMutex.Unlock()
	fake.DeleteSharedDomainStub = nil
	fake.deleteSharedDomainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDomainRepository) DeleteSharedDomainReturnsOnCall(i int, result1 error) {
	fake.deleteSharedDomainMutex.Lock()
	defer fake.deleteSharedDomainMutex.Unlock()
	fake.DeleteSharedDomainStub = nil
	if fake.deleteSharedDomainReturnsOnCall == nil {
		fake.deleteSharedDomainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSharedDomainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDomainRepository) FindByNameInOrg(arg1 string, arg2 string) (models.DomainFields, error) {
	fake.findByNameInOrgMutex.Lock()
	ret, specificReturn := fake.findByNameInOrgReturnsOnCall[len(fake.findByNameInOrgArgsForCall)]
	fake.findByNameInOrgArgsForCall = append(fake.findByNameInOrgArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("FindByNameInOrg", []interface{}{arg1, arg2})
	fake.findByNameInOrgMutex.Unlock()
	if fake.FindByNameInOrgStub != nil {
		return fake.FindByNameInOrgStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findByNameInOrgReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDomainRepository) FindByNameInOrgCallCount() int {
	fake.findByNameInOrgMutex.RLock()
	defer fake.findByNameInOrgMutex.RUnlock()
	return len(fake.findByNameInOrgArgsForCall)
}

func (fake *FakeDomainRepository) FindByNameInOrgCalls(stub func(string, string) (models.DomainFields, error)) {
	fake.findByNameInOrgMutex.Lock()
	defer fake.findByNameInOrgMutex.Unlock()
	fake.FindByNameInOrgStub = stub
}

func (fake *FakeDomainRepository) FindByNameInOrgArgsForCall(i int) (string, string) {
	fake.findByNameInOrgMutex.RLock()
	defer fake.findByNameInOrgMutex.RUnlock()
	argsForCall := fake.findByNameInOrgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDomainRepository) FindByNameInOrgReturns(result1 models.DomainFields, result2 error) {
	fake.findByNameInOrgMutex.Lock()
	defer fake.findByNameInOrgMutex.Unlock()
	fake.FindByNameInOrgStub = nil
	fake.findByNameInOrgReturns = struct {
		result1 models.DomainFields
		result2 error
	}{result1, result2}
}

func (fake *FakeDomainRepository) FindByNameInOrgReturnsOnCall(i int, result1 models.DomainFields, result2 error) {
	fake.findByNameInOrgMutex.Lock()
	defer fake.findByNameInOrgMutex.Unlock()
	fake.FindByNameInOrgStub = nil
	if fake.findByNameInOrgReturnsOnCall == nil {
		fake.findByNameInOrgReturnsOnCall = make(map[int]struct {
			result1 models.DomainFields
			result2 error
		})
	}
	fake.findByNameInOrgReturnsOnCall[i] = struct {
		result1 models.DomainFields
		result2 error
	}{result1, result2}
}

func (fake *FakeDomainRepository) FindPrivateByName(arg1 string) (models.DomainFields, error) {
	fake.findPrivateByNameMutex.Lock()
	ret, specificReturn := fake.findPrivateByNameReturnsOnCall[len(fake.findPrivateByNameArgsForCall)]
	fake.findPrivateByNameArgsForCall = append(fake.findPrivateByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindPrivateByName", []interface{}{arg1})
	fake.findPrivateByNameMutex.Unlock()
	if fake.FindPrivateByNameStub != nil {
		return fake.FindPrivateByNameStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findPrivateByNameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDomainRepository) FindPrivateByNameCallCount() int {
	fake.findPrivateByNameMutex.RLock()
	defer fake.findPrivateByNameMutex.RUnlock()
	return len(fake.findPrivateByNameArgsForCall)
}

func (fake *FakeDomainRepository) FindPrivateByNameCalls(stub func(string) (models.DomainFields, error)) {
	fake.findPrivateByNameMutex.Lock()
	defer fake.findPrivateByNameMutex.Unlock()
	fake.FindPrivateByNameStub = stub
}

func (fake *FakeDomainRepository) FindPrivateByNameArgsForCall(i int) string {
	fake.findPrivateByNameMutex.RLock()
	defer fake.findPrivateByNameMutex.RUnlock()
	argsForCall := fake.findPrivateByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDomainRepository) FindPrivateByNameReturns(result1 models.DomainFields, result2 error) {
	fake.findPrivateByNameMutex.Lock()
	defer fake.findPrivateByNameMutex.Unlock()
	fake.FindPrivateByNameStub = nil
	fake.findPrivateByNameReturns = struct {
		result1 models.DomainFields
		result2 error
	}{result1, result2}
}

func (fake *FakeDomainRepository) FindPrivateByNameReturnsOnCall(i int, result1 models.DomainFields, result2 error) {
	fake.findPrivateByNameMutex.Lock()
	defer fake.findPrivateByNameMutex.Unlock()
	fake.FindPrivateByNameStub = nil
	if fake.findPrivateByNameReturnsOnCall == nil {
		fake.findPrivateByNameReturnsOnCall = make(map[int]struct {
			result1 models.DomainFields
			result2 error
		})
	}
	fake.findPrivateByNameReturnsOnCall[i] = struct {
		result1 models.DomainFields
		result2 error
	}{result1, result2}
}

func (fake *FakeDomainRepository) FindSharedByName(arg1 string) (models.DomainFields, error) {
	fake.findSharedByNameMutex.Lock()
	ret, specificReturn := fake.findSharedByNameReturnsOnCall[len(fake.findSharedByNameArgsForCall)]
	fake.findSharedByNameArgsForCall = append(fake.findSharedByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindSharedByName", []interface{}{arg1})
	fake.findSharedByNameMutex.Unlock()
	if fake.FindSharedByNameStub != nil {
		return fake.FindSharedByNameStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findSharedByNameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDomainRepository) FindSharedByNameCallCount() int {
	fake.findSharedByNameMutex.RLock()
	defer fake.findSharedByNameMutex.RUnlock()
	return len(fake.findSharedByNameArgsForCall)
}

func (fake *FakeDomainRepository) FindSharedByNameCalls(stub func(string) (models.DomainFields, error)) {
	fake.findSharedByNameMutex.Lock()
	defer fake.findSharedByNameMutex.Unlock()
	fake.FindSharedByNameStub = stub
}

func (fake *FakeDomainRepository) FindSharedByNameArgsForCall(i int) string {
	fake.findSharedByNameMutex.RLock()
	defer fake.findSharedByNameMutex.RUnlock()
	argsForCall := fake.findSharedByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDomainRepository) FindSharedByNameReturns(result1 models.DomainFields, result2 error) {
	fake.findSharedByNameMutex.Lock()
	defer fake.findSharedByNameMutex.Unlock()
	fake.FindSharedByNameStub = nil
	fake.findSharedByNameReturns = struct {
		result1 models.DomainFields
		result2 error
	}{result1, result2}
}

func (fake *FakeDomainRepository) FindSharedByNameReturnsOnCall(i int, result1 models.DomainFields, result2 error) {
	fake.findSharedByNameMutex.Lock()
	defer fake.findSharedByNameMutex.Unlock()
	fake.FindSharedByNameStub = nil
	if fake.findSharedByNameReturnsOnCall == nil {
		fake.findSharedByNameReturnsOnCall = make(map[int]struct {
			result1 models.DomainFields
			result2 error
		})
	}
	fake.findSharedByNameReturnsOnCall[i] = struct {
		result1 models.DomainFields
		result2 error
	}{result1, result2}
}

func (fake *FakeDomainRepository) FirstOrDefault(arg1 string, arg2 *string) (models.DomainFields, error) {
	fake.firstOrDefaultMutex.Lock()
	ret, specificReturn := fake.firstOrDefaultReturnsOnCall[len(fake.firstOrDefaultArgsForCall)]
	fake.firstOrDefaultArgsForCall = append(fake.firstOrDefaultArgsForCall, struct {
		arg1 string
		arg2 *string
	}{arg1, arg2})
	fake.recordInvocation("FirstOrDefault", []interface{}{arg1, arg2})
	fake.firstOrDefaultMutex.Unlock()
	if fake.FirstOrDefaultStub != nil {
		return fake.FirstOrDefaultStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.firstOrDefaultReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDomainRepository) FirstOrDefaultCallCount() int {
	fake.firstOrDefaultMutex.RLock()
	defer fake.firstOrDefaultMutex.RUnlock()
	return len(fake.firstOrDefaultArgsForCall)
}

func (fake *FakeDomainRepository) FirstOrDefaultCalls(stub func(string, *string) (models.DomainFields, error)) {
	fake.firstOrDefaultMutex.Lock()
	defer fake.firstOrDefaultMutex.Unlock()
	fake.FirstOrDefaultStub = stub
}

func (fake *FakeDomainRepository) FirstOrDefaultArgsForCall(i int) (string, *string) {
	fake.firstOrDefaultMutex.RLock()
	defer fake.firstOrDefaultMutex.RUnlock()
	argsForCall := fake.firstOrDefaultArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDomainRepository) FirstOrDefaultReturns(result1 models.DomainFields, result2 error) {
	fake.firstOrDefaultMutex.Lock()
	defer fake.firstOrDefaultMutex.Unlock()
	fake.FirstOrDefaultStub = nil
	fake.firstOrDefaultReturns = struct {
		result1 models.DomainFields
		result2 error
	}{result1, result2}
}

func (fake *FakeDomainRepository) FirstOrDefaultReturnsOnCall(i int, result1 models.DomainFields, result2 error) {
	fake.firstOrDefaultMutex.Lock()
	defer fake.firstOrDefaultMutex.Unlock()
	fake.FirstOrDefaultStub = nil
	if fake.firstOrDefaultReturnsOnCall == nil {
		fake.firstOrDefaultReturnsOnCall = make(map[int]struct {
			result1 models.DomainFields
			result2 error
		})
	}
	fake.firstOrDefaultReturnsOnCall[i] = struct {
		result1 models.DomainFields
		result2 error
	}{result1, result2}
}

func (fake *FakeDomainRepository) ListDomainsForOrg(arg1 string, arg2 func(models.DomainFields) bool) error {
	fake.listDomainsForOrgMutex.Lock()
	ret, specificReturn := fake.listDomainsForOrgReturnsOnCall[len(fake.listDomainsForOrgArgsForCall)]
	fake.listDomainsForOrgArgsForCall = append(fake.listDomainsForOrgArgsForCall, struct {
		arg1 string
		arg2 func(models.DomainFields) bool
	}{arg1, arg2})
	fake.recordInvocation("ListDomainsForOrg", []interface{}{arg1, arg2})
	fake.listDomainsForOrgMutex.Unlock()
	if fake.ListDomainsForOrgStub != nil {
		return fake.ListDomainsForOrgStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.listDomainsForOrgReturns
	return fakeReturns.result1
}

func (fake *FakeDomainRepository) ListDomainsForOrgCallCount() int {
	fake.listDomainsForOrgMutex.RLock()
	defer fake.listDomainsForOrgMutex.RUnlock()
	return len(fake.listDomainsForOrgArgsForCall)
}

func (fake *FakeDomainRepository) ListDomainsForOrgCalls(stub func(string, func(models.DomainFields) bool) error) {
	fake.listDomainsForOrgMutex.Lock()
	defer fake.listDomainsForOrgMutex.Unlock()
	fake.ListDomainsForOrgStub = stub
}

func (fake *FakeDomainRepository) ListDomainsForOrgArgsForCall(i int) (string, func(models.DomainFields) bool) {
	fake.listDomainsForOrgMutex.RLock()
	defer fake.listDomainsForOrgMutex.RUnlock()
	argsForCall := fake.listDomainsForOrgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDomainRepository) ListDomainsForOrgReturns(result1 error) {
	fake.listDomainsForOrgMutex.Lock()
	defer fake.listDomainsForOrgMutex.Unlock()
	fake.ListDomainsForOrgStub = nil
	fake.listDomainsForOrgReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDomainRepository) ListDomainsForOrgReturnsOnCall(i int, result1 error) {
	fake.listDomainsForOrgMutex.Lock()
	defer fake.listDomainsForOrgMutex.Unlock()
	fake.ListDomainsForOrgStub = nil
	if fake.listDomainsForOrgReturnsOnCall == nil {
		fake.listDomainsForOrgReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listDomainsForOrgReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDomainRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.createSharedDomainMutex.RLock()
	defer fake.createSharedDomainMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deleteSharedDomainMutex.RLock()
	defer fake.deleteSharedDomainMutex.RUnlock()
	fake.findByNameInOrgMutex.RLock()
	defer fake.findByNameInOrgMutex.RUnlock()
	fake.findPrivateByNameMutex.RLock()
	defer fake.findPrivateByNameMutex.RUnlock()
	fake.findSharedByNameMutex.RLock()
	defer fake.findSharedByNameMutex.RUnlock()
	fake.firstOrDefaultMutex.RLock()
	defer fake.firstOrDefaultMutex.RUnlock()
	fake.listDomainsForOrgMutex.RLock()
	defer fake.listDomainsForOrgMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDomainRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.DomainRepository = new(FakeDomainRepository)
