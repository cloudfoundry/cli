// Code generated by counterfeiter. DO NOT EDIT.
package applicationsfakes

import (
	"sync"

	"code.cloudfoundry.org/cli/v8/cf/api/applications"
	"code.cloudfoundry.org/cli/v8/cf/models"
)

type FakeRepository struct {
	CreateStub        func(models.AppParams) (models.Application, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 models.AppParams
	}
	createReturns struct {
		result1 models.Application
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 models.Application
		result2 error
	}
	CreateRestageRequestStub        func(string) error
	createRestageRequestMutex       sync.RWMutex
	createRestageRequestArgsForCall []struct {
		arg1 string
	}
	createRestageRequestReturns struct {
		result1 error
	}
	createRestageRequestReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(string) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 string
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	GetAppStub        func(string) (models.Application, error)
	getAppMutex       sync.RWMutex
	getAppArgsForCall []struct {
		arg1 string
	}
	getAppReturns struct {
		result1 models.Application
		result2 error
	}
	getAppReturnsOnCall map[int]struct {
		result1 models.Application
		result2 error
	}
	GetAppRoutesStub        func(string) ([]models.Route, error)
	getAppRoutesMutex       sync.RWMutex
	getAppRoutesArgsForCall []struct {
		arg1 string
	}
	getAppRoutesReturns struct {
		result1 []models.Route
		result2 error
	}
	getAppRoutesReturnsOnCall map[int]struct {
		result1 []models.Route
		result2 error
	}
	ReadStub        func(string) (models.Application, error)
	readMutex       sync.RWMutex
	readArgsForCall []struct {
		arg1 string
	}
	readReturns struct {
		result1 models.Application
		result2 error
	}
	readReturnsOnCall map[int]struct {
		result1 models.Application
		result2 error
	}
	ReadEnvStub        func(string) (*models.Environment, error)
	readEnvMutex       sync.RWMutex
	readEnvArgsForCall []struct {
		arg1 string
	}
	readEnvReturns struct {
		result1 *models.Environment
		result2 error
	}
	readEnvReturnsOnCall map[int]struct {
		result1 *models.Environment
		result2 error
	}
	ReadFromSpaceStub        func(string, string) (models.Application, error)
	readFromSpaceMutex       sync.RWMutex
	readFromSpaceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	readFromSpaceReturns struct {
		result1 models.Application
		result2 error
	}
	readFromSpaceReturnsOnCall map[int]struct {
		result1 models.Application
		result2 error
	}
	UpdateStub        func(string, models.AppParams) (models.Application, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 string
		arg2 models.AppParams
	}
	updateReturns struct {
		result1 models.Application
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 models.Application
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRepository) Create(arg1 models.AppParams) (models.Application, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 models.AppParams
	}{arg1})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeRepository) CreateCalls(stub func(models.AppParams) (models.Application, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeRepository) CreateArgsForCall(i int) models.AppParams {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) CreateReturns(result1 models.Application, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 models.Application
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) CreateReturnsOnCall(i int, result1 models.Application, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 models.Application
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 models.Application
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) CreateRestageRequest(arg1 string) error {
	fake.createRestageRequestMutex.Lock()
	ret, specificReturn := fake.createRestageRequestReturnsOnCall[len(fake.createRestageRequestArgsForCall)]
	fake.createRestageRequestArgsForCall = append(fake.createRestageRequestArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CreateRestageRequestStub
	fakeReturns := fake.createRestageRequestReturns
	fake.recordInvocation("CreateRestageRequest", []interface{}{arg1})
	fake.createRestageRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) CreateRestageRequestCallCount() int {
	fake.createRestageRequestMutex.RLock()
	defer fake.createRestageRequestMutex.RUnlock()
	return len(fake.createRestageRequestArgsForCall)
}

func (fake *FakeRepository) CreateRestageRequestCalls(stub func(string) error) {
	fake.createRestageRequestMutex.Lock()
	defer fake.createRestageRequestMutex.Unlock()
	fake.CreateRestageRequestStub = stub
}

func (fake *FakeRepository) CreateRestageRequestArgsForCall(i int) string {
	fake.createRestageRequestMutex.RLock()
	defer fake.createRestageRequestMutex.RUnlock()
	argsForCall := fake.createRestageRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) CreateRestageRequestReturns(result1 error) {
	fake.createRestageRequestMutex.Lock()
	defer fake.createRestageRequestMutex.Unlock()
	fake.CreateRestageRequestStub = nil
	fake.createRestageRequestReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) CreateRestageRequestReturnsOnCall(i int, result1 error) {
	fake.createRestageRequestMutex.Lock()
	defer fake.createRestageRequestMutex.Unlock()
	fake.CreateRestageRequestStub = nil
	if fake.createRestageRequestReturnsOnCall == nil {
		fake.createRestageRequestReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createRestageRequestReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) Delete(arg1 string) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeRepository) DeleteCalls(stub func(string) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeRepository) DeleteArgsForCall(i int) string {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) GetApp(arg1 string) (models.Application, error) {
	fake.getAppMutex.Lock()
	ret, specificReturn := fake.getAppReturnsOnCall[len(fake.getAppArgsForCall)]
	fake.getAppArgsForCall = append(fake.getAppArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetAppStub
	fakeReturns := fake.getAppReturns
	fake.recordInvocation("GetApp", []interface{}{arg1})
	fake.getAppMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetAppCallCount() int {
	fake.getAppMutex.RLock()
	defer fake.getAppMutex.RUnlock()
	return len(fake.getAppArgsForCall)
}

func (fake *FakeRepository) GetAppCalls(stub func(string) (models.Application, error)) {
	fake.getAppMutex.Lock()
	defer fake.getAppMutex.Unlock()
	fake.GetAppStub = stub
}

func (fake *FakeRepository) GetAppArgsForCall(i int) string {
	fake.getAppMutex.RLock()
	defer fake.getAppMutex.RUnlock()
	argsForCall := fake.getAppArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) GetAppReturns(result1 models.Application, result2 error) {
	fake.getAppMutex.Lock()
	defer fake.getAppMutex.Unlock()
	fake.GetAppStub = nil
	fake.getAppReturns = struct {
		result1 models.Application
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetAppReturnsOnCall(i int, result1 models.Application, result2 error) {
	fake.getAppMutex.Lock()
	defer fake.getAppMutex.Unlock()
	fake.GetAppStub = nil
	if fake.getAppReturnsOnCall == nil {
		fake.getAppReturnsOnCall = make(map[int]struct {
			result1 models.Application
			result2 error
		})
	}
	fake.getAppReturnsOnCall[i] = struct {
		result1 models.Application
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetAppRoutes(arg1 string) ([]models.Route, error) {
	fake.getAppRoutesMutex.Lock()
	ret, specificReturn := fake.getAppRoutesReturnsOnCall[len(fake.getAppRoutesArgsForCall)]
	fake.getAppRoutesArgsForCall = append(fake.getAppRoutesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetAppRoutesStub
	fakeReturns := fake.getAppRoutesReturns
	fake.recordInvocation("GetAppRoutes", []interface{}{arg1})
	fake.getAppRoutesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetAppRoutesCallCount() int {
	fake.getAppRoutesMutex.RLock()
	defer fake.getAppRoutesMutex.RUnlock()
	return len(fake.getAppRoutesArgsForCall)
}

func (fake *FakeRepository) GetAppRoutesCalls(stub func(string) ([]models.Route, error)) {
	fake.getAppRoutesMutex.Lock()
	defer fake.getAppRoutesMutex.Unlock()
	fake.GetAppRoutesStub = stub
}

func (fake *FakeRepository) GetAppRoutesArgsForCall(i int) string {
	fake.getAppRoutesMutex.RLock()
	defer fake.getAppRoutesMutex.RUnlock()
	argsForCall := fake.getAppRoutesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) GetAppRoutesReturns(result1 []models.Route, result2 error) {
	fake.getAppRoutesMutex.Lock()
	defer fake.getAppRoutesMutex.Unlock()
	fake.GetAppRoutesStub = nil
	fake.getAppRoutesReturns = struct {
		result1 []models.Route
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetAppRoutesReturnsOnCall(i int, result1 []models.Route, result2 error) {
	fake.getAppRoutesMutex.Lock()
	defer fake.getAppRoutesMutex.Unlock()
	fake.GetAppRoutesStub = nil
	if fake.getAppRoutesReturnsOnCall == nil {
		fake.getAppRoutesReturnsOnCall = make(map[int]struct {
			result1 []models.Route
			result2 error
		})
	}
	fake.getAppRoutesReturnsOnCall[i] = struct {
		result1 []models.Route
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) Read(arg1 string) (models.Application, error) {
	fake.readMutex.Lock()
	ret, specificReturn := fake.readReturnsOnCall[len(fake.readArgsForCall)]
	fake.readArgsForCall = append(fake.readArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadStub
	fakeReturns := fake.readReturns
	fake.recordInvocation("Read", []interface{}{arg1})
	fake.readMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) ReadCallCount() int {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	return len(fake.readArgsForCall)
}

func (fake *FakeRepository) ReadCalls(stub func(string) (models.Application, error)) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = stub
}

func (fake *FakeRepository) ReadArgsForCall(i int) string {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	argsForCall := fake.readArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) ReadReturns(result1 models.Application, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	fake.readReturns = struct {
		result1 models.Application
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) ReadReturnsOnCall(i int, result1 models.Application, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	if fake.readReturnsOnCall == nil {
		fake.readReturnsOnCall = make(map[int]struct {
			result1 models.Application
			result2 error
		})
	}
	fake.readReturnsOnCall[i] = struct {
		result1 models.Application
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) ReadEnv(arg1 string) (*models.Environment, error) {
	fake.readEnvMutex.Lock()
	ret, specificReturn := fake.readEnvReturnsOnCall[len(fake.readEnvArgsForCall)]
	fake.readEnvArgsForCall = append(fake.readEnvArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadEnvStub
	fakeReturns := fake.readEnvReturns
	fake.recordInvocation("ReadEnv", []interface{}{arg1})
	fake.readEnvMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) ReadEnvCallCount() int {
	fake.readEnvMutex.RLock()
	defer fake.readEnvMutex.RUnlock()
	return len(fake.readEnvArgsForCall)
}

func (fake *FakeRepository) ReadEnvCalls(stub func(string) (*models.Environment, error)) {
	fake.readEnvMutex.Lock()
	defer fake.readEnvMutex.Unlock()
	fake.ReadEnvStub = stub
}

func (fake *FakeRepository) ReadEnvArgsForCall(i int) string {
	fake.readEnvMutex.RLock()
	defer fake.readEnvMutex.RUnlock()
	argsForCall := fake.readEnvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) ReadEnvReturns(result1 *models.Environment, result2 error) {
	fake.readEnvMutex.Lock()
	defer fake.readEnvMutex.Unlock()
	fake.ReadEnvStub = nil
	fake.readEnvReturns = struct {
		result1 *models.Environment
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) ReadEnvReturnsOnCall(i int, result1 *models.Environment, result2 error) {
	fake.readEnvMutex.Lock()
	defer fake.readEnvMutex.Unlock()
	fake.ReadEnvStub = nil
	if fake.readEnvReturnsOnCall == nil {
		fake.readEnvReturnsOnCall = make(map[int]struct {
			result1 *models.Environment
			result2 error
		})
	}
	fake.readEnvReturnsOnCall[i] = struct {
		result1 *models.Environment
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) ReadFromSpace(arg1 string, arg2 string) (models.Application, error) {
	fake.readFromSpaceMutex.Lock()
	ret, specificReturn := fake.readFromSpaceReturnsOnCall[len(fake.readFromSpaceArgsForCall)]
	fake.readFromSpaceArgsForCall = append(fake.readFromSpaceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ReadFromSpaceStub
	fakeReturns := fake.readFromSpaceReturns
	fake.recordInvocation("ReadFromSpace", []interface{}{arg1, arg2})
	fake.readFromSpaceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) ReadFromSpaceCallCount() int {
	fake.readFromSpaceMutex.RLock()
	defer fake.readFromSpaceMutex.RUnlock()
	return len(fake.readFromSpaceArgsForCall)
}

func (fake *FakeRepository) ReadFromSpaceCalls(stub func(string, string) (models.Application, error)) {
	fake.readFromSpaceMutex.Lock()
	defer fake.readFromSpaceMutex.Unlock()
	fake.ReadFromSpaceStub = stub
}

func (fake *FakeRepository) ReadFromSpaceArgsForCall(i int) (string, string) {
	fake.readFromSpaceMutex.RLock()
	defer fake.readFromSpaceMutex.RUnlock()
	argsForCall := fake.readFromSpaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) ReadFromSpaceReturns(result1 models.Application, result2 error) {
	fake.readFromSpaceMutex.Lock()
	defer fake.readFromSpaceMutex.Unlock()
	fake.ReadFromSpaceStub = nil
	fake.readFromSpaceReturns = struct {
		result1 models.Application
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) ReadFromSpaceReturnsOnCall(i int, result1 models.Application, result2 error) {
	fake.readFromSpaceMutex.Lock()
	defer fake.readFromSpaceMutex.Unlock()
	fake.ReadFromSpaceStub = nil
	if fake.readFromSpaceReturnsOnCall == nil {
		fake.readFromSpaceReturnsOnCall = make(map[int]struct {
			result1 models.Application
			result2 error
		})
	}
	fake.readFromSpaceReturnsOnCall[i] = struct {
		result1 models.Application
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) Update(arg1 string, arg2 models.AppParams) (models.Application, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 string
		arg2 models.AppParams
	}{arg1, arg2})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1, arg2})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeRepository) UpdateCalls(stub func(string, models.AppParams) (models.Application, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeRepository) UpdateArgsForCall(i int) (string, models.AppParams) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) UpdateReturns(result1 models.Application, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 models.Application
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) UpdateReturnsOnCall(i int, result1 models.Application, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 models.Application
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 models.Application
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.createRestageRequestMutex.RLock()
	defer fake.createRestageRequestMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.getAppMutex.RLock()
	defer fake.getAppMutex.RUnlock()
	fake.getAppRoutesMutex.RLock()
	defer fake.getAppRoutesMutex.RUnlock()
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	fake.readEnvMutex.RLock()
	defer fake.readEnvMutex.RUnlock()
	fake.readFromSpaceMutex.RLock()
	defer fake.readFromSpaceMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ applications.Repository = new(FakeRepository)
