// Code generated by counterfeiter. DO NOT EDIT.
package terminalfakes

import (
	"io"
	"sync"

	"code.cloudfoundry.org/cli/cf/configuration/coreconfig"
	"code.cloudfoundry.org/cli/cf/terminal"
)

type FakeUI struct {
	AskStub        func(string) string
	askMutex       sync.RWMutex
	askArgsForCall []struct {
		arg1 string
	}
	askReturns struct {
		result1 string
	}
	askReturnsOnCall map[int]struct {
		result1 string
	}
	AskForPasswordStub        func(string) string
	askForPasswordMutex       sync.RWMutex
	askForPasswordArgsForCall []struct {
		arg1 string
	}
	askForPasswordReturns struct {
		result1 string
	}
	askForPasswordReturnsOnCall map[int]struct {
		result1 string
	}
	ConfirmStub        func(string) bool
	confirmMutex       sync.RWMutex
	confirmArgsForCall []struct {
		arg1 string
	}
	confirmReturns struct {
		result1 bool
	}
	confirmReturnsOnCall map[int]struct {
		result1 bool
	}
	ConfirmDeleteStub        func(string, string) bool
	confirmDeleteMutex       sync.RWMutex
	confirmDeleteArgsForCall []struct {
		arg1 string
		arg2 string
	}
	confirmDeleteReturns struct {
		result1 bool
	}
	confirmDeleteReturnsOnCall map[int]struct {
		result1 bool
	}
	ConfirmDeleteWithAssociationsStub        func(string, string) bool
	confirmDeleteWithAssociationsMutex       sync.RWMutex
	confirmDeleteWithAssociationsArgsForCall []struct {
		arg1 string
		arg2 string
	}
	confirmDeleteWithAssociationsReturns struct {
		result1 bool
	}
	confirmDeleteWithAssociationsReturnsOnCall map[int]struct {
		result1 bool
	}
	FailedStub        func(string, ...interface{})
	failedMutex       sync.RWMutex
	failedArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	LoadingIndicationStub        func()
	loadingIndicationMutex       sync.RWMutex
	loadingIndicationArgsForCall []struct {
	}
	NotifyUpdateIfNeededStub        func(coreconfig.Reader)
	notifyUpdateIfNeededMutex       sync.RWMutex
	notifyUpdateIfNeededArgsForCall []struct {
		arg1 coreconfig.Reader
	}
	OkStub        func()
	okMutex       sync.RWMutex
	okArgsForCall []struct {
	}
	PrintCapturingNoOutputStub        func(string, ...interface{})
	printCapturingNoOutputMutex       sync.RWMutex
	printCapturingNoOutputArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	PrintPaginatorStub        func([]string, error)
	printPaginatorMutex       sync.RWMutex
	printPaginatorArgsForCall []struct {
		arg1 []string
		arg2 error
	}
	SayStub        func(string, ...interface{})
	sayMutex       sync.RWMutex
	sayArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	ShowConfigurationStub        func(coreconfig.Reader) error
	showConfigurationMutex       sync.RWMutex
	showConfigurationArgsForCall []struct {
		arg1 coreconfig.Reader
	}
	showConfigurationReturns struct {
		result1 error
	}
	showConfigurationReturnsOnCall map[int]struct {
		result1 error
	}
	TableStub        func([]string) *terminal.UITable
	tableMutex       sync.RWMutex
	tableArgsForCall []struct {
		arg1 []string
	}
	tableReturns struct {
		result1 *terminal.UITable
	}
	tableReturnsOnCall map[int]struct {
		result1 *terminal.UITable
	}
	WarnStub        func(string, ...interface{})
	warnMutex       sync.RWMutex
	warnArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	WriterStub        func() io.Writer
	writerMutex       sync.RWMutex
	writerArgsForCall []struct {
	}
	writerReturns struct {
		result1 io.Writer
	}
	writerReturnsOnCall map[int]struct {
		result1 io.Writer
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUI) Ask(arg1 string) string {
	fake.askMutex.Lock()
	ret, specificReturn := fake.askReturnsOnCall[len(fake.askArgsForCall)]
	fake.askArgsForCall = append(fake.askArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Ask", []interface{}{arg1})
	fake.askMutex.Unlock()
	if fake.AskStub != nil {
		return fake.AskStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.askReturns
	return fakeReturns.result1
}

func (fake *FakeUI) AskCallCount() int {
	fake.askMutex.RLock()
	defer fake.askMutex.RUnlock()
	return len(fake.askArgsForCall)
}

func (fake *FakeUI) AskCalls(stub func(string) string) {
	fake.askMutex.Lock()
	defer fake.askMutex.Unlock()
	fake.AskStub = stub
}

func (fake *FakeUI) AskArgsForCall(i int) string {
	fake.askMutex.RLock()
	defer fake.askMutex.RUnlock()
	argsForCall := fake.askArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) AskReturns(result1 string) {
	fake.askMutex.Lock()
	defer fake.askMutex.Unlock()
	fake.AskStub = nil
	fake.askReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUI) AskReturnsOnCall(i int, result1 string) {
	fake.askMutex.Lock()
	defer fake.askMutex.Unlock()
	fake.AskStub = nil
	if fake.askReturnsOnCall == nil {
		fake.askReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.askReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUI) AskForPassword(arg1 string) string {
	fake.askForPasswordMutex.Lock()
	ret, specificReturn := fake.askForPasswordReturnsOnCall[len(fake.askForPasswordArgsForCall)]
	fake.askForPasswordArgsForCall = append(fake.askForPasswordArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("AskForPassword", []interface{}{arg1})
	fake.askForPasswordMutex.Unlock()
	if fake.AskForPasswordStub != nil {
		return fake.AskForPasswordStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.askForPasswordReturns
	return fakeReturns.result1
}

func (fake *FakeUI) AskForPasswordCallCount() int {
	fake.askForPasswordMutex.RLock()
	defer fake.askForPasswordMutex.RUnlock()
	return len(fake.askForPasswordArgsForCall)
}

func (fake *FakeUI) AskForPasswordCalls(stub func(string) string) {
	fake.askForPasswordMutex.Lock()
	defer fake.askForPasswordMutex.Unlock()
	fake.AskForPasswordStub = stub
}

func (fake *FakeUI) AskForPasswordArgsForCall(i int) string {
	fake.askForPasswordMutex.RLock()
	defer fake.askForPasswordMutex.RUnlock()
	argsForCall := fake.askForPasswordArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) AskForPasswordReturns(result1 string) {
	fake.askForPasswordMutex.Lock()
	defer fake.askForPasswordMutex.Unlock()
	fake.AskForPasswordStub = nil
	fake.askForPasswordReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUI) AskForPasswordReturnsOnCall(i int, result1 string) {
	fake.askForPasswordMutex.Lock()
	defer fake.askForPasswordMutex.Unlock()
	fake.AskForPasswordStub = nil
	if fake.askForPasswordReturnsOnCall == nil {
		fake.askForPasswordReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.askForPasswordReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUI) Confirm(arg1 string) bool {
	fake.confirmMutex.Lock()
	ret, specificReturn := fake.confirmReturnsOnCall[len(fake.confirmArgsForCall)]
	fake.confirmArgsForCall = append(fake.confirmArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Confirm", []interface{}{arg1})
	fake.confirmMutex.Unlock()
	if fake.ConfirmStub != nil {
		return fake.ConfirmStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.confirmReturns
	return fakeReturns.result1
}

func (fake *FakeUI) ConfirmCallCount() int {
	fake.confirmMutex.RLock()
	defer fake.confirmMutex.RUnlock()
	return len(fake.confirmArgsForCall)
}

func (fake *FakeUI) ConfirmCalls(stub func(string) bool) {
	fake.confirmMutex.Lock()
	defer fake.confirmMutex.Unlock()
	fake.ConfirmStub = stub
}

func (fake *FakeUI) ConfirmArgsForCall(i int) string {
	fake.confirmMutex.RLock()
	defer fake.confirmMutex.RUnlock()
	argsForCall := fake.confirmArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) ConfirmReturns(result1 bool) {
	fake.confirmMutex.Lock()
	defer fake.confirmMutex.Unlock()
	fake.ConfirmStub = nil
	fake.confirmReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeUI) ConfirmReturnsOnCall(i int, result1 bool) {
	fake.confirmMutex.Lock()
	defer fake.confirmMutex.Unlock()
	fake.ConfirmStub = nil
	if fake.confirmReturnsOnCall == nil {
		fake.confirmReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.confirmReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeUI) ConfirmDelete(arg1 string, arg2 string) bool {
	fake.confirmDeleteMutex.Lock()
	ret, specificReturn := fake.confirmDeleteReturnsOnCall[len(fake.confirmDeleteArgsForCall)]
	fake.confirmDeleteArgsForCall = append(fake.confirmDeleteArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ConfirmDelete", []interface{}{arg1, arg2})
	fake.confirmDeleteMutex.Unlock()
	if fake.ConfirmDeleteStub != nil {
		return fake.ConfirmDeleteStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.confirmDeleteReturns
	return fakeReturns.result1
}

func (fake *FakeUI) ConfirmDeleteCallCount() int {
	fake.confirmDeleteMutex.RLock()
	defer fake.confirmDeleteMutex.RUnlock()
	return len(fake.confirmDeleteArgsForCall)
}

func (fake *FakeUI) ConfirmDeleteCalls(stub func(string, string) bool) {
	fake.confirmDeleteMutex.Lock()
	defer fake.confirmDeleteMutex.Unlock()
	fake.ConfirmDeleteStub = stub
}

func (fake *FakeUI) ConfirmDeleteArgsForCall(i int) (string, string) {
	fake.confirmDeleteMutex.RLock()
	defer fake.confirmDeleteMutex.RUnlock()
	argsForCall := fake.confirmDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) ConfirmDeleteReturns(result1 bool) {
	fake.confirmDeleteMutex.Lock()
	defer fake.confirmDeleteMutex.Unlock()
	fake.ConfirmDeleteStub = nil
	fake.confirmDeleteReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeUI) ConfirmDeleteReturnsOnCall(i int, result1 bool) {
	fake.confirmDeleteMutex.Lock()
	defer fake.confirmDeleteMutex.Unlock()
	fake.ConfirmDeleteStub = nil
	if fake.confirmDeleteReturnsOnCall == nil {
		fake.confirmDeleteReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.confirmDeleteReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeUI) ConfirmDeleteWithAssociations(arg1 string, arg2 string) bool {
	fake.confirmDeleteWithAssociationsMutex.Lock()
	ret, specificReturn := fake.confirmDeleteWithAssociationsReturnsOnCall[len(fake.confirmDeleteWithAssociationsArgsForCall)]
	fake.confirmDeleteWithAssociationsArgsForCall = append(fake.confirmDeleteWithAssociationsArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ConfirmDeleteWithAssociations", []interface{}{arg1, arg2})
	fake.confirmDeleteWithAssociationsMutex.Unlock()
	if fake.ConfirmDeleteWithAssociationsStub != nil {
		return fake.ConfirmDeleteWithAssociationsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.confirmDeleteWithAssociationsReturns
	return fakeReturns.result1
}

func (fake *FakeUI) ConfirmDeleteWithAssociationsCallCount() int {
	fake.confirmDeleteWithAssociationsMutex.RLock()
	defer fake.confirmDeleteWithAssociationsMutex.RUnlock()
	return len(fake.confirmDeleteWithAssociationsArgsForCall)
}

func (fake *FakeUI) ConfirmDeleteWithAssociationsCalls(stub func(string, string) bool) {
	fake.confirmDeleteWithAssociationsMutex.Lock()
	defer fake.confirmDeleteWithAssociationsMutex.Unlock()
	fake.ConfirmDeleteWithAssociationsStub = stub
}

func (fake *FakeUI) ConfirmDeleteWithAssociationsArgsForCall(i int) (string, string) {
	fake.confirmDeleteWithAssociationsMutex.RLock()
	defer fake.confirmDeleteWithAssociationsMutex.RUnlock()
	argsForCall := fake.confirmDeleteWithAssociationsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) ConfirmDeleteWithAssociationsReturns(result1 bool) {
	fake.confirmDeleteWithAssociationsMutex.Lock()
	defer fake.confirmDeleteWithAssociationsMutex.Unlock()
	fake.ConfirmDeleteWithAssociationsStub = nil
	fake.confirmDeleteWithAssociationsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeUI) ConfirmDeleteWithAssociationsReturnsOnCall(i int, result1 bool) {
	fake.confirmDeleteWithAssociationsMutex.Lock()
	defer fake.confirmDeleteWithAssociationsMutex.Unlock()
	fake.ConfirmDeleteWithAssociationsStub = nil
	if fake.confirmDeleteWithAssociationsReturnsOnCall == nil {
		fake.confirmDeleteWithAssociationsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.confirmDeleteWithAssociationsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeUI) Failed(arg1 string, arg2 ...interface{}) {
	fake.failedMutex.Lock()
	fake.failedArgsForCall = append(fake.failedArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	fake.recordInvocation("Failed", []interface{}{arg1, arg2})
	fake.failedMutex.Unlock()
	if fake.FailedStub != nil {
		fake.FailedStub(arg1, arg2...)
	}
}

func (fake *FakeUI) FailedCallCount() int {
	fake.failedMutex.RLock()
	defer fake.failedMutex.RUnlock()
	return len(fake.failedArgsForCall)
}

func (fake *FakeUI) FailedCalls(stub func(string, ...interface{})) {
	fake.failedMutex.Lock()
	defer fake.failedMutex.Unlock()
	fake.FailedStub = stub
}

func (fake *FakeUI) FailedArgsForCall(i int) (string, []interface{}) {
	fake.failedMutex.RLock()
	defer fake.failedMutex.RUnlock()
	argsForCall := fake.failedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) LoadingIndication() {
	fake.loadingIndicationMutex.Lock()
	fake.loadingIndicationArgsForCall = append(fake.loadingIndicationArgsForCall, struct {
	}{})
	fake.recordInvocation("LoadingIndication", []interface{}{})
	fake.loadingIndicationMutex.Unlock()
	if fake.LoadingIndicationStub != nil {
		fake.LoadingIndicationStub()
	}
}

func (fake *FakeUI) LoadingIndicationCallCount() int {
	fake.loadingIndicationMutex.RLock()
	defer fake.loadingIndicationMutex.RUnlock()
	return len(fake.loadingIndicationArgsForCall)
}

func (fake *FakeUI) LoadingIndicationCalls(stub func()) {
	fake.loadingIndicationMutex.Lock()
	defer fake.loadingIndicationMutex.Unlock()
	fake.LoadingIndicationStub = stub
}

func (fake *FakeUI) NotifyUpdateIfNeeded(arg1 coreconfig.Reader) {
	fake.notifyUpdateIfNeededMutex.Lock()
	fake.notifyUpdateIfNeededArgsForCall = append(fake.notifyUpdateIfNeededArgsForCall, struct {
		arg1 coreconfig.Reader
	}{arg1})
	fake.recordInvocation("NotifyUpdateIfNeeded", []interface{}{arg1})
	fake.notifyUpdateIfNeededMutex.Unlock()
	if fake.NotifyUpdateIfNeededStub != nil {
		fake.NotifyUpdateIfNeededStub(arg1)
	}
}

func (fake *FakeUI) NotifyUpdateIfNeededCallCount() int {
	fake.notifyUpdateIfNeededMutex.RLock()
	defer fake.notifyUpdateIfNeededMutex.RUnlock()
	return len(fake.notifyUpdateIfNeededArgsForCall)
}

func (fake *FakeUI) NotifyUpdateIfNeededCalls(stub func(coreconfig.Reader)) {
	fake.notifyUpdateIfNeededMutex.Lock()
	defer fake.notifyUpdateIfNeededMutex.Unlock()
	fake.NotifyUpdateIfNeededStub = stub
}

func (fake *FakeUI) NotifyUpdateIfNeededArgsForCall(i int) coreconfig.Reader {
	fake.notifyUpdateIfNeededMutex.RLock()
	defer fake.notifyUpdateIfNeededMutex.RUnlock()
	argsForCall := fake.notifyUpdateIfNeededArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) Ok() {
	fake.okMutex.Lock()
	fake.okArgsForCall = append(fake.okArgsForCall, struct {
	}{})
	fake.recordInvocation("Ok", []interface{}{})
	fake.okMutex.Unlock()
	if fake.OkStub != nil {
		fake.OkStub()
	}
}

func (fake *FakeUI) OkCallCount() int {
	fake.okMutex.RLock()
	defer fake.okMutex.RUnlock()
	return len(fake.okArgsForCall)
}

func (fake *FakeUI) OkCalls(stub func()) {
	fake.okMutex.Lock()
	defer fake.okMutex.Unlock()
	fake.OkStub = stub
}

func (fake *FakeUI) PrintCapturingNoOutput(arg1 string, arg2 ...interface{}) {
	fake.printCapturingNoOutputMutex.Lock()
	fake.printCapturingNoOutputArgsForCall = append(fake.printCapturingNoOutputArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	fake.recordInvocation("PrintCapturingNoOutput", []interface{}{arg1, arg2})
	fake.printCapturingNoOutputMutex.Unlock()
	if fake.PrintCapturingNoOutputStub != nil {
		fake.PrintCapturingNoOutputStub(arg1, arg2...)
	}
}

func (fake *FakeUI) PrintCapturingNoOutputCallCount() int {
	fake.printCapturingNoOutputMutex.RLock()
	defer fake.printCapturingNoOutputMutex.RUnlock()
	return len(fake.printCapturingNoOutputArgsForCall)
}

func (fake *FakeUI) PrintCapturingNoOutputCalls(stub func(string, ...interface{})) {
	fake.printCapturingNoOutputMutex.Lock()
	defer fake.printCapturingNoOutputMutex.Unlock()
	fake.PrintCapturingNoOutputStub = stub
}

func (fake *FakeUI) PrintCapturingNoOutputArgsForCall(i int) (string, []interface{}) {
	fake.printCapturingNoOutputMutex.RLock()
	defer fake.printCapturingNoOutputMutex.RUnlock()
	argsForCall := fake.printCapturingNoOutputArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) PrintPaginator(arg1 []string, arg2 error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.printPaginatorMutex.Lock()
	fake.printPaginatorArgsForCall = append(fake.printPaginatorArgsForCall, struct {
		arg1 []string
		arg2 error
	}{arg1Copy, arg2})
	fake.recordInvocation("PrintPaginator", []interface{}{arg1Copy, arg2})
	fake.printPaginatorMutex.Unlock()
	if fake.PrintPaginatorStub != nil {
		fake.PrintPaginatorStub(arg1, arg2)
	}
}

func (fake *FakeUI) PrintPaginatorCallCount() int {
	fake.printPaginatorMutex.RLock()
	defer fake.printPaginatorMutex.RUnlock()
	return len(fake.printPaginatorArgsForCall)
}

func (fake *FakeUI) PrintPaginatorCalls(stub func([]string, error)) {
	fake.printPaginatorMutex.Lock()
	defer fake.printPaginatorMutex.Unlock()
	fake.PrintPaginatorStub = stub
}

func (fake *FakeUI) PrintPaginatorArgsForCall(i int) ([]string, error) {
	fake.printPaginatorMutex.RLock()
	defer fake.printPaginatorMutex.RUnlock()
	argsForCall := fake.printPaginatorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) Say(arg1 string, arg2 ...interface{}) {
	fake.sayMutex.Lock()
	fake.sayArgsForCall = append(fake.sayArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	fake.recordInvocation("Say", []interface{}{arg1, arg2})
	fake.sayMutex.Unlock()
	if fake.SayStub != nil {
		fake.SayStub(arg1, arg2...)
	}
}

func (fake *FakeUI) SayCallCount() int {
	fake.sayMutex.RLock()
	defer fake.sayMutex.RUnlock()
	return len(fake.sayArgsForCall)
}

func (fake *FakeUI) SayCalls(stub func(string, ...interface{})) {
	fake.sayMutex.Lock()
	defer fake.sayMutex.Unlock()
	fake.SayStub = stub
}

func (fake *FakeUI) SayArgsForCall(i int) (string, []interface{}) {
	fake.sayMutex.RLock()
	defer fake.sayMutex.RUnlock()
	argsForCall := fake.sayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) ShowConfiguration(arg1 coreconfig.Reader) error {
	fake.showConfigurationMutex.Lock()
	ret, specificReturn := fake.showConfigurationReturnsOnCall[len(fake.showConfigurationArgsForCall)]
	fake.showConfigurationArgsForCall = append(fake.showConfigurationArgsForCall, struct {
		arg1 coreconfig.Reader
	}{arg1})
	fake.recordInvocation("ShowConfiguration", []interface{}{arg1})
	fake.showConfigurationMutex.Unlock()
	if fake.ShowConfigurationStub != nil {
		return fake.ShowConfigurationStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.showConfigurationReturns
	return fakeReturns.result1
}

func (fake *FakeUI) ShowConfigurationCallCount() int {
	fake.showConfigurationMutex.RLock()
	defer fake.showConfigurationMutex.RUnlock()
	return len(fake.showConfigurationArgsForCall)
}

func (fake *FakeUI) ShowConfigurationCalls(stub func(coreconfig.Reader) error) {
	fake.showConfigurationMutex.Lock()
	defer fake.showConfigurationMutex.Unlock()
	fake.ShowConfigurationStub = stub
}

func (fake *FakeUI) ShowConfigurationArgsForCall(i int) coreconfig.Reader {
	fake.showConfigurationMutex.RLock()
	defer fake.showConfigurationMutex.RUnlock()
	argsForCall := fake.showConfigurationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) ShowConfigurationReturns(result1 error) {
	fake.showConfigurationMutex.Lock()
	defer fake.showConfigurationMutex.Unlock()
	fake.ShowConfigurationStub = nil
	fake.showConfigurationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUI) ShowConfigurationReturnsOnCall(i int, result1 error) {
	fake.showConfigurationMutex.Lock()
	defer fake.showConfigurationMutex.Unlock()
	fake.ShowConfigurationStub = nil
	if fake.showConfigurationReturnsOnCall == nil {
		fake.showConfigurationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.showConfigurationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUI) Table(arg1 []string) *terminal.UITable {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.tableMutex.Lock()
	ret, specificReturn := fake.tableReturnsOnCall[len(fake.tableArgsForCall)]
	fake.tableArgsForCall = append(fake.tableArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("Table", []interface{}{arg1Copy})
	fake.tableMutex.Unlock()
	if fake.TableStub != nil {
		return fake.TableStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tableReturns
	return fakeReturns.result1
}

func (fake *FakeUI) TableCallCount() int {
	fake.tableMutex.RLock()
	defer fake.tableMutex.RUnlock()
	return len(fake.tableArgsForCall)
}

func (fake *FakeUI) TableCalls(stub func([]string) *terminal.UITable) {
	fake.tableMutex.Lock()
	defer fake.tableMutex.Unlock()
	fake.TableStub = stub
}

func (fake *FakeUI) TableArgsForCall(i int) []string {
	fake.tableMutex.RLock()
	defer fake.tableMutex.RUnlock()
	argsForCall := fake.tableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) TableReturns(result1 *terminal.UITable) {
	fake.tableMutex.Lock()
	defer fake.tableMutex.Unlock()
	fake.TableStub = nil
	fake.tableReturns = struct {
		result1 *terminal.UITable
	}{result1}
}

func (fake *FakeUI) TableReturnsOnCall(i int, result1 *terminal.UITable) {
	fake.tableMutex.Lock()
	defer fake.tableMutex.Unlock()
	fake.TableStub = nil
	if fake.tableReturnsOnCall == nil {
		fake.tableReturnsOnCall = make(map[int]struct {
			result1 *terminal.UITable
		})
	}
	fake.tableReturnsOnCall[i] = struct {
		result1 *terminal.UITable
	}{result1}
}

func (fake *FakeUI) Warn(arg1 string, arg2 ...interface{}) {
	fake.warnMutex.Lock()
	fake.warnArgsForCall = append(fake.warnArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	fake.recordInvocation("Warn", []interface{}{arg1, arg2})
	fake.warnMutex.Unlock()
	if fake.WarnStub != nil {
		fake.WarnStub(arg1, arg2...)
	}
}

func (fake *FakeUI) WarnCallCount() int {
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	return len(fake.warnArgsForCall)
}

func (fake *FakeUI) WarnCalls(stub func(string, ...interface{})) {
	fake.warnMutex.Lock()
	defer fake.warnMutex.Unlock()
	fake.WarnStub = stub
}

func (fake *FakeUI) WarnArgsForCall(i int) (string, []interface{}) {
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	argsForCall := fake.warnArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) Writer() io.Writer {
	fake.writerMutex.Lock()
	ret, specificReturn := fake.writerReturnsOnCall[len(fake.writerArgsForCall)]
	fake.writerArgsForCall = append(fake.writerArgsForCall, struct {
	}{})
	fake.recordInvocation("Writer", []interface{}{})
	fake.writerMutex.Unlock()
	if fake.WriterStub != nil {
		return fake.WriterStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.writerReturns
	return fakeReturns.result1
}

func (fake *FakeUI) WriterCallCount() int {
	fake.writerMutex.RLock()
	defer fake.writerMutex.RUnlock()
	return len(fake.writerArgsForCall)
}

func (fake *FakeUI) WriterCalls(stub func() io.Writer) {
	fake.writerMutex.Lock()
	defer fake.writerMutex.Unlock()
	fake.WriterStub = stub
}

func (fake *FakeUI) WriterReturns(result1 io.Writer) {
	fake.writerMutex.Lock()
	defer fake.writerMutex.Unlock()
	fake.WriterStub = nil
	fake.writerReturns = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeUI) WriterReturnsOnCall(i int, result1 io.Writer) {
	fake.writerMutex.Lock()
	defer fake.writerMutex.Unlock()
	fake.WriterStub = nil
	if fake.writerReturnsOnCall == nil {
		fake.writerReturnsOnCall = make(map[int]struct {
			result1 io.Writer
		})
	}
	fake.writerReturnsOnCall[i] = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeUI) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.askMutex.RLock()
	defer fake.askMutex.RUnlock()
	fake.askForPasswordMutex.RLock()
	defer fake.askForPasswordMutex.RUnlock()
	fake.confirmMutex.RLock()
	defer fake.confirmMutex.RUnlock()
	fake.confirmDeleteMutex.RLock()
	defer fake.confirmDeleteMutex.RUnlock()
	fake.confirmDeleteWithAssociationsMutex.RLock()
	defer fake.confirmDeleteWithAssociationsMutex.RUnlock()
	fake.failedMutex.RLock()
	defer fake.failedMutex.RUnlock()
	fake.loadingIndicationMutex.RLock()
	defer fake.loadingIndicationMutex.RUnlock()
	fake.notifyUpdateIfNeededMutex.RLock()
	defer fake.notifyUpdateIfNeededMutex.RUnlock()
	fake.okMutex.RLock()
	defer fake.okMutex.RUnlock()
	fake.printCapturingNoOutputMutex.RLock()
	defer fake.printCapturingNoOutputMutex.RUnlock()
	fake.printPaginatorMutex.RLock()
	defer fake.printPaginatorMutex.RUnlock()
	fake.sayMutex.RLock()
	defer fake.sayMutex.RUnlock()
	fake.showConfigurationMutex.RLock()
	defer fake.showConfigurationMutex.RUnlock()
	fake.tableMutex.RLock()
	defer fake.tableMutex.RUnlock()
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	fake.writerMutex.RLock()
	defer fake.writerMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUI) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ terminal.UI = new(FakeUI)
