// Code generated by counterfeiter. DO NOT EDIT.
package appfilesfakes

import (
	"sync"

	"code.cloudfoundry.org/cli/cf/appfiles"
	"code.cloudfoundry.org/cli/cf/models"
)

type FakeAppFiles struct {
	AppFilesInDirStub        func(string) ([]models.AppFileFields, error)
	appFilesInDirMutex       sync.RWMutex
	appFilesInDirArgsForCall []struct {
		arg1 string
	}
	appFilesInDirReturns struct {
		result1 []models.AppFileFields
		result2 error
	}
	appFilesInDirReturnsOnCall map[int]struct {
		result1 []models.AppFileFields
		result2 error
	}
	CopyFilesStub        func([]models.AppFileFields, string, string) error
	copyFilesMutex       sync.RWMutex
	copyFilesArgsForCall []struct {
		arg1 []models.AppFileFields
		arg2 string
		arg3 string
	}
	copyFilesReturns struct {
		result1 error
	}
	copyFilesReturnsOnCall map[int]struct {
		result1 error
	}
	CountFilesStub        func(string) int64
	countFilesMutex       sync.RWMutex
	countFilesArgsForCall []struct {
		arg1 string
	}
	countFilesReturns struct {
		result1 int64
	}
	countFilesReturnsOnCall map[int]struct {
		result1 int64
	}
	WalkAppFilesStub        func(string, func(string, string) error) error
	walkAppFilesMutex       sync.RWMutex
	walkAppFilesArgsForCall []struct {
		arg1 string
		arg2 func(string, string) error
	}
	walkAppFilesReturns struct {
		result1 error
	}
	walkAppFilesReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAppFiles) AppFilesInDir(arg1 string) ([]models.AppFileFields, error) {
	fake.appFilesInDirMutex.Lock()
	ret, specificReturn := fake.appFilesInDirReturnsOnCall[len(fake.appFilesInDirArgsForCall)]
	fake.appFilesInDirArgsForCall = append(fake.appFilesInDirArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("AppFilesInDir", []interface{}{arg1})
	fake.appFilesInDirMutex.Unlock()
	if fake.AppFilesInDirStub != nil {
		return fake.AppFilesInDirStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.appFilesInDirReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAppFiles) AppFilesInDirCallCount() int {
	fake.appFilesInDirMutex.RLock()
	defer fake.appFilesInDirMutex.RUnlock()
	return len(fake.appFilesInDirArgsForCall)
}

func (fake *FakeAppFiles) AppFilesInDirCalls(stub func(string) ([]models.AppFileFields, error)) {
	fake.appFilesInDirMutex.Lock()
	defer fake.appFilesInDirMutex.Unlock()
	fake.AppFilesInDirStub = stub
}

func (fake *FakeAppFiles) AppFilesInDirArgsForCall(i int) string {
	fake.appFilesInDirMutex.RLock()
	defer fake.appFilesInDirMutex.RUnlock()
	argsForCall := fake.appFilesInDirArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAppFiles) AppFilesInDirReturns(result1 []models.AppFileFields, result2 error) {
	fake.appFilesInDirMutex.Lock()
	defer fake.appFilesInDirMutex.Unlock()
	fake.AppFilesInDirStub = nil
	fake.appFilesInDirReturns = struct {
		result1 []models.AppFileFields
		result2 error
	}{result1, result2}
}

func (fake *FakeAppFiles) AppFilesInDirReturnsOnCall(i int, result1 []models.AppFileFields, result2 error) {
	fake.appFilesInDirMutex.Lock()
	defer fake.appFilesInDirMutex.Unlock()
	fake.AppFilesInDirStub = nil
	if fake.appFilesInDirReturnsOnCall == nil {
		fake.appFilesInDirReturnsOnCall = make(map[int]struct {
			result1 []models.AppFileFields
			result2 error
		})
	}
	fake.appFilesInDirReturnsOnCall[i] = struct {
		result1 []models.AppFileFields
		result2 error
	}{result1, result2}
}

func (fake *FakeAppFiles) CopyFiles(arg1 []models.AppFileFields, arg2 string, arg3 string) error {
	var arg1Copy []models.AppFileFields
	if arg1 != nil {
		arg1Copy = make([]models.AppFileFields, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.copyFilesMutex.Lock()
	ret, specificReturn := fake.copyFilesReturnsOnCall[len(fake.copyFilesArgsForCall)]
	fake.copyFilesArgsForCall = append(fake.copyFilesArgsForCall, struct {
		arg1 []models.AppFileFields
		arg2 string
		arg3 string
	}{arg1Copy, arg2, arg3})
	fake.recordInvocation("CopyFiles", []interface{}{arg1Copy, arg2, arg3})
	fake.copyFilesMutex.Unlock()
	if fake.CopyFilesStub != nil {
		return fake.CopyFilesStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.copyFilesReturns
	return fakeReturns.result1
}

func (fake *FakeAppFiles) CopyFilesCallCount() int {
	fake.copyFilesMutex.RLock()
	defer fake.copyFilesMutex.RUnlock()
	return len(fake.copyFilesArgsForCall)
}

func (fake *FakeAppFiles) CopyFilesCalls(stub func([]models.AppFileFields, string, string) error) {
	fake.copyFilesMutex.Lock()
	defer fake.copyFilesMutex.Unlock()
	fake.CopyFilesStub = stub
}

func (fake *FakeAppFiles) CopyFilesArgsForCall(i int) ([]models.AppFileFields, string, string) {
	fake.copyFilesMutex.RLock()
	defer fake.copyFilesMutex.RUnlock()
	argsForCall := fake.copyFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAppFiles) CopyFilesReturns(result1 error) {
	fake.copyFilesMutex.Lock()
	defer fake.copyFilesMutex.Unlock()
	fake.CopyFilesStub = nil
	fake.copyFilesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppFiles) CopyFilesReturnsOnCall(i int, result1 error) {
	fake.copyFilesMutex.Lock()
	defer fake.copyFilesMutex.Unlock()
	fake.CopyFilesStub = nil
	if fake.copyFilesReturnsOnCall == nil {
		fake.copyFilesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.copyFilesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppFiles) CountFiles(arg1 string) int64 {
	fake.countFilesMutex.Lock()
	ret, specificReturn := fake.countFilesReturnsOnCall[len(fake.countFilesArgsForCall)]
	fake.countFilesArgsForCall = append(fake.countFilesArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CountFiles", []interface{}{arg1})
	fake.countFilesMutex.Unlock()
	if fake.CountFilesStub != nil {
		return fake.CountFilesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.countFilesReturns
	return fakeReturns.result1
}

func (fake *FakeAppFiles) CountFilesCallCount() int {
	fake.countFilesMutex.RLock()
	defer fake.countFilesMutex.RUnlock()
	return len(fake.countFilesArgsForCall)
}

func (fake *FakeAppFiles) CountFilesCalls(stub func(string) int64) {
	fake.countFilesMutex.Lock()
	defer fake.countFilesMutex.Unlock()
	fake.CountFilesStub = stub
}

func (fake *FakeAppFiles) CountFilesArgsForCall(i int) string {
	fake.countFilesMutex.RLock()
	defer fake.countFilesMutex.RUnlock()
	argsForCall := fake.countFilesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAppFiles) CountFilesReturns(result1 int64) {
	fake.countFilesMutex.Lock()
	defer fake.countFilesMutex.Unlock()
	fake.CountFilesStub = nil
	fake.countFilesReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeAppFiles) CountFilesReturnsOnCall(i int, result1 int64) {
	fake.countFilesMutex.Lock()
	defer fake.countFilesMutex.Unlock()
	fake.CountFilesStub = nil
	if fake.countFilesReturnsOnCall == nil {
		fake.countFilesReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.countFilesReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeAppFiles) WalkAppFiles(arg1 string, arg2 func(string, string) error) error {
	fake.walkAppFilesMutex.Lock()
	ret, specificReturn := fake.walkAppFilesReturnsOnCall[len(fake.walkAppFilesArgsForCall)]
	fake.walkAppFilesArgsForCall = append(fake.walkAppFilesArgsForCall, struct {
		arg1 string
		arg2 func(string, string) error
	}{arg1, arg2})
	fake.recordInvocation("WalkAppFiles", []interface{}{arg1, arg2})
	fake.walkAppFilesMutex.Unlock()
	if fake.WalkAppFilesStub != nil {
		return fake.WalkAppFilesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.walkAppFilesReturns
	return fakeReturns.result1
}

func (fake *FakeAppFiles) WalkAppFilesCallCount() int {
	fake.walkAppFilesMutex.RLock()
	defer fake.walkAppFilesMutex.RUnlock()
	return len(fake.walkAppFilesArgsForCall)
}

func (fake *FakeAppFiles) WalkAppFilesCalls(stub func(string, func(string, string) error) error) {
	fake.walkAppFilesMutex.Lock()
	defer fake.walkAppFilesMutex.Unlock()
	fake.WalkAppFilesStub = stub
}

func (fake *FakeAppFiles) WalkAppFilesArgsForCall(i int) (string, func(string, string) error) {
	fake.walkAppFilesMutex.RLock()
	defer fake.walkAppFilesMutex.RUnlock()
	argsForCall := fake.walkAppFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAppFiles) WalkAppFilesReturns(result1 error) {
	fake.walkAppFilesMutex.Lock()
	defer fake.walkAppFilesMutex.Unlock()
	fake.WalkAppFilesStub = nil
	fake.walkAppFilesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppFiles) WalkAppFilesReturnsOnCall(i int, result1 error) {
	fake.walkAppFilesMutex.Lock()
	defer fake.walkAppFilesMutex.Unlock()
	fake.WalkAppFilesStub = nil
	if fake.walkAppFilesReturnsOnCall == nil {
		fake.walkAppFilesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.walkAppFilesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppFiles) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.appFilesInDirMutex.RLock()
	defer fake.appFilesInDirMutex.RUnlock()
	fake.copyFilesMutex.RLock()
	defer fake.copyFilesMutex.RUnlock()
	fake.countFilesMutex.RLock()
	defer fake.countFilesMutex.RUnlock()
	fake.walkAppFilesMutex.RLock()
	defer fake.walkAppFilesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAppFiles) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ appfiles.AppFiles = new(FakeAppFiles)
