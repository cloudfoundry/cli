// Code generated by counterfeiter. DO NOT EDIT.
package ccv3fakes

import (
	"io"
	"net/http"
	"sync"

	"code.cloudfoundry.org/cli/api/cloudcontroller/ccv3"
	"code.cloudfoundry.org/cli/api/cloudcontroller/ccv3/internal"
)

type FakeRequester struct {
	InitializeConnectionStub        func(ccv3.TargetSettings)
	initializeConnectionMutex       sync.RWMutex
	initializeConnectionArgsForCall []struct {
		arg1 ccv3.TargetSettings
	}
	InitializeRouterStub        func(string)
	initializeRouterMutex       sync.RWMutex
	initializeRouterArgsForCall []struct {
		arg1 string
	}
	MakeListRequestStub        func(ccv3.RequestParams) (ccv3.IncludedResources, ccv3.Warnings, error)
	makeListRequestMutex       sync.RWMutex
	makeListRequestArgsForCall []struct {
		arg1 ccv3.RequestParams
	}
	makeListRequestReturns struct {
		result1 ccv3.IncludedResources
		result2 ccv3.Warnings
		result3 error
	}
	makeListRequestReturnsOnCall map[int]struct {
		result1 ccv3.IncludedResources
		result2 ccv3.Warnings
		result3 error
	}
	MakeRequestStub        func(ccv3.RequestParams) (ccv3.JobURL, ccv3.Warnings, error)
	makeRequestMutex       sync.RWMutex
	makeRequestArgsForCall []struct {
		arg1 ccv3.RequestParams
	}
	makeRequestReturns struct {
		result1 ccv3.JobURL
		result2 ccv3.Warnings
		result3 error
	}
	makeRequestReturnsOnCall map[int]struct {
		result1 ccv3.JobURL
		result2 ccv3.Warnings
		result3 error
	}
	MakeRequestReceiveRawStub        func(string, internal.Params, string) ([]byte, ccv3.Warnings, error)
	makeRequestReceiveRawMutex       sync.RWMutex
	makeRequestReceiveRawArgsForCall []struct {
		arg1 string
		arg2 internal.Params
		arg3 string
	}
	makeRequestReceiveRawReturns struct {
		result1 []byte
		result2 ccv3.Warnings
		result3 error
	}
	makeRequestReceiveRawReturnsOnCall map[int]struct {
		result1 []byte
		result2 ccv3.Warnings
		result3 error
	}
	MakeRequestSendRawStub        func(string, internal.Params, []byte, string, interface{}) (string, ccv3.Warnings, error)
	makeRequestSendRawMutex       sync.RWMutex
	makeRequestSendRawArgsForCall []struct {
		arg1 string
		arg2 internal.Params
		arg3 []byte
		arg4 string
		arg5 interface{}
	}
	makeRequestSendRawReturns struct {
		result1 string
		result2 ccv3.Warnings
		result3 error
	}
	makeRequestSendRawReturnsOnCall map[int]struct {
		result1 string
		result2 ccv3.Warnings
		result3 error
	}
	MakeRequestSendReceiveRawStub        func(string, string, http.Header, []byte) ([]byte, *http.Response, error)
	makeRequestSendReceiveRawMutex       sync.RWMutex
	makeRequestSendReceiveRawArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 http.Header
		arg4 []byte
	}
	makeRequestSendReceiveRawReturns struct {
		result1 []byte
		result2 *http.Response
		result3 error
	}
	makeRequestSendReceiveRawReturnsOnCall map[int]struct {
		result1 []byte
		result2 *http.Response
		result3 error
	}
	MakeRequestUploadAsyncStub        func(string, internal.Params, string, io.ReadSeeker, int64, interface{}, <-chan error) (string, ccv3.Warnings, error)
	makeRequestUploadAsyncMutex       sync.RWMutex
	makeRequestUploadAsyncArgsForCall []struct {
		arg1 string
		arg2 internal.Params
		arg3 string
		arg4 io.ReadSeeker
		arg5 int64
		arg6 interface{}
		arg7 <-chan error
	}
	makeRequestUploadAsyncReturns struct {
		result1 string
		result2 ccv3.Warnings
		result3 error
	}
	makeRequestUploadAsyncReturnsOnCall map[int]struct {
		result1 string
		result2 ccv3.Warnings
		result3 error
	}
	WrapConnectionStub        func(ccv3.ConnectionWrapper)
	wrapConnectionMutex       sync.RWMutex
	wrapConnectionArgsForCall []struct {
		arg1 ccv3.ConnectionWrapper
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRequester) InitializeConnection(arg1 ccv3.TargetSettings) {
	fake.initializeConnectionMutex.Lock()
	fake.initializeConnectionArgsForCall = append(fake.initializeConnectionArgsForCall, struct {
		arg1 ccv3.TargetSettings
	}{arg1})
	fake.recordInvocation("InitializeConnection", []interface{}{arg1})
	fake.initializeConnectionMutex.Unlock()
	if fake.InitializeConnectionStub != nil {
		fake.InitializeConnectionStub(arg1)
	}
}

func (fake *FakeRequester) InitializeConnectionCallCount() int {
	fake.initializeConnectionMutex.RLock()
	defer fake.initializeConnectionMutex.RUnlock()
	return len(fake.initializeConnectionArgsForCall)
}

func (fake *FakeRequester) InitializeConnectionCalls(stub func(ccv3.TargetSettings)) {
	fake.initializeConnectionMutex.Lock()
	defer fake.initializeConnectionMutex.Unlock()
	fake.InitializeConnectionStub = stub
}

func (fake *FakeRequester) InitializeConnectionArgsForCall(i int) ccv3.TargetSettings {
	fake.initializeConnectionMutex.RLock()
	defer fake.initializeConnectionMutex.RUnlock()
	argsForCall := fake.initializeConnectionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRequester) InitializeRouter(arg1 string) {
	fake.initializeRouterMutex.Lock()
	fake.initializeRouterArgsForCall = append(fake.initializeRouterArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("InitializeRouter", []interface{}{arg1})
	fake.initializeRouterMutex.Unlock()
	if fake.InitializeRouterStub != nil {
		fake.InitializeRouterStub(arg1)
	}
}

func (fake *FakeRequester) InitializeRouterCallCount() int {
	fake.initializeRouterMutex.RLock()
	defer fake.initializeRouterMutex.RUnlock()
	return len(fake.initializeRouterArgsForCall)
}

func (fake *FakeRequester) InitializeRouterCalls(stub func(string)) {
	fake.initializeRouterMutex.Lock()
	defer fake.initializeRouterMutex.Unlock()
	fake.InitializeRouterStub = stub
}

func (fake *FakeRequester) InitializeRouterArgsForCall(i int) string {
	fake.initializeRouterMutex.RLock()
	defer fake.initializeRouterMutex.RUnlock()
	argsForCall := fake.initializeRouterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRequester) MakeListRequest(arg1 ccv3.RequestParams) (ccv3.IncludedResources, ccv3.Warnings, error) {
	fake.makeListRequestMutex.Lock()
	ret, specificReturn := fake.makeListRequestReturnsOnCall[len(fake.makeListRequestArgsForCall)]
	fake.makeListRequestArgsForCall = append(fake.makeListRequestArgsForCall, struct {
		arg1 ccv3.RequestParams
	}{arg1})
	fake.recordInvocation("MakeListRequest", []interface{}{arg1})
	fake.makeListRequestMutex.Unlock()
	if fake.MakeListRequestStub != nil {
		return fake.MakeListRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.makeListRequestReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeRequester) MakeListRequestCallCount() int {
	fake.makeListRequestMutex.RLock()
	defer fake.makeListRequestMutex.RUnlock()
	return len(fake.makeListRequestArgsForCall)
}

func (fake *FakeRequester) MakeListRequestCalls(stub func(ccv3.RequestParams) (ccv3.IncludedResources, ccv3.Warnings, error)) {
	fake.makeListRequestMutex.Lock()
	defer fake.makeListRequestMutex.Unlock()
	fake.MakeListRequestStub = stub
}

func (fake *FakeRequester) MakeListRequestArgsForCall(i int) ccv3.RequestParams {
	fake.makeListRequestMutex.RLock()
	defer fake.makeListRequestMutex.RUnlock()
	argsForCall := fake.makeListRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRequester) MakeListRequestReturns(result1 ccv3.IncludedResources, result2 ccv3.Warnings, result3 error) {
	fake.makeListRequestMutex.Lock()
	defer fake.makeListRequestMutex.Unlock()
	fake.MakeListRequestStub = nil
	fake.makeListRequestReturns = struct {
		result1 ccv3.IncludedResources
		result2 ccv3.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeRequester) MakeListRequestReturnsOnCall(i int, result1 ccv3.IncludedResources, result2 ccv3.Warnings, result3 error) {
	fake.makeListRequestMutex.Lock()
	defer fake.makeListRequestMutex.Unlock()
	fake.MakeListRequestStub = nil
	if fake.makeListRequestReturnsOnCall == nil {
		fake.makeListRequestReturnsOnCall = make(map[int]struct {
			result1 ccv3.IncludedResources
			result2 ccv3.Warnings
			result3 error
		})
	}
	fake.makeListRequestReturnsOnCall[i] = struct {
		result1 ccv3.IncludedResources
		result2 ccv3.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeRequester) MakeRequest(arg1 ccv3.RequestParams) (ccv3.JobURL, ccv3.Warnings, error) {
	fake.makeRequestMutex.Lock()
	ret, specificReturn := fake.makeRequestReturnsOnCall[len(fake.makeRequestArgsForCall)]
	fake.makeRequestArgsForCall = append(fake.makeRequestArgsForCall, struct {
		arg1 ccv3.RequestParams
	}{arg1})
	fake.recordInvocation("MakeRequest", []interface{}{arg1})
	fake.makeRequestMutex.Unlock()
	if fake.MakeRequestStub != nil {
		return fake.MakeRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.makeRequestReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeRequester) MakeRequestCallCount() int {
	fake.makeRequestMutex.RLock()
	defer fake.makeRequestMutex.RUnlock()
	return len(fake.makeRequestArgsForCall)
}

func (fake *FakeRequester) MakeRequestCalls(stub func(ccv3.RequestParams) (ccv3.JobURL, ccv3.Warnings, error)) {
	fake.makeRequestMutex.Lock()
	defer fake.makeRequestMutex.Unlock()
	fake.MakeRequestStub = stub
}

func (fake *FakeRequester) MakeRequestArgsForCall(i int) ccv3.RequestParams {
	fake.makeRequestMutex.RLock()
	defer fake.makeRequestMutex.RUnlock()
	argsForCall := fake.makeRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRequester) MakeRequestReturns(result1 ccv3.JobURL, result2 ccv3.Warnings, result3 error) {
	fake.makeRequestMutex.Lock()
	defer fake.makeRequestMutex.Unlock()
	fake.MakeRequestStub = nil
	fake.makeRequestReturns = struct {
		result1 ccv3.JobURL
		result2 ccv3.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeRequester) MakeRequestReturnsOnCall(i int, result1 ccv3.JobURL, result2 ccv3.Warnings, result3 error) {
	fake.makeRequestMutex.Lock()
	defer fake.makeRequestMutex.Unlock()
	fake.MakeRequestStub = nil
	if fake.makeRequestReturnsOnCall == nil {
		fake.makeRequestReturnsOnCall = make(map[int]struct {
			result1 ccv3.JobURL
			result2 ccv3.Warnings
			result3 error
		})
	}
	fake.makeRequestReturnsOnCall[i] = struct {
		result1 ccv3.JobURL
		result2 ccv3.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeRequester) MakeRequestReceiveRaw(arg1 string, arg2 internal.Params, arg3 string) ([]byte, ccv3.Warnings, error) {
	fake.makeRequestReceiveRawMutex.Lock()
	ret, specificReturn := fake.makeRequestReceiveRawReturnsOnCall[len(fake.makeRequestReceiveRawArgsForCall)]
	fake.makeRequestReceiveRawArgsForCall = append(fake.makeRequestReceiveRawArgsForCall, struct {
		arg1 string
		arg2 internal.Params
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("MakeRequestReceiveRaw", []interface{}{arg1, arg2, arg3})
	fake.makeRequestReceiveRawMutex.Unlock()
	if fake.MakeRequestReceiveRawStub != nil {
		return fake.MakeRequestReceiveRawStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.makeRequestReceiveRawReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeRequester) MakeRequestReceiveRawCallCount() int {
	fake.makeRequestReceiveRawMutex.RLock()
	defer fake.makeRequestReceiveRawMutex.RUnlock()
	return len(fake.makeRequestReceiveRawArgsForCall)
}

func (fake *FakeRequester) MakeRequestReceiveRawCalls(stub func(string, internal.Params, string) ([]byte, ccv3.Warnings, error)) {
	fake.makeRequestReceiveRawMutex.Lock()
	defer fake.makeRequestReceiveRawMutex.Unlock()
	fake.MakeRequestReceiveRawStub = stub
}

func (fake *FakeRequester) MakeRequestReceiveRawArgsForCall(i int) (string, internal.Params, string) {
	fake.makeRequestReceiveRawMutex.RLock()
	defer fake.makeRequestReceiveRawMutex.RUnlock()
	argsForCall := fake.makeRequestReceiveRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRequester) MakeRequestReceiveRawReturns(result1 []byte, result2 ccv3.Warnings, result3 error) {
	fake.makeRequestReceiveRawMutex.Lock()
	defer fake.makeRequestReceiveRawMutex.Unlock()
	fake.MakeRequestReceiveRawStub = nil
	fake.makeRequestReceiveRawReturns = struct {
		result1 []byte
		result2 ccv3.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeRequester) MakeRequestReceiveRawReturnsOnCall(i int, result1 []byte, result2 ccv3.Warnings, result3 error) {
	fake.makeRequestReceiveRawMutex.Lock()
	defer fake.makeRequestReceiveRawMutex.Unlock()
	fake.MakeRequestReceiveRawStub = nil
	if fake.makeRequestReceiveRawReturnsOnCall == nil {
		fake.makeRequestReceiveRawReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 ccv3.Warnings
			result3 error
		})
	}
	fake.makeRequestReceiveRawReturnsOnCall[i] = struct {
		result1 []byte
		result2 ccv3.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeRequester) MakeRequestSendRaw(arg1 string, arg2 internal.Params, arg3 []byte, arg4 string, arg5 interface{}) (string, ccv3.Warnings, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.makeRequestSendRawMutex.Lock()
	ret, specificReturn := fake.makeRequestSendRawReturnsOnCall[len(fake.makeRequestSendRawArgsForCall)]
	fake.makeRequestSendRawArgsForCall = append(fake.makeRequestSendRawArgsForCall, struct {
		arg1 string
		arg2 internal.Params
		arg3 []byte
		arg4 string
		arg5 interface{}
	}{arg1, arg2, arg3Copy, arg4, arg5})
	fake.recordInvocation("MakeRequestSendRaw", []interface{}{arg1, arg2, arg3Copy, arg4, arg5})
	fake.makeRequestSendRawMutex.Unlock()
	if fake.MakeRequestSendRawStub != nil {
		return fake.MakeRequestSendRawStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.makeRequestSendRawReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeRequester) MakeRequestSendRawCallCount() int {
	fake.makeRequestSendRawMutex.RLock()
	defer fake.makeRequestSendRawMutex.RUnlock()
	return len(fake.makeRequestSendRawArgsForCall)
}

func (fake *FakeRequester) MakeRequestSendRawCalls(stub func(string, internal.Params, []byte, string, interface{}) (string, ccv3.Warnings, error)) {
	fake.makeRequestSendRawMutex.Lock()
	defer fake.makeRequestSendRawMutex.Unlock()
	fake.MakeRequestSendRawStub = stub
}

func (fake *FakeRequester) MakeRequestSendRawArgsForCall(i int) (string, internal.Params, []byte, string, interface{}) {
	fake.makeRequestSendRawMutex.RLock()
	defer fake.makeRequestSendRawMutex.RUnlock()
	argsForCall := fake.makeRequestSendRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeRequester) MakeRequestSendRawReturns(result1 string, result2 ccv3.Warnings, result3 error) {
	fake.makeRequestSendRawMutex.Lock()
	defer fake.makeRequestSendRawMutex.Unlock()
	fake.MakeRequestSendRawStub = nil
	fake.makeRequestSendRawReturns = struct {
		result1 string
		result2 ccv3.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeRequester) MakeRequestSendRawReturnsOnCall(i int, result1 string, result2 ccv3.Warnings, result3 error) {
	fake.makeRequestSendRawMutex.Lock()
	defer fake.makeRequestSendRawMutex.Unlock()
	fake.MakeRequestSendRawStub = nil
	if fake.makeRequestSendRawReturnsOnCall == nil {
		fake.makeRequestSendRawReturnsOnCall = make(map[int]struct {
			result1 string
			result2 ccv3.Warnings
			result3 error
		})
	}
	fake.makeRequestSendRawReturnsOnCall[i] = struct {
		result1 string
		result2 ccv3.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeRequester) MakeRequestSendReceiveRaw(arg1 string, arg2 string, arg3 http.Header, arg4 []byte) ([]byte, *http.Response, error) {
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.makeRequestSendReceiveRawMutex.Lock()
	ret, specificReturn := fake.makeRequestSendReceiveRawReturnsOnCall[len(fake.makeRequestSendReceiveRawArgsForCall)]
	fake.makeRequestSendReceiveRawArgsForCall = append(fake.makeRequestSendReceiveRawArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 http.Header
		arg4 []byte
	}{arg1, arg2, arg3, arg4Copy})
	fake.recordInvocation("MakeRequestSendReceiveRaw", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.makeRequestSendReceiveRawMutex.Unlock()
	if fake.MakeRequestSendReceiveRawStub != nil {
		return fake.MakeRequestSendReceiveRawStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.makeRequestSendReceiveRawReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeRequester) MakeRequestSendReceiveRawCallCount() int {
	fake.makeRequestSendReceiveRawMutex.RLock()
	defer fake.makeRequestSendReceiveRawMutex.RUnlock()
	return len(fake.makeRequestSendReceiveRawArgsForCall)
}

func (fake *FakeRequester) MakeRequestSendReceiveRawCalls(stub func(string, string, http.Header, []byte) ([]byte, *http.Response, error)) {
	fake.makeRequestSendReceiveRawMutex.Lock()
	defer fake.makeRequestSendReceiveRawMutex.Unlock()
	fake.MakeRequestSendReceiveRawStub = stub
}

func (fake *FakeRequester) MakeRequestSendReceiveRawArgsForCall(i int) (string, string, http.Header, []byte) {
	fake.makeRequestSendReceiveRawMutex.RLock()
	defer fake.makeRequestSendReceiveRawMutex.RUnlock()
	argsForCall := fake.makeRequestSendReceiveRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeRequester) MakeRequestSendReceiveRawReturns(result1 []byte, result2 *http.Response, result3 error) {
	fake.makeRequestSendReceiveRawMutex.Lock()
	defer fake.makeRequestSendReceiveRawMutex.Unlock()
	fake.MakeRequestSendReceiveRawStub = nil
	fake.makeRequestSendReceiveRawReturns = struct {
		result1 []byte
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeRequester) MakeRequestSendReceiveRawReturnsOnCall(i int, result1 []byte, result2 *http.Response, result3 error) {
	fake.makeRequestSendReceiveRawMutex.Lock()
	defer fake.makeRequestSendReceiveRawMutex.Unlock()
	fake.MakeRequestSendReceiveRawStub = nil
	if fake.makeRequestSendReceiveRawReturnsOnCall == nil {
		fake.makeRequestSendReceiveRawReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 *http.Response
			result3 error
		})
	}
	fake.makeRequestSendReceiveRawReturnsOnCall[i] = struct {
		result1 []byte
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeRequester) MakeRequestUploadAsync(arg1 string, arg2 internal.Params, arg3 string, arg4 io.ReadSeeker, arg5 int64, arg6 interface{}, arg7 <-chan error) (string, ccv3.Warnings, error) {
	fake.makeRequestUploadAsyncMutex.Lock()
	ret, specificReturn := fake.makeRequestUploadAsyncReturnsOnCall[len(fake.makeRequestUploadAsyncArgsForCall)]
	fake.makeRequestUploadAsyncArgsForCall = append(fake.makeRequestUploadAsyncArgsForCall, struct {
		arg1 string
		arg2 internal.Params
		arg3 string
		arg4 io.ReadSeeker
		arg5 int64
		arg6 interface{}
		arg7 <-chan error
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.recordInvocation("MakeRequestUploadAsync", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.makeRequestUploadAsyncMutex.Unlock()
	if fake.MakeRequestUploadAsyncStub != nil {
		return fake.MakeRequestUploadAsyncStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.makeRequestUploadAsyncReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeRequester) MakeRequestUploadAsyncCallCount() int {
	fake.makeRequestUploadAsyncMutex.RLock()
	defer fake.makeRequestUploadAsyncMutex.RUnlock()
	return len(fake.makeRequestUploadAsyncArgsForCall)
}

func (fake *FakeRequester) MakeRequestUploadAsyncCalls(stub func(string, internal.Params, string, io.ReadSeeker, int64, interface{}, <-chan error) (string, ccv3.Warnings, error)) {
	fake.makeRequestUploadAsyncMutex.Lock()
	defer fake.makeRequestUploadAsyncMutex.Unlock()
	fake.MakeRequestUploadAsyncStub = stub
}

func (fake *FakeRequester) MakeRequestUploadAsyncArgsForCall(i int) (string, internal.Params, string, io.ReadSeeker, int64, interface{}, <-chan error) {
	fake.makeRequestUploadAsyncMutex.RLock()
	defer fake.makeRequestUploadAsyncMutex.RUnlock()
	argsForCall := fake.makeRequestUploadAsyncArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeRequester) MakeRequestUploadAsyncReturns(result1 string, result2 ccv3.Warnings, result3 error) {
	fake.makeRequestUploadAsyncMutex.Lock()
	defer fake.makeRequestUploadAsyncMutex.Unlock()
	fake.MakeRequestUploadAsyncStub = nil
	fake.makeRequestUploadAsyncReturns = struct {
		result1 string
		result2 ccv3.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeRequester) MakeRequestUploadAsyncReturnsOnCall(i int, result1 string, result2 ccv3.Warnings, result3 error) {
	fake.makeRequestUploadAsyncMutex.Lock()
	defer fake.makeRequestUploadAsyncMutex.Unlock()
	fake.MakeRequestUploadAsyncStub = nil
	if fake.makeRequestUploadAsyncReturnsOnCall == nil {
		fake.makeRequestUploadAsyncReturnsOnCall = make(map[int]struct {
			result1 string
			result2 ccv3.Warnings
			result3 error
		})
	}
	fake.makeRequestUploadAsyncReturnsOnCall[i] = struct {
		result1 string
		result2 ccv3.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeRequester) WrapConnection(arg1 ccv3.ConnectionWrapper) {
	fake.wrapConnectionMutex.Lock()
	fake.wrapConnectionArgsForCall = append(fake.wrapConnectionArgsForCall, struct {
		arg1 ccv3.ConnectionWrapper
	}{arg1})
	fake.recordInvocation("WrapConnection", []interface{}{arg1})
	fake.wrapConnectionMutex.Unlock()
	if fake.WrapConnectionStub != nil {
		fake.WrapConnectionStub(arg1)
	}
}

func (fake *FakeRequester) WrapConnectionCallCount() int {
	fake.wrapConnectionMutex.RLock()
	defer fake.wrapConnectionMutex.RUnlock()
	return len(fake.wrapConnectionArgsForCall)
}

func (fake *FakeRequester) WrapConnectionCalls(stub func(ccv3.ConnectionWrapper)) {
	fake.wrapConnectionMutex.Lock()
	defer fake.wrapConnectionMutex.Unlock()
	fake.WrapConnectionStub = stub
}

func (fake *FakeRequester) WrapConnectionArgsForCall(i int) ccv3.ConnectionWrapper {
	fake.wrapConnectionMutex.RLock()
	defer fake.wrapConnectionMutex.RUnlock()
	argsForCall := fake.wrapConnectionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRequester) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.initializeConnectionMutex.RLock()
	defer fake.initializeConnectionMutex.RUnlock()
	fake.initializeRouterMutex.RLock()
	defer fake.initializeRouterMutex.RUnlock()
	fake.makeListRequestMutex.RLock()
	defer fake.makeListRequestMutex.RUnlock()
	fake.makeRequestMutex.RLock()
	defer fake.makeRequestMutex.RUnlock()
	fake.makeRequestReceiveRawMutex.RLock()
	defer fake.makeRequestReceiveRawMutex.RUnlock()
	fake.makeRequestSendRawMutex.RLock()
	defer fake.makeRequestSendRawMutex.RUnlock()
	fake.makeRequestSendReceiveRawMutex.RLock()
	defer fake.makeRequestSendReceiveRawMutex.RUnlock()
	fake.makeRequestUploadAsyncMutex.RLock()
	defer fake.makeRequestUploadAsyncMutex.RUnlock()
	fake.wrapConnectionMutex.RLock()
	defer fake.wrapConnectionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRequester) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ccv3.Requester = new(FakeRequester)
