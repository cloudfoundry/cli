// Code generated by counterfeiter. DO NOT EDIT.
package uaafakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/cli/api/uaa"
)

type FakeConfig struct {
	BinaryNameStub        func() string
	binaryNameMutex       sync.RWMutex
	binaryNameArgsForCall []struct {
	}
	binaryNameReturns struct {
		result1 string
	}
	binaryNameReturnsOnCall map[int]struct {
		result1 string
	}
	BinaryVersionStub        func() string
	binaryVersionMutex       sync.RWMutex
	binaryVersionArgsForCall []struct {
	}
	binaryVersionReturns struct {
		result1 string
	}
	binaryVersionReturnsOnCall map[int]struct {
		result1 string
	}
	DialTimeoutStub        func() time.Duration
	dialTimeoutMutex       sync.RWMutex
	dialTimeoutArgsForCall []struct {
	}
	dialTimeoutReturns struct {
		result1 time.Duration
	}
	dialTimeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	SetUAAEndpointStub        func(string)
	setUAAEndpointMutex       sync.RWMutex
	setUAAEndpointArgsForCall []struct {
		arg1 string
	}
	SkipSSLValidationStub        func() bool
	skipSSLValidationMutex       sync.RWMutex
	skipSSLValidationArgsForCall []struct {
	}
	skipSSLValidationReturns struct {
		result1 bool
	}
	skipSSLValidationReturnsOnCall map[int]struct {
		result1 bool
	}
	UAADisableKeepAlivesStub        func() bool
	uAADisableKeepAlivesMutex       sync.RWMutex
	uAADisableKeepAlivesArgsForCall []struct {
	}
	uAADisableKeepAlivesReturns struct {
		result1 bool
	}
	uAADisableKeepAlivesReturnsOnCall map[int]struct {
		result1 bool
	}
	UAAGrantTypeStub        func() string
	uAAGrantTypeMutex       sync.RWMutex
	uAAGrantTypeArgsForCall []struct {
	}
	uAAGrantTypeReturns struct {
		result1 string
	}
	uAAGrantTypeReturnsOnCall map[int]struct {
		result1 string
	}
	UAAOAuthClientStub        func() string
	uAAOAuthClientMutex       sync.RWMutex
	uAAOAuthClientArgsForCall []struct {
	}
	uAAOAuthClientReturns struct {
		result1 string
	}
	uAAOAuthClientReturnsOnCall map[int]struct {
		result1 string
	}
	UAAOAuthClientSecretStub        func() string
	uAAOAuthClientSecretMutex       sync.RWMutex
	uAAOAuthClientSecretArgsForCall []struct {
	}
	uAAOAuthClientSecretReturns struct {
		result1 string
	}
	uAAOAuthClientSecretReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConfig) BinaryName() string {
	fake.binaryNameMutex.Lock()
	ret, specificReturn := fake.binaryNameReturnsOnCall[len(fake.binaryNameArgsForCall)]
	fake.binaryNameArgsForCall = append(fake.binaryNameArgsForCall, struct {
	}{})
	fake.recordInvocation("BinaryName", []interface{}{})
	fake.binaryNameMutex.Unlock()
	if fake.BinaryNameStub != nil {
		return fake.BinaryNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.binaryNameReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) BinaryNameCallCount() int {
	fake.binaryNameMutex.RLock()
	defer fake.binaryNameMutex.RUnlock()
	return len(fake.binaryNameArgsForCall)
}

func (fake *FakeConfig) BinaryNameCalls(stub func() string) {
	fake.binaryNameMutex.Lock()
	defer fake.binaryNameMutex.Unlock()
	fake.BinaryNameStub = stub
}

func (fake *FakeConfig) BinaryNameReturns(result1 string) {
	fake.binaryNameMutex.Lock()
	defer fake.binaryNameMutex.Unlock()
	fake.BinaryNameStub = nil
	fake.binaryNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BinaryNameReturnsOnCall(i int, result1 string) {
	fake.binaryNameMutex.Lock()
	defer fake.binaryNameMutex.Unlock()
	fake.BinaryNameStub = nil
	if fake.binaryNameReturnsOnCall == nil {
		fake.binaryNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.binaryNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BinaryVersion() string {
	fake.binaryVersionMutex.Lock()
	ret, specificReturn := fake.binaryVersionReturnsOnCall[len(fake.binaryVersionArgsForCall)]
	fake.binaryVersionArgsForCall = append(fake.binaryVersionArgsForCall, struct {
	}{})
	fake.recordInvocation("BinaryVersion", []interface{}{})
	fake.binaryVersionMutex.Unlock()
	if fake.BinaryVersionStub != nil {
		return fake.BinaryVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.binaryVersionReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) BinaryVersionCallCount() int {
	fake.binaryVersionMutex.RLock()
	defer fake.binaryVersionMutex.RUnlock()
	return len(fake.binaryVersionArgsForCall)
}

func (fake *FakeConfig) BinaryVersionCalls(stub func() string) {
	fake.binaryVersionMutex.Lock()
	defer fake.binaryVersionMutex.Unlock()
	fake.BinaryVersionStub = stub
}

func (fake *FakeConfig) BinaryVersionReturns(result1 string) {
	fake.binaryVersionMutex.Lock()
	defer fake.binaryVersionMutex.Unlock()
	fake.BinaryVersionStub = nil
	fake.binaryVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BinaryVersionReturnsOnCall(i int, result1 string) {
	fake.binaryVersionMutex.Lock()
	defer fake.binaryVersionMutex.Unlock()
	fake.BinaryVersionStub = nil
	if fake.binaryVersionReturnsOnCall == nil {
		fake.binaryVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.binaryVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) DialTimeout() time.Duration {
	fake.dialTimeoutMutex.Lock()
	ret, specificReturn := fake.dialTimeoutReturnsOnCall[len(fake.dialTimeoutArgsForCall)]
	fake.dialTimeoutArgsForCall = append(fake.dialTimeoutArgsForCall, struct {
	}{})
	fake.recordInvocation("DialTimeout", []interface{}{})
	fake.dialTimeoutMutex.Unlock()
	if fake.DialTimeoutStub != nil {
		return fake.DialTimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.dialTimeoutReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) DialTimeoutCallCount() int {
	fake.dialTimeoutMutex.RLock()
	defer fake.dialTimeoutMutex.RUnlock()
	return len(fake.dialTimeoutArgsForCall)
}

func (fake *FakeConfig) DialTimeoutCalls(stub func() time.Duration) {
	fake.dialTimeoutMutex.Lock()
	defer fake.dialTimeoutMutex.Unlock()
	fake.DialTimeoutStub = stub
}

func (fake *FakeConfig) DialTimeoutReturns(result1 time.Duration) {
	fake.dialTimeoutMutex.Lock()
	defer fake.dialTimeoutMutex.Unlock()
	fake.DialTimeoutStub = nil
	fake.dialTimeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) DialTimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.dialTimeoutMutex.Lock()
	defer fake.dialTimeoutMutex.Unlock()
	fake.DialTimeoutStub = nil
	if fake.dialTimeoutReturnsOnCall == nil {
		fake.dialTimeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.dialTimeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) SetUAAEndpoint(arg1 string) {
	fake.setUAAEndpointMutex.Lock()
	fake.setUAAEndpointArgsForCall = append(fake.setUAAEndpointArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetUAAEndpoint", []interface{}{arg1})
	fake.setUAAEndpointMutex.Unlock()
	if fake.SetUAAEndpointStub != nil {
		fake.SetUAAEndpointStub(arg1)
	}
}

func (fake *FakeConfig) SetUAAEndpointCallCount() int {
	fake.setUAAEndpointMutex.RLock()
	defer fake.setUAAEndpointMutex.RUnlock()
	return len(fake.setUAAEndpointArgsForCall)
}

func (fake *FakeConfig) SetUAAEndpointCalls(stub func(string)) {
	fake.setUAAEndpointMutex.Lock()
	defer fake.setUAAEndpointMutex.Unlock()
	fake.SetUAAEndpointStub = stub
}

func (fake *FakeConfig) SetUAAEndpointArgsForCall(i int) string {
	fake.setUAAEndpointMutex.RLock()
	defer fake.setUAAEndpointMutex.RUnlock()
	argsForCall := fake.setUAAEndpointArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConfig) SkipSSLValidation() bool {
	fake.skipSSLValidationMutex.Lock()
	ret, specificReturn := fake.skipSSLValidationReturnsOnCall[len(fake.skipSSLValidationArgsForCall)]
	fake.skipSSLValidationArgsForCall = append(fake.skipSSLValidationArgsForCall, struct {
	}{})
	fake.recordInvocation("SkipSSLValidation", []interface{}{})
	fake.skipSSLValidationMutex.Unlock()
	if fake.SkipSSLValidationStub != nil {
		return fake.SkipSSLValidationStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.skipSSLValidationReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) SkipSSLValidationCallCount() int {
	fake.skipSSLValidationMutex.RLock()
	defer fake.skipSSLValidationMutex.RUnlock()
	return len(fake.skipSSLValidationArgsForCall)
}

func (fake *FakeConfig) SkipSSLValidationCalls(stub func() bool) {
	fake.skipSSLValidationMutex.Lock()
	defer fake.skipSSLValidationMutex.Unlock()
	fake.SkipSSLValidationStub = stub
}

func (fake *FakeConfig) SkipSSLValidationReturns(result1 bool) {
	fake.skipSSLValidationMutex.Lock()
	defer fake.skipSSLValidationMutex.Unlock()
	fake.SkipSSLValidationStub = nil
	fake.skipSSLValidationReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) SkipSSLValidationReturnsOnCall(i int, result1 bool) {
	fake.skipSSLValidationMutex.Lock()
	defer fake.skipSSLValidationMutex.Unlock()
	fake.SkipSSLValidationStub = nil
	if fake.skipSSLValidationReturnsOnCall == nil {
		fake.skipSSLValidationReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.skipSSLValidationReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) UAADisableKeepAlives() bool {
	fake.uAADisableKeepAlivesMutex.Lock()
	ret, specificReturn := fake.uAADisableKeepAlivesReturnsOnCall[len(fake.uAADisableKeepAlivesArgsForCall)]
	fake.uAADisableKeepAlivesArgsForCall = append(fake.uAADisableKeepAlivesArgsForCall, struct {
	}{})
	fake.recordInvocation("UAADisableKeepAlives", []interface{}{})
	fake.uAADisableKeepAlivesMutex.Unlock()
	if fake.UAADisableKeepAlivesStub != nil {
		return fake.UAADisableKeepAlivesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uAADisableKeepAlivesReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) UAADisableKeepAlivesCallCount() int {
	fake.uAADisableKeepAlivesMutex.RLock()
	defer fake.uAADisableKeepAlivesMutex.RUnlock()
	return len(fake.uAADisableKeepAlivesArgsForCall)
}

func (fake *FakeConfig) UAADisableKeepAlivesCalls(stub func() bool) {
	fake.uAADisableKeepAlivesMutex.Lock()
	defer fake.uAADisableKeepAlivesMutex.Unlock()
	fake.UAADisableKeepAlivesStub = stub
}

func (fake *FakeConfig) UAADisableKeepAlivesReturns(result1 bool) {
	fake.uAADisableKeepAlivesMutex.Lock()
	defer fake.uAADisableKeepAlivesMutex.Unlock()
	fake.UAADisableKeepAlivesStub = nil
	fake.uAADisableKeepAlivesReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) UAADisableKeepAlivesReturnsOnCall(i int, result1 bool) {
	fake.uAADisableKeepAlivesMutex.Lock()
	defer fake.uAADisableKeepAlivesMutex.Unlock()
	fake.UAADisableKeepAlivesStub = nil
	if fake.uAADisableKeepAlivesReturnsOnCall == nil {
		fake.uAADisableKeepAlivesReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.uAADisableKeepAlivesReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) UAAGrantType() string {
	fake.uAAGrantTypeMutex.Lock()
	ret, specificReturn := fake.uAAGrantTypeReturnsOnCall[len(fake.uAAGrantTypeArgsForCall)]
	fake.uAAGrantTypeArgsForCall = append(fake.uAAGrantTypeArgsForCall, struct {
	}{})
	fake.recordInvocation("UAAGrantType", []interface{}{})
	fake.uAAGrantTypeMutex.Unlock()
	if fake.UAAGrantTypeStub != nil {
		return fake.UAAGrantTypeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uAAGrantTypeReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) UAAGrantTypeCallCount() int {
	fake.uAAGrantTypeMutex.RLock()
	defer fake.uAAGrantTypeMutex.RUnlock()
	return len(fake.uAAGrantTypeArgsForCall)
}

func (fake *FakeConfig) UAAGrantTypeCalls(stub func() string) {
	fake.uAAGrantTypeMutex.Lock()
	defer fake.uAAGrantTypeMutex.Unlock()
	fake.UAAGrantTypeStub = stub
}

func (fake *FakeConfig) UAAGrantTypeReturns(result1 string) {
	fake.uAAGrantTypeMutex.Lock()
	defer fake.uAAGrantTypeMutex.Unlock()
	fake.UAAGrantTypeStub = nil
	fake.uAAGrantTypeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAGrantTypeReturnsOnCall(i int, result1 string) {
	fake.uAAGrantTypeMutex.Lock()
	defer fake.uAAGrantTypeMutex.Unlock()
	fake.UAAGrantTypeStub = nil
	if fake.uAAGrantTypeReturnsOnCall == nil {
		fake.uAAGrantTypeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uAAGrantTypeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClient() string {
	fake.uAAOAuthClientMutex.Lock()
	ret, specificReturn := fake.uAAOAuthClientReturnsOnCall[len(fake.uAAOAuthClientArgsForCall)]
	fake.uAAOAuthClientArgsForCall = append(fake.uAAOAuthClientArgsForCall, struct {
	}{})
	fake.recordInvocation("UAAOAuthClient", []interface{}{})
	fake.uAAOAuthClientMutex.Unlock()
	if fake.UAAOAuthClientStub != nil {
		return fake.UAAOAuthClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uAAOAuthClientReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) UAAOAuthClientCallCount() int {
	fake.uAAOAuthClientMutex.RLock()
	defer fake.uAAOAuthClientMutex.RUnlock()
	return len(fake.uAAOAuthClientArgsForCall)
}

func (fake *FakeConfig) UAAOAuthClientCalls(stub func() string) {
	fake.uAAOAuthClientMutex.Lock()
	defer fake.uAAOAuthClientMutex.Unlock()
	fake.UAAOAuthClientStub = stub
}

func (fake *FakeConfig) UAAOAuthClientReturns(result1 string) {
	fake.uAAOAuthClientMutex.Lock()
	defer fake.uAAOAuthClientMutex.Unlock()
	fake.UAAOAuthClientStub = nil
	fake.uAAOAuthClientReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClientReturnsOnCall(i int, result1 string) {
	fake.uAAOAuthClientMutex.Lock()
	defer fake.uAAOAuthClientMutex.Unlock()
	fake.UAAOAuthClientStub = nil
	if fake.uAAOAuthClientReturnsOnCall == nil {
		fake.uAAOAuthClientReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uAAOAuthClientReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClientSecret() string {
	fake.uAAOAuthClientSecretMutex.Lock()
	ret, specificReturn := fake.uAAOAuthClientSecretReturnsOnCall[len(fake.uAAOAuthClientSecretArgsForCall)]
	fake.uAAOAuthClientSecretArgsForCall = append(fake.uAAOAuthClientSecretArgsForCall, struct {
	}{})
	fake.recordInvocation("UAAOAuthClientSecret", []interface{}{})
	fake.uAAOAuthClientSecretMutex.Unlock()
	if fake.UAAOAuthClientSecretStub != nil {
		return fake.UAAOAuthClientSecretStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uAAOAuthClientSecretReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) UAAOAuthClientSecretCallCount() int {
	fake.uAAOAuthClientSecretMutex.RLock()
	defer fake.uAAOAuthClientSecretMutex.RUnlock()
	return len(fake.uAAOAuthClientSecretArgsForCall)
}

func (fake *FakeConfig) UAAOAuthClientSecretCalls(stub func() string) {
	fake.uAAOAuthClientSecretMutex.Lock()
	defer fake.uAAOAuthClientSecretMutex.Unlock()
	fake.UAAOAuthClientSecretStub = stub
}

func (fake *FakeConfig) UAAOAuthClientSecretReturns(result1 string) {
	fake.uAAOAuthClientSecretMutex.Lock()
	defer fake.uAAOAuthClientSecretMutex.Unlock()
	fake.UAAOAuthClientSecretStub = nil
	fake.uAAOAuthClientSecretReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClientSecretReturnsOnCall(i int, result1 string) {
	fake.uAAOAuthClientSecretMutex.Lock()
	defer fake.uAAOAuthClientSecretMutex.Unlock()
	fake.UAAOAuthClientSecretStub = nil
	if fake.uAAOAuthClientSecretReturnsOnCall == nil {
		fake.uAAOAuthClientSecretReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uAAOAuthClientSecretReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.binaryNameMutex.RLock()
	defer fake.binaryNameMutex.RUnlock()
	fake.binaryVersionMutex.RLock()
	defer fake.binaryVersionMutex.RUnlock()
	fake.dialTimeoutMutex.RLock()
	defer fake.dialTimeoutMutex.RUnlock()
	fake.setUAAEndpointMutex.RLock()
	defer fake.setUAAEndpointMutex.RUnlock()
	fake.skipSSLValidationMutex.RLock()
	defer fake.skipSSLValidationMutex.RUnlock()
	fake.uAADisableKeepAlivesMutex.RLock()
	defer fake.uAADisableKeepAlivesMutex.RUnlock()
	fake.uAAGrantTypeMutex.RLock()
	defer fake.uAAGrantTypeMutex.RUnlock()
	fake.uAAOAuthClientMutex.RLock()
	defer fake.uAAOAuthClientMutex.RUnlock()
	fake.uAAOAuthClientSecretMutex.RLock()
	defer fake.uAAOAuthClientSecretMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeConfig) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ uaa.Config = new(FakeConfig)
