// Code generated by counterfeiter. DO NOT EDIT.
package pluginactionfakes

import (
	"sync"

	"code.cloudfoundry.org/cli/actor/pluginaction"
)

type FakeCommandList struct {
	HasAliasStub        func(string) bool
	hasAliasMutex       sync.RWMutex
	hasAliasArgsForCall []struct {
		arg1 string
	}
	hasAliasReturns struct {
		result1 bool
	}
	hasAliasReturnsOnCall map[int]struct {
		result1 bool
	}
	HasCommandStub        func(string) bool
	hasCommandMutex       sync.RWMutex
	hasCommandArgsForCall []struct {
		arg1 string
	}
	hasCommandReturns struct {
		result1 bool
	}
	hasCommandReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCommandList) HasAlias(arg1 string) bool {
	fake.hasAliasMutex.Lock()
	ret, specificReturn := fake.hasAliasReturnsOnCall[len(fake.hasAliasArgsForCall)]
	fake.hasAliasArgsForCall = append(fake.hasAliasArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("HasAlias", []interface{}{arg1})
	fake.hasAliasMutex.Unlock()
	if fake.HasAliasStub != nil {
		return fake.HasAliasStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasAliasReturns
	return fakeReturns.result1
}

func (fake *FakeCommandList) HasAliasCallCount() int {
	fake.hasAliasMutex.RLock()
	defer fake.hasAliasMutex.RUnlock()
	return len(fake.hasAliasArgsForCall)
}

func (fake *FakeCommandList) HasAliasCalls(stub func(string) bool) {
	fake.hasAliasMutex.Lock()
	defer fake.hasAliasMutex.Unlock()
	fake.HasAliasStub = stub
}

func (fake *FakeCommandList) HasAliasArgsForCall(i int) string {
	fake.hasAliasMutex.RLock()
	defer fake.hasAliasMutex.RUnlock()
	argsForCall := fake.hasAliasArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCommandList) HasAliasReturns(result1 bool) {
	fake.hasAliasMutex.Lock()
	defer fake.hasAliasMutex.Unlock()
	fake.HasAliasStub = nil
	fake.hasAliasReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeCommandList) HasAliasReturnsOnCall(i int, result1 bool) {
	fake.hasAliasMutex.Lock()
	defer fake.hasAliasMutex.Unlock()
	fake.HasAliasStub = nil
	if fake.hasAliasReturnsOnCall == nil {
		fake.hasAliasReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasAliasReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeCommandList) HasCommand(arg1 string) bool {
	fake.hasCommandMutex.Lock()
	ret, specificReturn := fake.hasCommandReturnsOnCall[len(fake.hasCommandArgsForCall)]
	fake.hasCommandArgsForCall = append(fake.hasCommandArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("HasCommand", []interface{}{arg1})
	fake.hasCommandMutex.Unlock()
	if fake.HasCommandStub != nil {
		return fake.HasCommandStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasCommandReturns
	return fakeReturns.result1
}

func (fake *FakeCommandList) HasCommandCallCount() int {
	fake.hasCommandMutex.RLock()
	defer fake.hasCommandMutex.RUnlock()
	return len(fake.hasCommandArgsForCall)
}

func (fake *FakeCommandList) HasCommandCalls(stub func(string) bool) {
	fake.hasCommandMutex.Lock()
	defer fake.hasCommandMutex.Unlock()
	fake.HasCommandStub = stub
}

func (fake *FakeCommandList) HasCommandArgsForCall(i int) string {
	fake.hasCommandMutex.RLock()
	defer fake.hasCommandMutex.RUnlock()
	argsForCall := fake.hasCommandArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCommandList) HasCommandReturns(result1 bool) {
	fake.hasCommandMutex.Lock()
	defer fake.hasCommandMutex.Unlock()
	fake.HasCommandStub = nil
	fake.hasCommandReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeCommandList) HasCommandReturnsOnCall(i int, result1 bool) {
	fake.hasCommandMutex.Lock()
	defer fake.hasCommandMutex.Unlock()
	fake.HasCommandStub = nil
	if fake.hasCommandReturnsOnCall == nil {
		fake.hasCommandReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasCommandReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeCommandList) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.hasAliasMutex.RLock()
	defer fake.hasAliasMutex.RUnlock()
	fake.hasCommandMutex.RLock()
	defer fake.hasCommandMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCommandList) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pluginaction.CommandList = new(FakeCommandList)
