// Code generated by counterfeiter. DO NOT EDIT.
package v3actionfakes

import (
	"sync"

	"code.cloudfoundry.org/cli/actor/sharedaction"
	"code.cloudfoundry.org/cli/actor/v3action"
)

type FakeSharedActor struct {
	GatherArchiveResourcesStub        func(archivePath string) ([]sharedaction.Resource, error)
	gatherArchiveResourcesMutex       sync.RWMutex
	gatherArchiveResourcesArgsForCall []struct {
		archivePath string
	}
	gatherArchiveResourcesReturns struct {
		result1 []sharedaction.Resource
		result2 error
	}
	gatherArchiveResourcesReturnsOnCall map[int]struct {
		result1 []sharedaction.Resource
		result2 error
	}
	GatherDirectoryResourcesStub        func(sourceDir string) ([]sharedaction.Resource, error)
	gatherDirectoryResourcesMutex       sync.RWMutex
	gatherDirectoryResourcesArgsForCall []struct {
		sourceDir string
	}
	gatherDirectoryResourcesReturns struct {
		result1 []sharedaction.Resource
		result2 error
	}
	gatherDirectoryResourcesReturnsOnCall map[int]struct {
		result1 []sharedaction.Resource
		result2 error
	}
	ZipArchiveResourcesStub        func(sourceArchivePath string, filesToInclude []sharedaction.Resource) (string, error)
	zipArchiveResourcesMutex       sync.RWMutex
	zipArchiveResourcesArgsForCall []struct {
		sourceArchivePath string
		filesToInclude    []sharedaction.Resource
	}
	zipArchiveResourcesReturns struct {
		result1 string
		result2 error
	}
	zipArchiveResourcesReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ZipDirectoryResourcesStub        func(sourceDir string, filesToInclude []sharedaction.Resource) (string, error)
	zipDirectoryResourcesMutex       sync.RWMutex
	zipDirectoryResourcesArgsForCall []struct {
		sourceDir      string
		filesToInclude []sharedaction.Resource
	}
	zipDirectoryResourcesReturns struct {
		result1 string
		result2 error
	}
	zipDirectoryResourcesReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSharedActor) GatherArchiveResources(archivePath string) ([]sharedaction.Resource, error) {
	fake.gatherArchiveResourcesMutex.Lock()
	ret, specificReturn := fake.gatherArchiveResourcesReturnsOnCall[len(fake.gatherArchiveResourcesArgsForCall)]
	fake.gatherArchiveResourcesArgsForCall = append(fake.gatherArchiveResourcesArgsForCall, struct {
		archivePath string
	}{archivePath})
	fake.recordInvocation("GatherArchiveResources", []interface{}{archivePath})
	fake.gatherArchiveResourcesMutex.Unlock()
	if fake.GatherArchiveResourcesStub != nil {
		return fake.GatherArchiveResourcesStub(archivePath)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.gatherArchiveResourcesReturns.result1, fake.gatherArchiveResourcesReturns.result2
}

func (fake *FakeSharedActor) GatherArchiveResourcesCallCount() int {
	fake.gatherArchiveResourcesMutex.RLock()
	defer fake.gatherArchiveResourcesMutex.RUnlock()
	return len(fake.gatherArchiveResourcesArgsForCall)
}

func (fake *FakeSharedActor) GatherArchiveResourcesArgsForCall(i int) string {
	fake.gatherArchiveResourcesMutex.RLock()
	defer fake.gatherArchiveResourcesMutex.RUnlock()
	return fake.gatherArchiveResourcesArgsForCall[i].archivePath
}

func (fake *FakeSharedActor) GatherArchiveResourcesReturns(result1 []sharedaction.Resource, result2 error) {
	fake.GatherArchiveResourcesStub = nil
	fake.gatherArchiveResourcesReturns = struct {
		result1 []sharedaction.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakeSharedActor) GatherArchiveResourcesReturnsOnCall(i int, result1 []sharedaction.Resource, result2 error) {
	fake.GatherArchiveResourcesStub = nil
	if fake.gatherArchiveResourcesReturnsOnCall == nil {
		fake.gatherArchiveResourcesReturnsOnCall = make(map[int]struct {
			result1 []sharedaction.Resource
			result2 error
		})
	}
	fake.gatherArchiveResourcesReturnsOnCall[i] = struct {
		result1 []sharedaction.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakeSharedActor) GatherDirectoryResources(sourceDir string) ([]sharedaction.Resource, error) {
	fake.gatherDirectoryResourcesMutex.Lock()
	ret, specificReturn := fake.gatherDirectoryResourcesReturnsOnCall[len(fake.gatherDirectoryResourcesArgsForCall)]
	fake.gatherDirectoryResourcesArgsForCall = append(fake.gatherDirectoryResourcesArgsForCall, struct {
		sourceDir string
	}{sourceDir})
	fake.recordInvocation("GatherDirectoryResources", []interface{}{sourceDir})
	fake.gatherDirectoryResourcesMutex.Unlock()
	if fake.GatherDirectoryResourcesStub != nil {
		return fake.GatherDirectoryResourcesStub(sourceDir)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.gatherDirectoryResourcesReturns.result1, fake.gatherDirectoryResourcesReturns.result2
}

func (fake *FakeSharedActor) GatherDirectoryResourcesCallCount() int {
	fake.gatherDirectoryResourcesMutex.RLock()
	defer fake.gatherDirectoryResourcesMutex.RUnlock()
	return len(fake.gatherDirectoryResourcesArgsForCall)
}

func (fake *FakeSharedActor) GatherDirectoryResourcesArgsForCall(i int) string {
	fake.gatherDirectoryResourcesMutex.RLock()
	defer fake.gatherDirectoryResourcesMutex.RUnlock()
	return fake.gatherDirectoryResourcesArgsForCall[i].sourceDir
}

func (fake *FakeSharedActor) GatherDirectoryResourcesReturns(result1 []sharedaction.Resource, result2 error) {
	fake.GatherDirectoryResourcesStub = nil
	fake.gatherDirectoryResourcesReturns = struct {
		result1 []sharedaction.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakeSharedActor) GatherDirectoryResourcesReturnsOnCall(i int, result1 []sharedaction.Resource, result2 error) {
	fake.GatherDirectoryResourcesStub = nil
	if fake.gatherDirectoryResourcesReturnsOnCall == nil {
		fake.gatherDirectoryResourcesReturnsOnCall = make(map[int]struct {
			result1 []sharedaction.Resource
			result2 error
		})
	}
	fake.gatherDirectoryResourcesReturnsOnCall[i] = struct {
		result1 []sharedaction.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakeSharedActor) ZipArchiveResources(sourceArchivePath string, filesToInclude []sharedaction.Resource) (string, error) {
	var filesToIncludeCopy []sharedaction.Resource
	if filesToInclude != nil {
		filesToIncludeCopy = make([]sharedaction.Resource, len(filesToInclude))
		copy(filesToIncludeCopy, filesToInclude)
	}
	fake.zipArchiveResourcesMutex.Lock()
	ret, specificReturn := fake.zipArchiveResourcesReturnsOnCall[len(fake.zipArchiveResourcesArgsForCall)]
	fake.zipArchiveResourcesArgsForCall = append(fake.zipArchiveResourcesArgsForCall, struct {
		sourceArchivePath string
		filesToInclude    []sharedaction.Resource
	}{sourceArchivePath, filesToIncludeCopy})
	fake.recordInvocation("ZipArchiveResources", []interface{}{sourceArchivePath, filesToIncludeCopy})
	fake.zipArchiveResourcesMutex.Unlock()
	if fake.ZipArchiveResourcesStub != nil {
		return fake.ZipArchiveResourcesStub(sourceArchivePath, filesToInclude)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.zipArchiveResourcesReturns.result1, fake.zipArchiveResourcesReturns.result2
}

func (fake *FakeSharedActor) ZipArchiveResourcesCallCount() int {
	fake.zipArchiveResourcesMutex.RLock()
	defer fake.zipArchiveResourcesMutex.RUnlock()
	return len(fake.zipArchiveResourcesArgsForCall)
}

func (fake *FakeSharedActor) ZipArchiveResourcesArgsForCall(i int) (string, []sharedaction.Resource) {
	fake.zipArchiveResourcesMutex.RLock()
	defer fake.zipArchiveResourcesMutex.RUnlock()
	return fake.zipArchiveResourcesArgsForCall[i].sourceArchivePath, fake.zipArchiveResourcesArgsForCall[i].filesToInclude
}

func (fake *FakeSharedActor) ZipArchiveResourcesReturns(result1 string, result2 error) {
	fake.ZipArchiveResourcesStub = nil
	fake.zipArchiveResourcesReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSharedActor) ZipArchiveResourcesReturnsOnCall(i int, result1 string, result2 error) {
	fake.ZipArchiveResourcesStub = nil
	if fake.zipArchiveResourcesReturnsOnCall == nil {
		fake.zipArchiveResourcesReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.zipArchiveResourcesReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSharedActor) ZipDirectoryResources(sourceDir string, filesToInclude []sharedaction.Resource) (string, error) {
	var filesToIncludeCopy []sharedaction.Resource
	if filesToInclude != nil {
		filesToIncludeCopy = make([]sharedaction.Resource, len(filesToInclude))
		copy(filesToIncludeCopy, filesToInclude)
	}
	fake.zipDirectoryResourcesMutex.Lock()
	ret, specificReturn := fake.zipDirectoryResourcesReturnsOnCall[len(fake.zipDirectoryResourcesArgsForCall)]
	fake.zipDirectoryResourcesArgsForCall = append(fake.zipDirectoryResourcesArgsForCall, struct {
		sourceDir      string
		filesToInclude []sharedaction.Resource
	}{sourceDir, filesToIncludeCopy})
	fake.recordInvocation("ZipDirectoryResources", []interface{}{sourceDir, filesToIncludeCopy})
	fake.zipDirectoryResourcesMutex.Unlock()
	if fake.ZipDirectoryResourcesStub != nil {
		return fake.ZipDirectoryResourcesStub(sourceDir, filesToInclude)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.zipDirectoryResourcesReturns.result1, fake.zipDirectoryResourcesReturns.result2
}

func (fake *FakeSharedActor) ZipDirectoryResourcesCallCount() int {
	fake.zipDirectoryResourcesMutex.RLock()
	defer fake.zipDirectoryResourcesMutex.RUnlock()
	return len(fake.zipDirectoryResourcesArgsForCall)
}

func (fake *FakeSharedActor) ZipDirectoryResourcesArgsForCall(i int) (string, []sharedaction.Resource) {
	fake.zipDirectoryResourcesMutex.RLock()
	defer fake.zipDirectoryResourcesMutex.RUnlock()
	return fake.zipDirectoryResourcesArgsForCall[i].sourceDir, fake.zipDirectoryResourcesArgsForCall[i].filesToInclude
}

func (fake *FakeSharedActor) ZipDirectoryResourcesReturns(result1 string, result2 error) {
	fake.ZipDirectoryResourcesStub = nil
	fake.zipDirectoryResourcesReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSharedActor) ZipDirectoryResourcesReturnsOnCall(i int, result1 string, result2 error) {
	fake.ZipDirectoryResourcesStub = nil
	if fake.zipDirectoryResourcesReturnsOnCall == nil {
		fake.zipDirectoryResourcesReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.zipDirectoryResourcesReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSharedActor) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.gatherArchiveResourcesMutex.RLock()
	defer fake.gatherArchiveResourcesMutex.RUnlock()
	fake.gatherDirectoryResourcesMutex.RLock()
	defer fake.gatherDirectoryResourcesMutex.RUnlock()
	fake.zipArchiveResourcesMutex.RLock()
	defer fake.zipArchiveResourcesMutex.RUnlock()
	fake.zipDirectoryResourcesMutex.RLock()
	defer fake.zipDirectoryResourcesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSharedActor) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ v3action.SharedActor = new(FakeSharedActor)
