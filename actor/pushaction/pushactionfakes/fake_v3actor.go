// Code generated by counterfeiter. DO NOT EDIT.
package pushactionfakes

import (
	io "io"
	sync "sync"

	pushaction "code.cloudfoundry.org/cli/actor/pushaction"
	sharedaction "code.cloudfoundry.org/cli/actor/sharedaction"
	v3action "code.cloudfoundry.org/cli/actor/v3action"
)

type FakeV3Actor struct {
	CloudControllerAPIVersionStub        func() string
	cloudControllerAPIVersionMutex       sync.RWMutex
	cloudControllerAPIVersionArgsForCall []struct {
	}
	cloudControllerAPIVersionReturns struct {
		result1 string
	}
	cloudControllerAPIVersionReturnsOnCall map[int]struct {
		result1 string
	}
	CreateApplicationInSpaceStub        func(v3action.Application, string) (v3action.Application, v3action.Warnings, error)
	createApplicationInSpaceMutex       sync.RWMutex
	createApplicationInSpaceArgsForCall []struct {
		arg1 v3action.Application
		arg2 string
	}
	createApplicationInSpaceReturns struct {
		result1 v3action.Application
		result2 v3action.Warnings
		result3 error
	}
	createApplicationInSpaceReturnsOnCall map[int]struct {
		result1 v3action.Application
		result2 v3action.Warnings
		result3 error
	}
	CreateBitsPackageByApplicationStub        func(string) (v3action.Package, v3action.Warnings, error)
	createBitsPackageByApplicationMutex       sync.RWMutex
	createBitsPackageByApplicationArgsForCall []struct {
		arg1 string
	}
	createBitsPackageByApplicationReturns struct {
		result1 v3action.Package
		result2 v3action.Warnings
		result3 error
	}
	createBitsPackageByApplicationReturnsOnCall map[int]struct {
		result1 v3action.Package
		result2 v3action.Warnings
		result3 error
	}
	GetApplicationByNameAndSpaceStub        func(string, string) (v3action.Application, v3action.Warnings, error)
	getApplicationByNameAndSpaceMutex       sync.RWMutex
	getApplicationByNameAndSpaceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getApplicationByNameAndSpaceReturns struct {
		result1 v3action.Application
		result2 v3action.Warnings
		result3 error
	}
	getApplicationByNameAndSpaceReturnsOnCall map[int]struct {
		result1 v3action.Application
		result2 v3action.Warnings
		result3 error
	}
	PollBuildStub        func(string, string) (v3action.Droplet, v3action.Warnings, error)
	pollBuildMutex       sync.RWMutex
	pollBuildArgsForCall []struct {
		arg1 string
		arg2 string
	}
	pollBuildReturns struct {
		result1 v3action.Droplet
		result2 v3action.Warnings
		result3 error
	}
	pollBuildReturnsOnCall map[int]struct {
		result1 v3action.Droplet
		result2 v3action.Warnings
		result3 error
	}
	PollPackageStub        func(v3action.Package) (v3action.Package, v3action.Warnings, error)
	pollPackageMutex       sync.RWMutex
	pollPackageArgsForCall []struct {
		arg1 v3action.Package
	}
	pollPackageReturns struct {
		result1 v3action.Package
		result2 v3action.Warnings
		result3 error
	}
	pollPackageReturnsOnCall map[int]struct {
		result1 v3action.Package
		result2 v3action.Warnings
		result3 error
	}
	SetApplicationDropletStub        func(string, string) (v3action.Warnings, error)
	setApplicationDropletMutex       sync.RWMutex
	setApplicationDropletArgsForCall []struct {
		arg1 string
		arg2 string
	}
	setApplicationDropletReturns struct {
		result1 v3action.Warnings
		result2 error
	}
	setApplicationDropletReturnsOnCall map[int]struct {
		result1 v3action.Warnings
		result2 error
	}
	StageApplicationPackageStub        func(string) (v3action.Build, v3action.Warnings, error)
	stageApplicationPackageMutex       sync.RWMutex
	stageApplicationPackageArgsForCall []struct {
		arg1 string
	}
	stageApplicationPackageReturns struct {
		result1 v3action.Build
		result2 v3action.Warnings
		result3 error
	}
	stageApplicationPackageReturnsOnCall map[int]struct {
		result1 v3action.Build
		result2 v3action.Warnings
		result3 error
	}
	UpdateApplicationStub        func(v3action.Application) (v3action.Application, v3action.Warnings, error)
	updateApplicationMutex       sync.RWMutex
	updateApplicationArgsForCall []struct {
		arg1 v3action.Application
	}
	updateApplicationReturns struct {
		result1 v3action.Application
		result2 v3action.Warnings
		result3 error
	}
	updateApplicationReturnsOnCall map[int]struct {
		result1 v3action.Application
		result2 v3action.Warnings
		result3 error
	}
	UploadBitsPackageStub        func(v3action.Package, []sharedaction.Resource, io.Reader, int64) (v3action.Package, v3action.Warnings, error)
	uploadBitsPackageMutex       sync.RWMutex
	uploadBitsPackageArgsForCall []struct {
		arg1 v3action.Package
		arg2 []sharedaction.Resource
		arg3 io.Reader
		arg4 int64
	}
	uploadBitsPackageReturns struct {
		result1 v3action.Package
		result2 v3action.Warnings
		result3 error
	}
	uploadBitsPackageReturnsOnCall map[int]struct {
		result1 v3action.Package
		result2 v3action.Warnings
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeV3Actor) CloudControllerAPIVersion() string {
	fake.cloudControllerAPIVersionMutex.Lock()
	ret, specificReturn := fake.cloudControllerAPIVersionReturnsOnCall[len(fake.cloudControllerAPIVersionArgsForCall)]
	fake.cloudControllerAPIVersionArgsForCall = append(fake.cloudControllerAPIVersionArgsForCall, struct {
	}{})
	fake.recordInvocation("CloudControllerAPIVersion", []interface{}{})
	fake.cloudControllerAPIVersionMutex.Unlock()
	if fake.CloudControllerAPIVersionStub != nil {
		return fake.CloudControllerAPIVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cloudControllerAPIVersionReturns
	return fakeReturns.result1
}

func (fake *FakeV3Actor) CloudControllerAPIVersionCallCount() int {
	fake.cloudControllerAPIVersionMutex.RLock()
	defer fake.cloudControllerAPIVersionMutex.RUnlock()
	return len(fake.cloudControllerAPIVersionArgsForCall)
}

func (fake *FakeV3Actor) CloudControllerAPIVersionCalls(stub func() string) {
	fake.cloudControllerAPIVersionMutex.Lock()
	defer fake.cloudControllerAPIVersionMutex.Unlock()
	fake.CloudControllerAPIVersionStub = stub
}

func (fake *FakeV3Actor) CloudControllerAPIVersionReturns(result1 string) {
	fake.cloudControllerAPIVersionMutex.Lock()
	defer fake.cloudControllerAPIVersionMutex.Unlock()
	fake.CloudControllerAPIVersionStub = nil
	fake.cloudControllerAPIVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeV3Actor) CloudControllerAPIVersionReturnsOnCall(i int, result1 string) {
	fake.cloudControllerAPIVersionMutex.Lock()
	defer fake.cloudControllerAPIVersionMutex.Unlock()
	fake.CloudControllerAPIVersionStub = nil
	if fake.cloudControllerAPIVersionReturnsOnCall == nil {
		fake.cloudControllerAPIVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cloudControllerAPIVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeV3Actor) CreateApplicationInSpace(arg1 v3action.Application, arg2 string) (v3action.Application, v3action.Warnings, error) {
	fake.createApplicationInSpaceMutex.Lock()
	ret, specificReturn := fake.createApplicationInSpaceReturnsOnCall[len(fake.createApplicationInSpaceArgsForCall)]
	fake.createApplicationInSpaceArgsForCall = append(fake.createApplicationInSpaceArgsForCall, struct {
		arg1 v3action.Application
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("CreateApplicationInSpace", []interface{}{arg1, arg2})
	fake.createApplicationInSpaceMutex.Unlock()
	if fake.CreateApplicationInSpaceStub != nil {
		return fake.CreateApplicationInSpaceStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.createApplicationInSpaceReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeV3Actor) CreateApplicationInSpaceCallCount() int {
	fake.createApplicationInSpaceMutex.RLock()
	defer fake.createApplicationInSpaceMutex.RUnlock()
	return len(fake.createApplicationInSpaceArgsForCall)
}

func (fake *FakeV3Actor) CreateApplicationInSpaceCalls(stub func(v3action.Application, string) (v3action.Application, v3action.Warnings, error)) {
	fake.createApplicationInSpaceMutex.Lock()
	defer fake.createApplicationInSpaceMutex.Unlock()
	fake.CreateApplicationInSpaceStub = stub
}

func (fake *FakeV3Actor) CreateApplicationInSpaceArgsForCall(i int) (v3action.Application, string) {
	fake.createApplicationInSpaceMutex.RLock()
	defer fake.createApplicationInSpaceMutex.RUnlock()
	argsForCall := fake.createApplicationInSpaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3Actor) CreateApplicationInSpaceReturns(result1 v3action.Application, result2 v3action.Warnings, result3 error) {
	fake.createApplicationInSpaceMutex.Lock()
	defer fake.createApplicationInSpaceMutex.Unlock()
	fake.CreateApplicationInSpaceStub = nil
	fake.createApplicationInSpaceReturns = struct {
		result1 v3action.Application
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) CreateApplicationInSpaceReturnsOnCall(i int, result1 v3action.Application, result2 v3action.Warnings, result3 error) {
	fake.createApplicationInSpaceMutex.Lock()
	defer fake.createApplicationInSpaceMutex.Unlock()
	fake.CreateApplicationInSpaceStub = nil
	if fake.createApplicationInSpaceReturnsOnCall == nil {
		fake.createApplicationInSpaceReturnsOnCall = make(map[int]struct {
			result1 v3action.Application
			result2 v3action.Warnings
			result3 error
		})
	}
	fake.createApplicationInSpaceReturnsOnCall[i] = struct {
		result1 v3action.Application
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) CreateBitsPackageByApplication(arg1 string) (v3action.Package, v3action.Warnings, error) {
	fake.createBitsPackageByApplicationMutex.Lock()
	ret, specificReturn := fake.createBitsPackageByApplicationReturnsOnCall[len(fake.createBitsPackageByApplicationArgsForCall)]
	fake.createBitsPackageByApplicationArgsForCall = append(fake.createBitsPackageByApplicationArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CreateBitsPackageByApplication", []interface{}{arg1})
	fake.createBitsPackageByApplicationMutex.Unlock()
	if fake.CreateBitsPackageByApplicationStub != nil {
		return fake.CreateBitsPackageByApplicationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.createBitsPackageByApplicationReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeV3Actor) CreateBitsPackageByApplicationCallCount() int {
	fake.createBitsPackageByApplicationMutex.RLock()
	defer fake.createBitsPackageByApplicationMutex.RUnlock()
	return len(fake.createBitsPackageByApplicationArgsForCall)
}

func (fake *FakeV3Actor) CreateBitsPackageByApplicationCalls(stub func(string) (v3action.Package, v3action.Warnings, error)) {
	fake.createBitsPackageByApplicationMutex.Lock()
	defer fake.createBitsPackageByApplicationMutex.Unlock()
	fake.CreateBitsPackageByApplicationStub = stub
}

func (fake *FakeV3Actor) CreateBitsPackageByApplicationArgsForCall(i int) string {
	fake.createBitsPackageByApplicationMutex.RLock()
	defer fake.createBitsPackageByApplicationMutex.RUnlock()
	argsForCall := fake.createBitsPackageByApplicationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3Actor) CreateBitsPackageByApplicationReturns(result1 v3action.Package, result2 v3action.Warnings, result3 error) {
	fake.createBitsPackageByApplicationMutex.Lock()
	defer fake.createBitsPackageByApplicationMutex.Unlock()
	fake.CreateBitsPackageByApplicationStub = nil
	fake.createBitsPackageByApplicationReturns = struct {
		result1 v3action.Package
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) CreateBitsPackageByApplicationReturnsOnCall(i int, result1 v3action.Package, result2 v3action.Warnings, result3 error) {
	fake.createBitsPackageByApplicationMutex.Lock()
	defer fake.createBitsPackageByApplicationMutex.Unlock()
	fake.CreateBitsPackageByApplicationStub = nil
	if fake.createBitsPackageByApplicationReturnsOnCall == nil {
		fake.createBitsPackageByApplicationReturnsOnCall = make(map[int]struct {
			result1 v3action.Package
			result2 v3action.Warnings
			result3 error
		})
	}
	fake.createBitsPackageByApplicationReturnsOnCall[i] = struct {
		result1 v3action.Package
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) GetApplicationByNameAndSpace(arg1 string, arg2 string) (v3action.Application, v3action.Warnings, error) {
	fake.getApplicationByNameAndSpaceMutex.Lock()
	ret, specificReturn := fake.getApplicationByNameAndSpaceReturnsOnCall[len(fake.getApplicationByNameAndSpaceArgsForCall)]
	fake.getApplicationByNameAndSpaceArgsForCall = append(fake.getApplicationByNameAndSpaceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetApplicationByNameAndSpace", []interface{}{arg1, arg2})
	fake.getApplicationByNameAndSpaceMutex.Unlock()
	if fake.GetApplicationByNameAndSpaceStub != nil {
		return fake.GetApplicationByNameAndSpaceStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.getApplicationByNameAndSpaceReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeV3Actor) GetApplicationByNameAndSpaceCallCount() int {
	fake.getApplicationByNameAndSpaceMutex.RLock()
	defer fake.getApplicationByNameAndSpaceMutex.RUnlock()
	return len(fake.getApplicationByNameAndSpaceArgsForCall)
}

func (fake *FakeV3Actor) GetApplicationByNameAndSpaceCalls(stub func(string, string) (v3action.Application, v3action.Warnings, error)) {
	fake.getApplicationByNameAndSpaceMutex.Lock()
	defer fake.getApplicationByNameAndSpaceMutex.Unlock()
	fake.GetApplicationByNameAndSpaceStub = stub
}

func (fake *FakeV3Actor) GetApplicationByNameAndSpaceArgsForCall(i int) (string, string) {
	fake.getApplicationByNameAndSpaceMutex.RLock()
	defer fake.getApplicationByNameAndSpaceMutex.RUnlock()
	argsForCall := fake.getApplicationByNameAndSpaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3Actor) GetApplicationByNameAndSpaceReturns(result1 v3action.Application, result2 v3action.Warnings, result3 error) {
	fake.getApplicationByNameAndSpaceMutex.Lock()
	defer fake.getApplicationByNameAndSpaceMutex.Unlock()
	fake.GetApplicationByNameAndSpaceStub = nil
	fake.getApplicationByNameAndSpaceReturns = struct {
		result1 v3action.Application
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) GetApplicationByNameAndSpaceReturnsOnCall(i int, result1 v3action.Application, result2 v3action.Warnings, result3 error) {
	fake.getApplicationByNameAndSpaceMutex.Lock()
	defer fake.getApplicationByNameAndSpaceMutex.Unlock()
	fake.GetApplicationByNameAndSpaceStub = nil
	if fake.getApplicationByNameAndSpaceReturnsOnCall == nil {
		fake.getApplicationByNameAndSpaceReturnsOnCall = make(map[int]struct {
			result1 v3action.Application
			result2 v3action.Warnings
			result3 error
		})
	}
	fake.getApplicationByNameAndSpaceReturnsOnCall[i] = struct {
		result1 v3action.Application
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) PollBuild(arg1 string, arg2 string) (v3action.Droplet, v3action.Warnings, error) {
	fake.pollBuildMutex.Lock()
	ret, specificReturn := fake.pollBuildReturnsOnCall[len(fake.pollBuildArgsForCall)]
	fake.pollBuildArgsForCall = append(fake.pollBuildArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("PollBuild", []interface{}{arg1, arg2})
	fake.pollBuildMutex.Unlock()
	if fake.PollBuildStub != nil {
		return fake.PollBuildStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.pollBuildReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeV3Actor) PollBuildCallCount() int {
	fake.pollBuildMutex.RLock()
	defer fake.pollBuildMutex.RUnlock()
	return len(fake.pollBuildArgsForCall)
}

func (fake *FakeV3Actor) PollBuildCalls(stub func(string, string) (v3action.Droplet, v3action.Warnings, error)) {
	fake.pollBuildMutex.Lock()
	defer fake.pollBuildMutex.Unlock()
	fake.PollBuildStub = stub
}

func (fake *FakeV3Actor) PollBuildArgsForCall(i int) (string, string) {
	fake.pollBuildMutex.RLock()
	defer fake.pollBuildMutex.RUnlock()
	argsForCall := fake.pollBuildArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3Actor) PollBuildReturns(result1 v3action.Droplet, result2 v3action.Warnings, result3 error) {
	fake.pollBuildMutex.Lock()
	defer fake.pollBuildMutex.Unlock()
	fake.PollBuildStub = nil
	fake.pollBuildReturns = struct {
		result1 v3action.Droplet
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) PollBuildReturnsOnCall(i int, result1 v3action.Droplet, result2 v3action.Warnings, result3 error) {
	fake.pollBuildMutex.Lock()
	defer fake.pollBuildMutex.Unlock()
	fake.PollBuildStub = nil
	if fake.pollBuildReturnsOnCall == nil {
		fake.pollBuildReturnsOnCall = make(map[int]struct {
			result1 v3action.Droplet
			result2 v3action.Warnings
			result3 error
		})
	}
	fake.pollBuildReturnsOnCall[i] = struct {
		result1 v3action.Droplet
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) PollPackage(arg1 v3action.Package) (v3action.Package, v3action.Warnings, error) {
	fake.pollPackageMutex.Lock()
	ret, specificReturn := fake.pollPackageReturnsOnCall[len(fake.pollPackageArgsForCall)]
	fake.pollPackageArgsForCall = append(fake.pollPackageArgsForCall, struct {
		arg1 v3action.Package
	}{arg1})
	fake.recordInvocation("PollPackage", []interface{}{arg1})
	fake.pollPackageMutex.Unlock()
	if fake.PollPackageStub != nil {
		return fake.PollPackageStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.pollPackageReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeV3Actor) PollPackageCallCount() int {
	fake.pollPackageMutex.RLock()
	defer fake.pollPackageMutex.RUnlock()
	return len(fake.pollPackageArgsForCall)
}

func (fake *FakeV3Actor) PollPackageCalls(stub func(v3action.Package) (v3action.Package, v3action.Warnings, error)) {
	fake.pollPackageMutex.Lock()
	defer fake.pollPackageMutex.Unlock()
	fake.PollPackageStub = stub
}

func (fake *FakeV3Actor) PollPackageArgsForCall(i int) v3action.Package {
	fake.pollPackageMutex.RLock()
	defer fake.pollPackageMutex.RUnlock()
	argsForCall := fake.pollPackageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3Actor) PollPackageReturns(result1 v3action.Package, result2 v3action.Warnings, result3 error) {
	fake.pollPackageMutex.Lock()
	defer fake.pollPackageMutex.Unlock()
	fake.PollPackageStub = nil
	fake.pollPackageReturns = struct {
		result1 v3action.Package
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) PollPackageReturnsOnCall(i int, result1 v3action.Package, result2 v3action.Warnings, result3 error) {
	fake.pollPackageMutex.Lock()
	defer fake.pollPackageMutex.Unlock()
	fake.PollPackageStub = nil
	if fake.pollPackageReturnsOnCall == nil {
		fake.pollPackageReturnsOnCall = make(map[int]struct {
			result1 v3action.Package
			result2 v3action.Warnings
			result3 error
		})
	}
	fake.pollPackageReturnsOnCall[i] = struct {
		result1 v3action.Package
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) SetApplicationDroplet(arg1 string, arg2 string) (v3action.Warnings, error) {
	fake.setApplicationDropletMutex.Lock()
	ret, specificReturn := fake.setApplicationDropletReturnsOnCall[len(fake.setApplicationDropletArgsForCall)]
	fake.setApplicationDropletArgsForCall = append(fake.setApplicationDropletArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SetApplicationDroplet", []interface{}{arg1, arg2})
	fake.setApplicationDropletMutex.Unlock()
	if fake.SetApplicationDropletStub != nil {
		return fake.SetApplicationDropletStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.setApplicationDropletReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeV3Actor) SetApplicationDropletCallCount() int {
	fake.setApplicationDropletMutex.RLock()
	defer fake.setApplicationDropletMutex.RUnlock()
	return len(fake.setApplicationDropletArgsForCall)
}

func (fake *FakeV3Actor) SetApplicationDropletCalls(stub func(string, string) (v3action.Warnings, error)) {
	fake.setApplicationDropletMutex.Lock()
	defer fake.setApplicationDropletMutex.Unlock()
	fake.SetApplicationDropletStub = stub
}

func (fake *FakeV3Actor) SetApplicationDropletArgsForCall(i int) (string, string) {
	fake.setApplicationDropletMutex.RLock()
	defer fake.setApplicationDropletMutex.RUnlock()
	argsForCall := fake.setApplicationDropletArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3Actor) SetApplicationDropletReturns(result1 v3action.Warnings, result2 error) {
	fake.setApplicationDropletMutex.Lock()
	defer fake.setApplicationDropletMutex.Unlock()
	fake.SetApplicationDropletStub = nil
	fake.setApplicationDropletReturns = struct {
		result1 v3action.Warnings
		result2 error
	}{result1, result2}
}

func (fake *FakeV3Actor) SetApplicationDropletReturnsOnCall(i int, result1 v3action.Warnings, result2 error) {
	fake.setApplicationDropletMutex.Lock()
	defer fake.setApplicationDropletMutex.Unlock()
	fake.SetApplicationDropletStub = nil
	if fake.setApplicationDropletReturnsOnCall == nil {
		fake.setApplicationDropletReturnsOnCall = make(map[int]struct {
			result1 v3action.Warnings
			result2 error
		})
	}
	fake.setApplicationDropletReturnsOnCall[i] = struct {
		result1 v3action.Warnings
		result2 error
	}{result1, result2}
}

func (fake *FakeV3Actor) StageApplicationPackage(arg1 string) (v3action.Build, v3action.Warnings, error) {
	fake.stageApplicationPackageMutex.Lock()
	ret, specificReturn := fake.stageApplicationPackageReturnsOnCall[len(fake.stageApplicationPackageArgsForCall)]
	fake.stageApplicationPackageArgsForCall = append(fake.stageApplicationPackageArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("StageApplicationPackage", []interface{}{arg1})
	fake.stageApplicationPackageMutex.Unlock()
	if fake.StageApplicationPackageStub != nil {
		return fake.StageApplicationPackageStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.stageApplicationPackageReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeV3Actor) StageApplicationPackageCallCount() int {
	fake.stageApplicationPackageMutex.RLock()
	defer fake.stageApplicationPackageMutex.RUnlock()
	return len(fake.stageApplicationPackageArgsForCall)
}

func (fake *FakeV3Actor) StageApplicationPackageCalls(stub func(string) (v3action.Build, v3action.Warnings, error)) {
	fake.stageApplicationPackageMutex.Lock()
	defer fake.stageApplicationPackageMutex.Unlock()
	fake.StageApplicationPackageStub = stub
}

func (fake *FakeV3Actor) StageApplicationPackageArgsForCall(i int) string {
	fake.stageApplicationPackageMutex.RLock()
	defer fake.stageApplicationPackageMutex.RUnlock()
	argsForCall := fake.stageApplicationPackageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3Actor) StageApplicationPackageReturns(result1 v3action.Build, result2 v3action.Warnings, result3 error) {
	fake.stageApplicationPackageMutex.Lock()
	defer fake.stageApplicationPackageMutex.Unlock()
	fake.StageApplicationPackageStub = nil
	fake.stageApplicationPackageReturns = struct {
		result1 v3action.Build
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) StageApplicationPackageReturnsOnCall(i int, result1 v3action.Build, result2 v3action.Warnings, result3 error) {
	fake.stageApplicationPackageMutex.Lock()
	defer fake.stageApplicationPackageMutex.Unlock()
	fake.StageApplicationPackageStub = nil
	if fake.stageApplicationPackageReturnsOnCall == nil {
		fake.stageApplicationPackageReturnsOnCall = make(map[int]struct {
			result1 v3action.Build
			result2 v3action.Warnings
			result3 error
		})
	}
	fake.stageApplicationPackageReturnsOnCall[i] = struct {
		result1 v3action.Build
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) UpdateApplication(arg1 v3action.Application) (v3action.Application, v3action.Warnings, error) {
	fake.updateApplicationMutex.Lock()
	ret, specificReturn := fake.updateApplicationReturnsOnCall[len(fake.updateApplicationArgsForCall)]
	fake.updateApplicationArgsForCall = append(fake.updateApplicationArgsForCall, struct {
		arg1 v3action.Application
	}{arg1})
	fake.recordInvocation("UpdateApplication", []interface{}{arg1})
	fake.updateApplicationMutex.Unlock()
	if fake.UpdateApplicationStub != nil {
		return fake.UpdateApplicationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.updateApplicationReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeV3Actor) UpdateApplicationCallCount() int {
	fake.updateApplicationMutex.RLock()
	defer fake.updateApplicationMutex.RUnlock()
	return len(fake.updateApplicationArgsForCall)
}

func (fake *FakeV3Actor) UpdateApplicationCalls(stub func(v3action.Application) (v3action.Application, v3action.Warnings, error)) {
	fake.updateApplicationMutex.Lock()
	defer fake.updateApplicationMutex.Unlock()
	fake.UpdateApplicationStub = stub
}

func (fake *FakeV3Actor) UpdateApplicationArgsForCall(i int) v3action.Application {
	fake.updateApplicationMutex.RLock()
	defer fake.updateApplicationMutex.RUnlock()
	argsForCall := fake.updateApplicationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3Actor) UpdateApplicationReturns(result1 v3action.Application, result2 v3action.Warnings, result3 error) {
	fake.updateApplicationMutex.Lock()
	defer fake.updateApplicationMutex.Unlock()
	fake.UpdateApplicationStub = nil
	fake.updateApplicationReturns = struct {
		result1 v3action.Application
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) UpdateApplicationReturnsOnCall(i int, result1 v3action.Application, result2 v3action.Warnings, result3 error) {
	fake.updateApplicationMutex.Lock()
	defer fake.updateApplicationMutex.Unlock()
	fake.UpdateApplicationStub = nil
	if fake.updateApplicationReturnsOnCall == nil {
		fake.updateApplicationReturnsOnCall = make(map[int]struct {
			result1 v3action.Application
			result2 v3action.Warnings
			result3 error
		})
	}
	fake.updateApplicationReturnsOnCall[i] = struct {
		result1 v3action.Application
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) UploadBitsPackage(arg1 v3action.Package, arg2 []sharedaction.Resource, arg3 io.Reader, arg4 int64) (v3action.Package, v3action.Warnings, error) {
	var arg2Copy []sharedaction.Resource
	if arg2 != nil {
		arg2Copy = make([]sharedaction.Resource, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.uploadBitsPackageMutex.Lock()
	ret, specificReturn := fake.uploadBitsPackageReturnsOnCall[len(fake.uploadBitsPackageArgsForCall)]
	fake.uploadBitsPackageArgsForCall = append(fake.uploadBitsPackageArgsForCall, struct {
		arg1 v3action.Package
		arg2 []sharedaction.Resource
		arg3 io.Reader
		arg4 int64
	}{arg1, arg2Copy, arg3, arg4})
	fake.recordInvocation("UploadBitsPackage", []interface{}{arg1, arg2Copy, arg3, arg4})
	fake.uploadBitsPackageMutex.Unlock()
	if fake.UploadBitsPackageStub != nil {
		return fake.UploadBitsPackageStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.uploadBitsPackageReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeV3Actor) UploadBitsPackageCallCount() int {
	fake.uploadBitsPackageMutex.RLock()
	defer fake.uploadBitsPackageMutex.RUnlock()
	return len(fake.uploadBitsPackageArgsForCall)
}

func (fake *FakeV3Actor) UploadBitsPackageCalls(stub func(v3action.Package, []sharedaction.Resource, io.Reader, int64) (v3action.Package, v3action.Warnings, error)) {
	fake.uploadBitsPackageMutex.Lock()
	defer fake.uploadBitsPackageMutex.Unlock()
	fake.UploadBitsPackageStub = stub
}

func (fake *FakeV3Actor) UploadBitsPackageArgsForCall(i int) (v3action.Package, []sharedaction.Resource, io.Reader, int64) {
	fake.uploadBitsPackageMutex.RLock()
	defer fake.uploadBitsPackageMutex.RUnlock()
	argsForCall := fake.uploadBitsPackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeV3Actor) UploadBitsPackageReturns(result1 v3action.Package, result2 v3action.Warnings, result3 error) {
	fake.uploadBitsPackageMutex.Lock()
	defer fake.uploadBitsPackageMutex.Unlock()
	fake.UploadBitsPackageStub = nil
	fake.uploadBitsPackageReturns = struct {
		result1 v3action.Package
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) UploadBitsPackageReturnsOnCall(i int, result1 v3action.Package, result2 v3action.Warnings, result3 error) {
	fake.uploadBitsPackageMutex.Lock()
	defer fake.uploadBitsPackageMutex.Unlock()
	fake.UploadBitsPackageStub = nil
	if fake.uploadBitsPackageReturnsOnCall == nil {
		fake.uploadBitsPackageReturnsOnCall = make(map[int]struct {
			result1 v3action.Package
			result2 v3action.Warnings
			result3 error
		})
	}
	fake.uploadBitsPackageReturnsOnCall[i] = struct {
		result1 v3action.Package
		result2 v3action.Warnings
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeV3Actor) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cloudControllerAPIVersionMutex.RLock()
	defer fake.cloudControllerAPIVersionMutex.RUnlock()
	fake.createApplicationInSpaceMutex.RLock()
	defer fake.createApplicationInSpaceMutex.RUnlock()
	fake.createBitsPackageByApplicationMutex.RLock()
	defer fake.createBitsPackageByApplicationMutex.RUnlock()
	fake.getApplicationByNameAndSpaceMutex.RLock()
	defer fake.getApplicationByNameAndSpaceMutex.RUnlock()
	fake.pollBuildMutex.RLock()
	defer fake.pollBuildMutex.RUnlock()
	fake.pollPackageMutex.RLock()
	defer fake.pollPackageMutex.RUnlock()
	fake.setApplicationDropletMutex.RLock()
	defer fake.setApplicationDropletMutex.RUnlock()
	fake.stageApplicationPackageMutex.RLock()
	defer fake.stageApplicationPackageMutex.RUnlock()
	fake.updateApplicationMutex.RLock()
	defer fake.updateApplicationMutex.RUnlock()
	fake.uploadBitsPackageMutex.RLock()
	defer fake.uploadBitsPackageMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeV3Actor) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pushaction.V3Actor = new(FakeV3Actor)
