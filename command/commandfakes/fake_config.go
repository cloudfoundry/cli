// Code generated by counterfeiter. DO NOT EDIT.
package commandfakes

import (
	sync "sync"
	time "time"

	command "code.cloudfoundry.org/cli/command"
	configv3 "code.cloudfoundry.org/cli/util/configv3"
)

type FakeConfig struct {
	APIVersionStub        func() string
	aPIVersionMutex       sync.RWMutex
	aPIVersionArgsForCall []struct {
	}
	aPIVersionReturns struct {
		result1 string
	}
	aPIVersionReturnsOnCall map[int]struct {
		result1 string
	}
	AccessTokenStub        func() string
	accessTokenMutex       sync.RWMutex
	accessTokenArgsForCall []struct {
	}
	accessTokenReturns struct {
		result1 string
	}
	accessTokenReturnsOnCall map[int]struct {
		result1 string
	}
	AddPluginStub        func(configv3.Plugin)
	addPluginMutex       sync.RWMutex
	addPluginArgsForCall []struct {
		arg1 configv3.Plugin
	}
	AddPluginRepositoryStub        func(string, string)
	addPluginRepositoryMutex       sync.RWMutex
	addPluginRepositoryArgsForCall []struct {
		arg1 string
		arg2 string
	}
	BinaryNameStub        func() string
	binaryNameMutex       sync.RWMutex
	binaryNameArgsForCall []struct {
	}
	binaryNameReturns struct {
		result1 string
	}
	binaryNameReturnsOnCall map[int]struct {
		result1 string
	}
	BinaryVersionStub        func() string
	binaryVersionMutex       sync.RWMutex
	binaryVersionArgsForCall []struct {
	}
	binaryVersionReturns struct {
		result1 string
	}
	binaryVersionReturnsOnCall map[int]struct {
		result1 string
	}
	CFPasswordStub        func() string
	cFPasswordMutex       sync.RWMutex
	cFPasswordArgsForCall []struct {
	}
	cFPasswordReturns struct {
		result1 string
	}
	cFPasswordReturnsOnCall map[int]struct {
		result1 string
	}
	CFUsernameStub        func() string
	cFUsernameMutex       sync.RWMutex
	cFUsernameArgsForCall []struct {
	}
	cFUsernameReturns struct {
		result1 string
	}
	cFUsernameReturnsOnCall map[int]struct {
		result1 string
	}
	ColorEnabledStub        func() configv3.ColorSetting
	colorEnabledMutex       sync.RWMutex
	colorEnabledArgsForCall []struct {
	}
	colorEnabledReturns struct {
		result1 configv3.ColorSetting
	}
	colorEnabledReturnsOnCall map[int]struct {
		result1 configv3.ColorSetting
	}
	CurrentUserStub        func() (configv3.User, error)
	currentUserMutex       sync.RWMutex
	currentUserArgsForCall []struct {
	}
	currentUserReturns struct {
		result1 configv3.User
		result2 error
	}
	currentUserReturnsOnCall map[int]struct {
		result1 configv3.User
		result2 error
	}
	CurrentUserNameStub        func() (string, error)
	currentUserNameMutex       sync.RWMutex
	currentUserNameArgsForCall []struct {
	}
	currentUserNameReturns struct {
		result1 string
		result2 error
	}
	currentUserNameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DialTimeoutStub        func() time.Duration
	dialTimeoutMutex       sync.RWMutex
	dialTimeoutArgsForCall []struct {
	}
	dialTimeoutReturns struct {
		result1 time.Duration
	}
	dialTimeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	DockerPasswordStub        func() string
	dockerPasswordMutex       sync.RWMutex
	dockerPasswordArgsForCall []struct {
	}
	dockerPasswordReturns struct {
		result1 string
	}
	dockerPasswordReturnsOnCall map[int]struct {
		result1 string
	}
	ExperimentalStub        func() bool
	experimentalMutex       sync.RWMutex
	experimentalArgsForCall []struct {
	}
	experimentalReturns struct {
		result1 bool
	}
	experimentalReturnsOnCall map[int]struct {
		result1 bool
	}
	GetPluginStub        func(string) (configv3.Plugin, bool)
	getPluginMutex       sync.RWMutex
	getPluginArgsForCall []struct {
		arg1 string
	}
	getPluginReturns struct {
		result1 configv3.Plugin
		result2 bool
	}
	getPluginReturnsOnCall map[int]struct {
		result1 configv3.Plugin
		result2 bool
	}
	GetPluginCaseInsensitiveStub        func(string) (configv3.Plugin, bool)
	getPluginCaseInsensitiveMutex       sync.RWMutex
	getPluginCaseInsensitiveArgsForCall []struct {
		arg1 string
	}
	getPluginCaseInsensitiveReturns struct {
		result1 configv3.Plugin
		result2 bool
	}
	getPluginCaseInsensitiveReturnsOnCall map[int]struct {
		result1 configv3.Plugin
		result2 bool
	}
	HasTargetedOrganizationStub        func() bool
	hasTargetedOrganizationMutex       sync.RWMutex
	hasTargetedOrganizationArgsForCall []struct {
	}
	hasTargetedOrganizationReturns struct {
		result1 bool
	}
	hasTargetedOrganizationReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedSpaceStub        func() bool
	hasTargetedSpaceMutex       sync.RWMutex
	hasTargetedSpaceArgsForCall []struct {
	}
	hasTargetedSpaceReturns struct {
		result1 bool
	}
	hasTargetedSpaceReturnsOnCall map[int]struct {
		result1 bool
	}
	LocaleStub        func() string
	localeMutex       sync.RWMutex
	localeArgsForCall []struct {
	}
	localeReturns struct {
		result1 string
	}
	localeReturnsOnCall map[int]struct {
		result1 string
	}
	MinCLIVersionStub        func() string
	minCLIVersionMutex       sync.RWMutex
	minCLIVersionArgsForCall []struct {
	}
	minCLIVersionReturns struct {
		result1 string
	}
	minCLIVersionReturnsOnCall map[int]struct {
		result1 string
	}
	NOAARequestRetryCountStub        func() int
	nOAARequestRetryCountMutex       sync.RWMutex
	nOAARequestRetryCountArgsForCall []struct {
	}
	nOAARequestRetryCountReturns struct {
		result1 int
	}
	nOAARequestRetryCountReturnsOnCall map[int]struct {
		result1 int
	}
	OverallPollingTimeoutStub        func() time.Duration
	overallPollingTimeoutMutex       sync.RWMutex
	overallPollingTimeoutArgsForCall []struct {
	}
	overallPollingTimeoutReturns struct {
		result1 time.Duration
	}
	overallPollingTimeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	PluginHomeStub        func() string
	pluginHomeMutex       sync.RWMutex
	pluginHomeArgsForCall []struct {
	}
	pluginHomeReturns struct {
		result1 string
	}
	pluginHomeReturnsOnCall map[int]struct {
		result1 string
	}
	PluginRepositoriesStub        func() []configv3.PluginRepository
	pluginRepositoriesMutex       sync.RWMutex
	pluginRepositoriesArgsForCall []struct {
	}
	pluginRepositoriesReturns struct {
		result1 []configv3.PluginRepository
	}
	pluginRepositoriesReturnsOnCall map[int]struct {
		result1 []configv3.PluginRepository
	}
	PluginsStub        func() []configv3.Plugin
	pluginsMutex       sync.RWMutex
	pluginsArgsForCall []struct {
	}
	pluginsReturns struct {
		result1 []configv3.Plugin
	}
	pluginsReturnsOnCall map[int]struct {
		result1 []configv3.Plugin
	}
	PollingIntervalStub        func() time.Duration
	pollingIntervalMutex       sync.RWMutex
	pollingIntervalArgsForCall []struct {
	}
	pollingIntervalReturns struct {
		result1 time.Duration
	}
	pollingIntervalReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	RefreshTokenStub        func() string
	refreshTokenMutex       sync.RWMutex
	refreshTokenArgsForCall []struct {
	}
	refreshTokenReturns struct {
		result1 string
	}
	refreshTokenReturnsOnCall map[int]struct {
		result1 string
	}
	RemovePluginStub        func(string)
	removePluginMutex       sync.RWMutex
	removePluginArgsForCall []struct {
		arg1 string
	}
	RequestRetryCountStub        func() int
	requestRetryCountMutex       sync.RWMutex
	requestRetryCountArgsForCall []struct {
	}
	requestRetryCountReturns struct {
		result1 int
	}
	requestRetryCountReturnsOnCall map[int]struct {
		result1 int
	}
	RoutingEndpointStub        func() string
	routingEndpointMutex       sync.RWMutex
	routingEndpointArgsForCall []struct {
	}
	routingEndpointReturns struct {
		result1 string
	}
	routingEndpointReturnsOnCall map[int]struct {
		result1 string
	}
	SSHOAuthClientStub        func() string
	sSHOAuthClientMutex       sync.RWMutex
	sSHOAuthClientArgsForCall []struct {
	}
	sSHOAuthClientReturns struct {
		result1 string
	}
	sSHOAuthClientReturnsOnCall map[int]struct {
		result1 string
	}
	SetAccessTokenStub        func(string)
	setAccessTokenMutex       sync.RWMutex
	setAccessTokenArgsForCall []struct {
		arg1 string
	}
	SetOrganizationInformationStub        func(string, string)
	setOrganizationInformationMutex       sync.RWMutex
	setOrganizationInformationArgsForCall []struct {
		arg1 string
		arg2 string
	}
	SetRefreshTokenStub        func(string)
	setRefreshTokenMutex       sync.RWMutex
	setRefreshTokenArgsForCall []struct {
		arg1 string
	}
	SetSpaceInformationStub        func(string, string, bool)
	setSpaceInformationMutex       sync.RWMutex
	setSpaceInformationArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
	}
	SetTargetInformationStub        func(string, string, string, string, string, string, bool)
	setTargetInformationMutex       sync.RWMutex
	setTargetInformationArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 bool
	}
	SetTokenInformationStub        func(string, string, string)
	setTokenInformationMutex       sync.RWMutex
	setTokenInformationArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	SetUAAClientCredentialsStub        func(string, string)
	setUAAClientCredentialsMutex       sync.RWMutex
	setUAAClientCredentialsArgsForCall []struct {
		arg1 string
		arg2 string
	}
	SetUAAEndpointStub        func(string)
	setUAAEndpointMutex       sync.RWMutex
	setUAAEndpointArgsForCall []struct {
		arg1 string
	}
	SetUAAGrantTypeStub        func(string)
	setUAAGrantTypeMutex       sync.RWMutex
	setUAAGrantTypeArgsForCall []struct {
		arg1 string
	}
	SkipSSLValidationStub        func() bool
	skipSSLValidationMutex       sync.RWMutex
	skipSSLValidationArgsForCall []struct {
	}
	skipSSLValidationReturns struct {
		result1 bool
	}
	skipSSLValidationReturnsOnCall map[int]struct {
		result1 bool
	}
	StagingTimeoutStub        func() time.Duration
	stagingTimeoutMutex       sync.RWMutex
	stagingTimeoutArgsForCall []struct {
	}
	stagingTimeoutReturns struct {
		result1 time.Duration
	}
	stagingTimeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	StartupTimeoutStub        func() time.Duration
	startupTimeoutMutex       sync.RWMutex
	startupTimeoutArgsForCall []struct {
	}
	startupTimeoutReturns struct {
		result1 time.Duration
	}
	startupTimeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	TargetStub        func() string
	targetMutex       sync.RWMutex
	targetArgsForCall []struct {
	}
	targetReturns struct {
		result1 string
	}
	targetReturnsOnCall map[int]struct {
		result1 string
	}
	TargetedOrganizationStub        func() configv3.Organization
	targetedOrganizationMutex       sync.RWMutex
	targetedOrganizationArgsForCall []struct {
	}
	targetedOrganizationReturns struct {
		result1 configv3.Organization
	}
	targetedOrganizationReturnsOnCall map[int]struct {
		result1 configv3.Organization
	}
	TargetedOrganizationNameStub        func() string
	targetedOrganizationNameMutex       sync.RWMutex
	targetedOrganizationNameArgsForCall []struct {
	}
	targetedOrganizationNameReturns struct {
		result1 string
	}
	targetedOrganizationNameReturnsOnCall map[int]struct {
		result1 string
	}
	TargetedSpaceStub        func() configv3.Space
	targetedSpaceMutex       sync.RWMutex
	targetedSpaceArgsForCall []struct {
	}
	targetedSpaceReturns struct {
		result1 configv3.Space
	}
	targetedSpaceReturnsOnCall map[int]struct {
		result1 configv3.Space
	}
	UAADisableKeepAlivesStub        func() bool
	uAADisableKeepAlivesMutex       sync.RWMutex
	uAADisableKeepAlivesArgsForCall []struct {
	}
	uAADisableKeepAlivesReturns struct {
		result1 bool
	}
	uAADisableKeepAlivesReturnsOnCall map[int]struct {
		result1 bool
	}
	UAAGrantTypeStub        func() string
	uAAGrantTypeMutex       sync.RWMutex
	uAAGrantTypeArgsForCall []struct {
	}
	uAAGrantTypeReturns struct {
		result1 string
	}
	uAAGrantTypeReturnsOnCall map[int]struct {
		result1 string
	}
	UAAOAuthClientStub        func() string
	uAAOAuthClientMutex       sync.RWMutex
	uAAOAuthClientArgsForCall []struct {
	}
	uAAOAuthClientReturns struct {
		result1 string
	}
	uAAOAuthClientReturnsOnCall map[int]struct {
		result1 string
	}
	UAAOAuthClientSecretStub        func() string
	uAAOAuthClientSecretMutex       sync.RWMutex
	uAAOAuthClientSecretArgsForCall []struct {
	}
	uAAOAuthClientSecretReturns struct {
		result1 string
	}
	uAAOAuthClientSecretReturnsOnCall map[int]struct {
		result1 string
	}
	UnsetOrganizationAndSpaceInformationStub        func()
	unsetOrganizationAndSpaceInformationMutex       sync.RWMutex
	unsetOrganizationAndSpaceInformationArgsForCall []struct {
	}
	UnsetSpaceInformationStub        func()
	unsetSpaceInformationMutex       sync.RWMutex
	unsetSpaceInformationArgsForCall []struct {
	}
	UnsetUserInformationStub        func()
	unsetUserInformationMutex       sync.RWMutex
	unsetUserInformationArgsForCall []struct {
	}
	VerboseStub        func() (bool, []string)
	verboseMutex       sync.RWMutex
	verboseArgsForCall []struct {
	}
	verboseReturns struct {
		result1 bool
		result2 []string
	}
	verboseReturnsOnCall map[int]struct {
		result1 bool
		result2 []string
	}
	WritePluginConfigStub        func() error
	writePluginConfigMutex       sync.RWMutex
	writePluginConfigArgsForCall []struct {
	}
	writePluginConfigReturns struct {
		result1 error
	}
	writePluginConfigReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConfig) APIVersion() string {
	fake.aPIVersionMutex.Lock()
	ret, specificReturn := fake.aPIVersionReturnsOnCall[len(fake.aPIVersionArgsForCall)]
	fake.aPIVersionArgsForCall = append(fake.aPIVersionArgsForCall, struct {
	}{})
	fake.recordInvocation("APIVersion", []interface{}{})
	fake.aPIVersionMutex.Unlock()
	if fake.APIVersionStub != nil {
		return fake.APIVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.aPIVersionReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) APIVersionCallCount() int {
	fake.aPIVersionMutex.RLock()
	defer fake.aPIVersionMutex.RUnlock()
	return len(fake.aPIVersionArgsForCall)
}

func (fake *FakeConfig) APIVersionCalls(stub func() string) {
	fake.aPIVersionMutex.Lock()
	defer fake.aPIVersionMutex.Unlock()
	fake.APIVersionStub = stub
}

func (fake *FakeConfig) APIVersionReturns(result1 string) {
	fake.aPIVersionMutex.Lock()
	defer fake.aPIVersionMutex.Unlock()
	fake.APIVersionStub = nil
	fake.aPIVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) APIVersionReturnsOnCall(i int, result1 string) {
	fake.aPIVersionMutex.Lock()
	defer fake.aPIVersionMutex.Unlock()
	fake.APIVersionStub = nil
	if fake.aPIVersionReturnsOnCall == nil {
		fake.aPIVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.aPIVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) AccessToken() string {
	fake.accessTokenMutex.Lock()
	ret, specificReturn := fake.accessTokenReturnsOnCall[len(fake.accessTokenArgsForCall)]
	fake.accessTokenArgsForCall = append(fake.accessTokenArgsForCall, struct {
	}{})
	fake.recordInvocation("AccessToken", []interface{}{})
	fake.accessTokenMutex.Unlock()
	if fake.AccessTokenStub != nil {
		return fake.AccessTokenStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.accessTokenReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) AccessTokenCallCount() int {
	fake.accessTokenMutex.RLock()
	defer fake.accessTokenMutex.RUnlock()
	return len(fake.accessTokenArgsForCall)
}

func (fake *FakeConfig) AccessTokenCalls(stub func() string) {
	fake.accessTokenMutex.Lock()
	defer fake.accessTokenMutex.Unlock()
	fake.AccessTokenStub = stub
}

func (fake *FakeConfig) AccessTokenReturns(result1 string) {
	fake.accessTokenMutex.Lock()
	defer fake.accessTokenMutex.Unlock()
	fake.AccessTokenStub = nil
	fake.accessTokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) AccessTokenReturnsOnCall(i int, result1 string) {
	fake.accessTokenMutex.Lock()
	defer fake.accessTokenMutex.Unlock()
	fake.AccessTokenStub = nil
	if fake.accessTokenReturnsOnCall == nil {
		fake.accessTokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.accessTokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) AddPlugin(arg1 configv3.Plugin) {
	fake.addPluginMutex.Lock()
	fake.addPluginArgsForCall = append(fake.addPluginArgsForCall, struct {
		arg1 configv3.Plugin
	}{arg1})
	fake.recordInvocation("AddPlugin", []interface{}{arg1})
	fake.addPluginMutex.Unlock()
	if fake.AddPluginStub != nil {
		fake.AddPluginStub(arg1)
	}
}

func (fake *FakeConfig) AddPluginCallCount() int {
	fake.addPluginMutex.RLock()
	defer fake.addPluginMutex.RUnlock()
	return len(fake.addPluginArgsForCall)
}

func (fake *FakeConfig) AddPluginCalls(stub func(configv3.Plugin)) {
	fake.addPluginMutex.Lock()
	defer fake.addPluginMutex.Unlock()
	fake.AddPluginStub = stub
}

func (fake *FakeConfig) AddPluginArgsForCall(i int) configv3.Plugin {
	fake.addPluginMutex.RLock()
	defer fake.addPluginMutex.RUnlock()
	argsForCall := fake.addPluginArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConfig) AddPluginRepository(arg1 string, arg2 string) {
	fake.addPluginRepositoryMutex.Lock()
	fake.addPluginRepositoryArgsForCall = append(fake.addPluginRepositoryArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("AddPluginRepository", []interface{}{arg1, arg2})
	fake.addPluginRepositoryMutex.Unlock()
	if fake.AddPluginRepositoryStub != nil {
		fake.AddPluginRepositoryStub(arg1, arg2)
	}
}

func (fake *FakeConfig) AddPluginRepositoryCallCount() int {
	fake.addPluginRepositoryMutex.RLock()
	defer fake.addPluginRepositoryMutex.RUnlock()
	return len(fake.addPluginRepositoryArgsForCall)
}

func (fake *FakeConfig) AddPluginRepositoryCalls(stub func(string, string)) {
	fake.addPluginRepositoryMutex.Lock()
	defer fake.addPluginRepositoryMutex.Unlock()
	fake.AddPluginRepositoryStub = stub
}

func (fake *FakeConfig) AddPluginRepositoryArgsForCall(i int) (string, string) {
	fake.addPluginRepositoryMutex.RLock()
	defer fake.addPluginRepositoryMutex.RUnlock()
	argsForCall := fake.addPluginRepositoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConfig) BinaryName() string {
	fake.binaryNameMutex.Lock()
	ret, specificReturn := fake.binaryNameReturnsOnCall[len(fake.binaryNameArgsForCall)]
	fake.binaryNameArgsForCall = append(fake.binaryNameArgsForCall, struct {
	}{})
	fake.recordInvocation("BinaryName", []interface{}{})
	fake.binaryNameMutex.Unlock()
	if fake.BinaryNameStub != nil {
		return fake.BinaryNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.binaryNameReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) BinaryNameCallCount() int {
	fake.binaryNameMutex.RLock()
	defer fake.binaryNameMutex.RUnlock()
	return len(fake.binaryNameArgsForCall)
}

func (fake *FakeConfig) BinaryNameCalls(stub func() string) {
	fake.binaryNameMutex.Lock()
	defer fake.binaryNameMutex.Unlock()
	fake.BinaryNameStub = stub
}

func (fake *FakeConfig) BinaryNameReturns(result1 string) {
	fake.binaryNameMutex.Lock()
	defer fake.binaryNameMutex.Unlock()
	fake.BinaryNameStub = nil
	fake.binaryNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BinaryNameReturnsOnCall(i int, result1 string) {
	fake.binaryNameMutex.Lock()
	defer fake.binaryNameMutex.Unlock()
	fake.BinaryNameStub = nil
	if fake.binaryNameReturnsOnCall == nil {
		fake.binaryNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.binaryNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BinaryVersion() string {
	fake.binaryVersionMutex.Lock()
	ret, specificReturn := fake.binaryVersionReturnsOnCall[len(fake.binaryVersionArgsForCall)]
	fake.binaryVersionArgsForCall = append(fake.binaryVersionArgsForCall, struct {
	}{})
	fake.recordInvocation("BinaryVersion", []interface{}{})
	fake.binaryVersionMutex.Unlock()
	if fake.BinaryVersionStub != nil {
		return fake.BinaryVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.binaryVersionReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) BinaryVersionCallCount() int {
	fake.binaryVersionMutex.RLock()
	defer fake.binaryVersionMutex.RUnlock()
	return len(fake.binaryVersionArgsForCall)
}

func (fake *FakeConfig) BinaryVersionCalls(stub func() string) {
	fake.binaryVersionMutex.Lock()
	defer fake.binaryVersionMutex.Unlock()
	fake.BinaryVersionStub = stub
}

func (fake *FakeConfig) BinaryVersionReturns(result1 string) {
	fake.binaryVersionMutex.Lock()
	defer fake.binaryVersionMutex.Unlock()
	fake.BinaryVersionStub = nil
	fake.binaryVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BinaryVersionReturnsOnCall(i int, result1 string) {
	fake.binaryVersionMutex.Lock()
	defer fake.binaryVersionMutex.Unlock()
	fake.BinaryVersionStub = nil
	if fake.binaryVersionReturnsOnCall == nil {
		fake.binaryVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.binaryVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) CFPassword() string {
	fake.cFPasswordMutex.Lock()
	ret, specificReturn := fake.cFPasswordReturnsOnCall[len(fake.cFPasswordArgsForCall)]
	fake.cFPasswordArgsForCall = append(fake.cFPasswordArgsForCall, struct {
	}{})
	fake.recordInvocation("CFPassword", []interface{}{})
	fake.cFPasswordMutex.Unlock()
	if fake.CFPasswordStub != nil {
		return fake.CFPasswordStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cFPasswordReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) CFPasswordCallCount() int {
	fake.cFPasswordMutex.RLock()
	defer fake.cFPasswordMutex.RUnlock()
	return len(fake.cFPasswordArgsForCall)
}

func (fake *FakeConfig) CFPasswordCalls(stub func() string) {
	fake.cFPasswordMutex.Lock()
	defer fake.cFPasswordMutex.Unlock()
	fake.CFPasswordStub = stub
}

func (fake *FakeConfig) CFPasswordReturns(result1 string) {
	fake.cFPasswordMutex.Lock()
	defer fake.cFPasswordMutex.Unlock()
	fake.CFPasswordStub = nil
	fake.cFPasswordReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) CFPasswordReturnsOnCall(i int, result1 string) {
	fake.cFPasswordMutex.Lock()
	defer fake.cFPasswordMutex.Unlock()
	fake.CFPasswordStub = nil
	if fake.cFPasswordReturnsOnCall == nil {
		fake.cFPasswordReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cFPasswordReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) CFUsername() string {
	fake.cFUsernameMutex.Lock()
	ret, specificReturn := fake.cFUsernameReturnsOnCall[len(fake.cFUsernameArgsForCall)]
	fake.cFUsernameArgsForCall = append(fake.cFUsernameArgsForCall, struct {
	}{})
	fake.recordInvocation("CFUsername", []interface{}{})
	fake.cFUsernameMutex.Unlock()
	if fake.CFUsernameStub != nil {
		return fake.CFUsernameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cFUsernameReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) CFUsernameCallCount() int {
	fake.cFUsernameMutex.RLock()
	defer fake.cFUsernameMutex.RUnlock()
	return len(fake.cFUsernameArgsForCall)
}

func (fake *FakeConfig) CFUsernameCalls(stub func() string) {
	fake.cFUsernameMutex.Lock()
	defer fake.cFUsernameMutex.Unlock()
	fake.CFUsernameStub = stub
}

func (fake *FakeConfig) CFUsernameReturns(result1 string) {
	fake.cFUsernameMutex.Lock()
	defer fake.cFUsernameMutex.Unlock()
	fake.CFUsernameStub = nil
	fake.cFUsernameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) CFUsernameReturnsOnCall(i int, result1 string) {
	fake.cFUsernameMutex.Lock()
	defer fake.cFUsernameMutex.Unlock()
	fake.CFUsernameStub = nil
	if fake.cFUsernameReturnsOnCall == nil {
		fake.cFUsernameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cFUsernameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) ColorEnabled() configv3.ColorSetting {
	fake.colorEnabledMutex.Lock()
	ret, specificReturn := fake.colorEnabledReturnsOnCall[len(fake.colorEnabledArgsForCall)]
	fake.colorEnabledArgsForCall = append(fake.colorEnabledArgsForCall, struct {
	}{})
	fake.recordInvocation("ColorEnabled", []interface{}{})
	fake.colorEnabledMutex.Unlock()
	if fake.ColorEnabledStub != nil {
		return fake.ColorEnabledStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.colorEnabledReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) ColorEnabledCallCount() int {
	fake.colorEnabledMutex.RLock()
	defer fake.colorEnabledMutex.RUnlock()
	return len(fake.colorEnabledArgsForCall)
}

func (fake *FakeConfig) ColorEnabledCalls(stub func() configv3.ColorSetting) {
	fake.colorEnabledMutex.Lock()
	defer fake.colorEnabledMutex.Unlock()
	fake.ColorEnabledStub = stub
}

func (fake *FakeConfig) ColorEnabledReturns(result1 configv3.ColorSetting) {
	fake.colorEnabledMutex.Lock()
	defer fake.colorEnabledMutex.Unlock()
	fake.ColorEnabledStub = nil
	fake.colorEnabledReturns = struct {
		result1 configv3.ColorSetting
	}{result1}
}

func (fake *FakeConfig) ColorEnabledReturnsOnCall(i int, result1 configv3.ColorSetting) {
	fake.colorEnabledMutex.Lock()
	defer fake.colorEnabledMutex.Unlock()
	fake.ColorEnabledStub = nil
	if fake.colorEnabledReturnsOnCall == nil {
		fake.colorEnabledReturnsOnCall = make(map[int]struct {
			result1 configv3.ColorSetting
		})
	}
	fake.colorEnabledReturnsOnCall[i] = struct {
		result1 configv3.ColorSetting
	}{result1}
}

func (fake *FakeConfig) CurrentUser() (configv3.User, error) {
	fake.currentUserMutex.Lock()
	ret, specificReturn := fake.currentUserReturnsOnCall[len(fake.currentUserArgsForCall)]
	fake.currentUserArgsForCall = append(fake.currentUserArgsForCall, struct {
	}{})
	fake.recordInvocation("CurrentUser", []interface{}{})
	fake.currentUserMutex.Unlock()
	if fake.CurrentUserStub != nil {
		return fake.CurrentUserStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentUserReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConfig) CurrentUserCallCount() int {
	fake.currentUserMutex.RLock()
	defer fake.currentUserMutex.RUnlock()
	return len(fake.currentUserArgsForCall)
}

func (fake *FakeConfig) CurrentUserCalls(stub func() (configv3.User, error)) {
	fake.currentUserMutex.Lock()
	defer fake.currentUserMutex.Unlock()
	fake.CurrentUserStub = stub
}

func (fake *FakeConfig) CurrentUserReturns(result1 configv3.User, result2 error) {
	fake.currentUserMutex.Lock()
	defer fake.currentUserMutex.Unlock()
	fake.CurrentUserStub = nil
	fake.currentUserReturns = struct {
		result1 configv3.User
		result2 error
	}{result1, result2}
}

func (fake *FakeConfig) CurrentUserReturnsOnCall(i int, result1 configv3.User, result2 error) {
	fake.currentUserMutex.Lock()
	defer fake.currentUserMutex.Unlock()
	fake.CurrentUserStub = nil
	if fake.currentUserReturnsOnCall == nil {
		fake.currentUserReturnsOnCall = make(map[int]struct {
			result1 configv3.User
			result2 error
		})
	}
	fake.currentUserReturnsOnCall[i] = struct {
		result1 configv3.User
		result2 error
	}{result1, result2}
}

func (fake *FakeConfig) CurrentUserName() (string, error) {
	fake.currentUserNameMutex.Lock()
	ret, specificReturn := fake.currentUserNameReturnsOnCall[len(fake.currentUserNameArgsForCall)]
	fake.currentUserNameArgsForCall = append(fake.currentUserNameArgsForCall, struct {
	}{})
	fake.recordInvocation("CurrentUserName", []interface{}{})
	fake.currentUserNameMutex.Unlock()
	if fake.CurrentUserNameStub != nil {
		return fake.CurrentUserNameStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentUserNameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConfig) CurrentUserNameCallCount() int {
	fake.currentUserNameMutex.RLock()
	defer fake.currentUserNameMutex.RUnlock()
	return len(fake.currentUserNameArgsForCall)
}

func (fake *FakeConfig) CurrentUserNameCalls(stub func() (string, error)) {
	fake.currentUserNameMutex.Lock()
	defer fake.currentUserNameMutex.Unlock()
	fake.CurrentUserNameStub = stub
}

func (fake *FakeConfig) CurrentUserNameReturns(result1 string, result2 error) {
	fake.currentUserNameMutex.Lock()
	defer fake.currentUserNameMutex.Unlock()
	fake.CurrentUserNameStub = nil
	fake.currentUserNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeConfig) CurrentUserNameReturnsOnCall(i int, result1 string, result2 error) {
	fake.currentUserNameMutex.Lock()
	defer fake.currentUserNameMutex.Unlock()
	fake.CurrentUserNameStub = nil
	if fake.currentUserNameReturnsOnCall == nil {
		fake.currentUserNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.currentUserNameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeConfig) DialTimeout() time.Duration {
	fake.dialTimeoutMutex.Lock()
	ret, specificReturn := fake.dialTimeoutReturnsOnCall[len(fake.dialTimeoutArgsForCall)]
	fake.dialTimeoutArgsForCall = append(fake.dialTimeoutArgsForCall, struct {
	}{})
	fake.recordInvocation("DialTimeout", []interface{}{})
	fake.dialTimeoutMutex.Unlock()
	if fake.DialTimeoutStub != nil {
		return fake.DialTimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.dialTimeoutReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) DialTimeoutCallCount() int {
	fake.dialTimeoutMutex.RLock()
	defer fake.dialTimeoutMutex.RUnlock()
	return len(fake.dialTimeoutArgsForCall)
}

func (fake *FakeConfig) DialTimeoutCalls(stub func() time.Duration) {
	fake.dialTimeoutMutex.Lock()
	defer fake.dialTimeoutMutex.Unlock()
	fake.DialTimeoutStub = stub
}

func (fake *FakeConfig) DialTimeoutReturns(result1 time.Duration) {
	fake.dialTimeoutMutex.Lock()
	defer fake.dialTimeoutMutex.Unlock()
	fake.DialTimeoutStub = nil
	fake.dialTimeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) DialTimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.dialTimeoutMutex.Lock()
	defer fake.dialTimeoutMutex.Unlock()
	fake.DialTimeoutStub = nil
	if fake.dialTimeoutReturnsOnCall == nil {
		fake.dialTimeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.dialTimeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) DockerPassword() string {
	fake.dockerPasswordMutex.Lock()
	ret, specificReturn := fake.dockerPasswordReturnsOnCall[len(fake.dockerPasswordArgsForCall)]
	fake.dockerPasswordArgsForCall = append(fake.dockerPasswordArgsForCall, struct {
	}{})
	fake.recordInvocation("DockerPassword", []interface{}{})
	fake.dockerPasswordMutex.Unlock()
	if fake.DockerPasswordStub != nil {
		return fake.DockerPasswordStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.dockerPasswordReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) DockerPasswordCallCount() int {
	fake.dockerPasswordMutex.RLock()
	defer fake.dockerPasswordMutex.RUnlock()
	return len(fake.dockerPasswordArgsForCall)
}

func (fake *FakeConfig) DockerPasswordCalls(stub func() string) {
	fake.dockerPasswordMutex.Lock()
	defer fake.dockerPasswordMutex.Unlock()
	fake.DockerPasswordStub = stub
}

func (fake *FakeConfig) DockerPasswordReturns(result1 string) {
	fake.dockerPasswordMutex.Lock()
	defer fake.dockerPasswordMutex.Unlock()
	fake.DockerPasswordStub = nil
	fake.dockerPasswordReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) DockerPasswordReturnsOnCall(i int, result1 string) {
	fake.dockerPasswordMutex.Lock()
	defer fake.dockerPasswordMutex.Unlock()
	fake.DockerPasswordStub = nil
	if fake.dockerPasswordReturnsOnCall == nil {
		fake.dockerPasswordReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.dockerPasswordReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) Experimental() bool {
	fake.experimentalMutex.Lock()
	ret, specificReturn := fake.experimentalReturnsOnCall[len(fake.experimentalArgsForCall)]
	fake.experimentalArgsForCall = append(fake.experimentalArgsForCall, struct {
	}{})
	fake.recordInvocation("Experimental", []interface{}{})
	fake.experimentalMutex.Unlock()
	if fake.ExperimentalStub != nil {
		return fake.ExperimentalStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.experimentalReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) ExperimentalCallCount() int {
	fake.experimentalMutex.RLock()
	defer fake.experimentalMutex.RUnlock()
	return len(fake.experimentalArgsForCall)
}

func (fake *FakeConfig) ExperimentalCalls(stub func() bool) {
	fake.experimentalMutex.Lock()
	defer fake.experimentalMutex.Unlock()
	fake.ExperimentalStub = stub
}

func (fake *FakeConfig) ExperimentalReturns(result1 bool) {
	fake.experimentalMutex.Lock()
	defer fake.experimentalMutex.Unlock()
	fake.ExperimentalStub = nil
	fake.experimentalReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) ExperimentalReturnsOnCall(i int, result1 bool) {
	fake.experimentalMutex.Lock()
	defer fake.experimentalMutex.Unlock()
	fake.ExperimentalStub = nil
	if fake.experimentalReturnsOnCall == nil {
		fake.experimentalReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.experimentalReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) GetPlugin(arg1 string) (configv3.Plugin, bool) {
	fake.getPluginMutex.Lock()
	ret, specificReturn := fake.getPluginReturnsOnCall[len(fake.getPluginArgsForCall)]
	fake.getPluginArgsForCall = append(fake.getPluginArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetPlugin", []interface{}{arg1})
	fake.getPluginMutex.Unlock()
	if fake.GetPluginStub != nil {
		return fake.GetPluginStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getPluginReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConfig) GetPluginCallCount() int {
	fake.getPluginMutex.RLock()
	defer fake.getPluginMutex.RUnlock()
	return len(fake.getPluginArgsForCall)
}

func (fake *FakeConfig) GetPluginCalls(stub func(string) (configv3.Plugin, bool)) {
	fake.getPluginMutex.Lock()
	defer fake.getPluginMutex.Unlock()
	fake.GetPluginStub = stub
}

func (fake *FakeConfig) GetPluginArgsForCall(i int) string {
	fake.getPluginMutex.RLock()
	defer fake.getPluginMutex.RUnlock()
	argsForCall := fake.getPluginArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConfig) GetPluginReturns(result1 configv3.Plugin, result2 bool) {
	fake.getPluginMutex.Lock()
	defer fake.getPluginMutex.Unlock()
	fake.GetPluginStub = nil
	fake.getPluginReturns = struct {
		result1 configv3.Plugin
		result2 bool
	}{result1, result2}
}

func (fake *FakeConfig) GetPluginReturnsOnCall(i int, result1 configv3.Plugin, result2 bool) {
	fake.getPluginMutex.Lock()
	defer fake.getPluginMutex.Unlock()
	fake.GetPluginStub = nil
	if fake.getPluginReturnsOnCall == nil {
		fake.getPluginReturnsOnCall = make(map[int]struct {
			result1 configv3.Plugin
			result2 bool
		})
	}
	fake.getPluginReturnsOnCall[i] = struct {
		result1 configv3.Plugin
		result2 bool
	}{result1, result2}
}

func (fake *FakeConfig) GetPluginCaseInsensitive(arg1 string) (configv3.Plugin, bool) {
	fake.getPluginCaseInsensitiveMutex.Lock()
	ret, specificReturn := fake.getPluginCaseInsensitiveReturnsOnCall[len(fake.getPluginCaseInsensitiveArgsForCall)]
	fake.getPluginCaseInsensitiveArgsForCall = append(fake.getPluginCaseInsensitiveArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetPluginCaseInsensitive", []interface{}{arg1})
	fake.getPluginCaseInsensitiveMutex.Unlock()
	if fake.GetPluginCaseInsensitiveStub != nil {
		return fake.GetPluginCaseInsensitiveStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getPluginCaseInsensitiveReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConfig) GetPluginCaseInsensitiveCallCount() int {
	fake.getPluginCaseInsensitiveMutex.RLock()
	defer fake.getPluginCaseInsensitiveMutex.RUnlock()
	return len(fake.getPluginCaseInsensitiveArgsForCall)
}

func (fake *FakeConfig) GetPluginCaseInsensitiveCalls(stub func(string) (configv3.Plugin, bool)) {
	fake.getPluginCaseInsensitiveMutex.Lock()
	defer fake.getPluginCaseInsensitiveMutex.Unlock()
	fake.GetPluginCaseInsensitiveStub = stub
}

func (fake *FakeConfig) GetPluginCaseInsensitiveArgsForCall(i int) string {
	fake.getPluginCaseInsensitiveMutex.RLock()
	defer fake.getPluginCaseInsensitiveMutex.RUnlock()
	argsForCall := fake.getPluginCaseInsensitiveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConfig) GetPluginCaseInsensitiveReturns(result1 configv3.Plugin, result2 bool) {
	fake.getPluginCaseInsensitiveMutex.Lock()
	defer fake.getPluginCaseInsensitiveMutex.Unlock()
	fake.GetPluginCaseInsensitiveStub = nil
	fake.getPluginCaseInsensitiveReturns = struct {
		result1 configv3.Plugin
		result2 bool
	}{result1, result2}
}

func (fake *FakeConfig) GetPluginCaseInsensitiveReturnsOnCall(i int, result1 configv3.Plugin, result2 bool) {
	fake.getPluginCaseInsensitiveMutex.Lock()
	defer fake.getPluginCaseInsensitiveMutex.Unlock()
	fake.GetPluginCaseInsensitiveStub = nil
	if fake.getPluginCaseInsensitiveReturnsOnCall == nil {
		fake.getPluginCaseInsensitiveReturnsOnCall = make(map[int]struct {
			result1 configv3.Plugin
			result2 bool
		})
	}
	fake.getPluginCaseInsensitiveReturnsOnCall[i] = struct {
		result1 configv3.Plugin
		result2 bool
	}{result1, result2}
}

func (fake *FakeConfig) HasTargetedOrganization() bool {
	fake.hasTargetedOrganizationMutex.Lock()
	ret, specificReturn := fake.hasTargetedOrganizationReturnsOnCall[len(fake.hasTargetedOrganizationArgsForCall)]
	fake.hasTargetedOrganizationArgsForCall = append(fake.hasTargetedOrganizationArgsForCall, struct {
	}{})
	fake.recordInvocation("HasTargetedOrganization", []interface{}{})
	fake.hasTargetedOrganizationMutex.Unlock()
	if fake.HasTargetedOrganizationStub != nil {
		return fake.HasTargetedOrganizationStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasTargetedOrganizationReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) HasTargetedOrganizationCallCount() int {
	fake.hasTargetedOrganizationMutex.RLock()
	defer fake.hasTargetedOrganizationMutex.RUnlock()
	return len(fake.hasTargetedOrganizationArgsForCall)
}

func (fake *FakeConfig) HasTargetedOrganizationCalls(stub func() bool) {
	fake.hasTargetedOrganizationMutex.Lock()
	defer fake.hasTargetedOrganizationMutex.Unlock()
	fake.HasTargetedOrganizationStub = stub
}

func (fake *FakeConfig) HasTargetedOrganizationReturns(result1 bool) {
	fake.hasTargetedOrganizationMutex.Lock()
	defer fake.hasTargetedOrganizationMutex.Unlock()
	fake.HasTargetedOrganizationStub = nil
	fake.hasTargetedOrganizationReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) HasTargetedOrganizationReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedOrganizationMutex.Lock()
	defer fake.hasTargetedOrganizationMutex.Unlock()
	fake.HasTargetedOrganizationStub = nil
	if fake.hasTargetedOrganizationReturnsOnCall == nil {
		fake.hasTargetedOrganizationReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedOrganizationReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) HasTargetedSpace() bool {
	fake.hasTargetedSpaceMutex.Lock()
	ret, specificReturn := fake.hasTargetedSpaceReturnsOnCall[len(fake.hasTargetedSpaceArgsForCall)]
	fake.hasTargetedSpaceArgsForCall = append(fake.hasTargetedSpaceArgsForCall, struct {
	}{})
	fake.recordInvocation("HasTargetedSpace", []interface{}{})
	fake.hasTargetedSpaceMutex.Unlock()
	if fake.HasTargetedSpaceStub != nil {
		return fake.HasTargetedSpaceStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasTargetedSpaceReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) HasTargetedSpaceCallCount() int {
	fake.hasTargetedSpaceMutex.RLock()
	defer fake.hasTargetedSpaceMutex.RUnlock()
	return len(fake.hasTargetedSpaceArgsForCall)
}

func (fake *FakeConfig) HasTargetedSpaceCalls(stub func() bool) {
	fake.hasTargetedSpaceMutex.Lock()
	defer fake.hasTargetedSpaceMutex.Unlock()
	fake.HasTargetedSpaceStub = stub
}

func (fake *FakeConfig) HasTargetedSpaceReturns(result1 bool) {
	fake.hasTargetedSpaceMutex.Lock()
	defer fake.hasTargetedSpaceMutex.Unlock()
	fake.HasTargetedSpaceStub = nil
	fake.hasTargetedSpaceReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) HasTargetedSpaceReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedSpaceMutex.Lock()
	defer fake.hasTargetedSpaceMutex.Unlock()
	fake.HasTargetedSpaceStub = nil
	if fake.hasTargetedSpaceReturnsOnCall == nil {
		fake.hasTargetedSpaceReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedSpaceReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) Locale() string {
	fake.localeMutex.Lock()
	ret, specificReturn := fake.localeReturnsOnCall[len(fake.localeArgsForCall)]
	fake.localeArgsForCall = append(fake.localeArgsForCall, struct {
	}{})
	fake.recordInvocation("Locale", []interface{}{})
	fake.localeMutex.Unlock()
	if fake.LocaleStub != nil {
		return fake.LocaleStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.localeReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) LocaleCallCount() int {
	fake.localeMutex.RLock()
	defer fake.localeMutex.RUnlock()
	return len(fake.localeArgsForCall)
}

func (fake *FakeConfig) LocaleCalls(stub func() string) {
	fake.localeMutex.Lock()
	defer fake.localeMutex.Unlock()
	fake.LocaleStub = stub
}

func (fake *FakeConfig) LocaleReturns(result1 string) {
	fake.localeMutex.Lock()
	defer fake.localeMutex.Unlock()
	fake.LocaleStub = nil
	fake.localeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) LocaleReturnsOnCall(i int, result1 string) {
	fake.localeMutex.Lock()
	defer fake.localeMutex.Unlock()
	fake.LocaleStub = nil
	if fake.localeReturnsOnCall == nil {
		fake.localeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.localeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) MinCLIVersion() string {
	fake.minCLIVersionMutex.Lock()
	ret, specificReturn := fake.minCLIVersionReturnsOnCall[len(fake.minCLIVersionArgsForCall)]
	fake.minCLIVersionArgsForCall = append(fake.minCLIVersionArgsForCall, struct {
	}{})
	fake.recordInvocation("MinCLIVersion", []interface{}{})
	fake.minCLIVersionMutex.Unlock()
	if fake.MinCLIVersionStub != nil {
		return fake.MinCLIVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.minCLIVersionReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) MinCLIVersionCallCount() int {
	fake.minCLIVersionMutex.RLock()
	defer fake.minCLIVersionMutex.RUnlock()
	return len(fake.minCLIVersionArgsForCall)
}

func (fake *FakeConfig) MinCLIVersionCalls(stub func() string) {
	fake.minCLIVersionMutex.Lock()
	defer fake.minCLIVersionMutex.Unlock()
	fake.MinCLIVersionStub = stub
}

func (fake *FakeConfig) MinCLIVersionReturns(result1 string) {
	fake.minCLIVersionMutex.Lock()
	defer fake.minCLIVersionMutex.Unlock()
	fake.MinCLIVersionStub = nil
	fake.minCLIVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) MinCLIVersionReturnsOnCall(i int, result1 string) {
	fake.minCLIVersionMutex.Lock()
	defer fake.minCLIVersionMutex.Unlock()
	fake.MinCLIVersionStub = nil
	if fake.minCLIVersionReturnsOnCall == nil {
		fake.minCLIVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.minCLIVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) NOAARequestRetryCount() int {
	fake.nOAARequestRetryCountMutex.Lock()
	ret, specificReturn := fake.nOAARequestRetryCountReturnsOnCall[len(fake.nOAARequestRetryCountArgsForCall)]
	fake.nOAARequestRetryCountArgsForCall = append(fake.nOAARequestRetryCountArgsForCall, struct {
	}{})
	fake.recordInvocation("NOAARequestRetryCount", []interface{}{})
	fake.nOAARequestRetryCountMutex.Unlock()
	if fake.NOAARequestRetryCountStub != nil {
		return fake.NOAARequestRetryCountStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nOAARequestRetryCountReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) NOAARequestRetryCountCallCount() int {
	fake.nOAARequestRetryCountMutex.RLock()
	defer fake.nOAARequestRetryCountMutex.RUnlock()
	return len(fake.nOAARequestRetryCountArgsForCall)
}

func (fake *FakeConfig) NOAARequestRetryCountCalls(stub func() int) {
	fake.nOAARequestRetryCountMutex.Lock()
	defer fake.nOAARequestRetryCountMutex.Unlock()
	fake.NOAARequestRetryCountStub = stub
}

func (fake *FakeConfig) NOAARequestRetryCountReturns(result1 int) {
	fake.nOAARequestRetryCountMutex.Lock()
	defer fake.nOAARequestRetryCountMutex.Unlock()
	fake.NOAARequestRetryCountStub = nil
	fake.nOAARequestRetryCountReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeConfig) NOAARequestRetryCountReturnsOnCall(i int, result1 int) {
	fake.nOAARequestRetryCountMutex.Lock()
	defer fake.nOAARequestRetryCountMutex.Unlock()
	fake.NOAARequestRetryCountStub = nil
	if fake.nOAARequestRetryCountReturnsOnCall == nil {
		fake.nOAARequestRetryCountReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.nOAARequestRetryCountReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeConfig) OverallPollingTimeout() time.Duration {
	fake.overallPollingTimeoutMutex.Lock()
	ret, specificReturn := fake.overallPollingTimeoutReturnsOnCall[len(fake.overallPollingTimeoutArgsForCall)]
	fake.overallPollingTimeoutArgsForCall = append(fake.overallPollingTimeoutArgsForCall, struct {
	}{})
	fake.recordInvocation("OverallPollingTimeout", []interface{}{})
	fake.overallPollingTimeoutMutex.Unlock()
	if fake.OverallPollingTimeoutStub != nil {
		return fake.OverallPollingTimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.overallPollingTimeoutReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) OverallPollingTimeoutCallCount() int {
	fake.overallPollingTimeoutMutex.RLock()
	defer fake.overallPollingTimeoutMutex.RUnlock()
	return len(fake.overallPollingTimeoutArgsForCall)
}

func (fake *FakeConfig) OverallPollingTimeoutCalls(stub func() time.Duration) {
	fake.overallPollingTimeoutMutex.Lock()
	defer fake.overallPollingTimeoutMutex.Unlock()
	fake.OverallPollingTimeoutStub = stub
}

func (fake *FakeConfig) OverallPollingTimeoutReturns(result1 time.Duration) {
	fake.overallPollingTimeoutMutex.Lock()
	defer fake.overallPollingTimeoutMutex.Unlock()
	fake.OverallPollingTimeoutStub = nil
	fake.overallPollingTimeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) OverallPollingTimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.overallPollingTimeoutMutex.Lock()
	defer fake.overallPollingTimeoutMutex.Unlock()
	fake.OverallPollingTimeoutStub = nil
	if fake.overallPollingTimeoutReturnsOnCall == nil {
		fake.overallPollingTimeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.overallPollingTimeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) PluginHome() string {
	fake.pluginHomeMutex.Lock()
	ret, specificReturn := fake.pluginHomeReturnsOnCall[len(fake.pluginHomeArgsForCall)]
	fake.pluginHomeArgsForCall = append(fake.pluginHomeArgsForCall, struct {
	}{})
	fake.recordInvocation("PluginHome", []interface{}{})
	fake.pluginHomeMutex.Unlock()
	if fake.PluginHomeStub != nil {
		return fake.PluginHomeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pluginHomeReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) PluginHomeCallCount() int {
	fake.pluginHomeMutex.RLock()
	defer fake.pluginHomeMutex.RUnlock()
	return len(fake.pluginHomeArgsForCall)
}

func (fake *FakeConfig) PluginHomeCalls(stub func() string) {
	fake.pluginHomeMutex.Lock()
	defer fake.pluginHomeMutex.Unlock()
	fake.PluginHomeStub = stub
}

func (fake *FakeConfig) PluginHomeReturns(result1 string) {
	fake.pluginHomeMutex.Lock()
	defer fake.pluginHomeMutex.Unlock()
	fake.PluginHomeStub = nil
	fake.pluginHomeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) PluginHomeReturnsOnCall(i int, result1 string) {
	fake.pluginHomeMutex.Lock()
	defer fake.pluginHomeMutex.Unlock()
	fake.PluginHomeStub = nil
	if fake.pluginHomeReturnsOnCall == nil {
		fake.pluginHomeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pluginHomeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) PluginRepositories() []configv3.PluginRepository {
	fake.pluginRepositoriesMutex.Lock()
	ret, specificReturn := fake.pluginRepositoriesReturnsOnCall[len(fake.pluginRepositoriesArgsForCall)]
	fake.pluginRepositoriesArgsForCall = append(fake.pluginRepositoriesArgsForCall, struct {
	}{})
	fake.recordInvocation("PluginRepositories", []interface{}{})
	fake.pluginRepositoriesMutex.Unlock()
	if fake.PluginRepositoriesStub != nil {
		return fake.PluginRepositoriesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pluginRepositoriesReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) PluginRepositoriesCallCount() int {
	fake.pluginRepositoriesMutex.RLock()
	defer fake.pluginRepositoriesMutex.RUnlock()
	return len(fake.pluginRepositoriesArgsForCall)
}

func (fake *FakeConfig) PluginRepositoriesCalls(stub func() []configv3.PluginRepository) {
	fake.pluginRepositoriesMutex.Lock()
	defer fake.pluginRepositoriesMutex.Unlock()
	fake.PluginRepositoriesStub = stub
}

func (fake *FakeConfig) PluginRepositoriesReturns(result1 []configv3.PluginRepository) {
	fake.pluginRepositoriesMutex.Lock()
	defer fake.pluginRepositoriesMutex.Unlock()
	fake.PluginRepositoriesStub = nil
	fake.pluginRepositoriesReturns = struct {
		result1 []configv3.PluginRepository
	}{result1}
}

func (fake *FakeConfig) PluginRepositoriesReturnsOnCall(i int, result1 []configv3.PluginRepository) {
	fake.pluginRepositoriesMutex.Lock()
	defer fake.pluginRepositoriesMutex.Unlock()
	fake.PluginRepositoriesStub = nil
	if fake.pluginRepositoriesReturnsOnCall == nil {
		fake.pluginRepositoriesReturnsOnCall = make(map[int]struct {
			result1 []configv3.PluginRepository
		})
	}
	fake.pluginRepositoriesReturnsOnCall[i] = struct {
		result1 []configv3.PluginRepository
	}{result1}
}

func (fake *FakeConfig) Plugins() []configv3.Plugin {
	fake.pluginsMutex.Lock()
	ret, specificReturn := fake.pluginsReturnsOnCall[len(fake.pluginsArgsForCall)]
	fake.pluginsArgsForCall = append(fake.pluginsArgsForCall, struct {
	}{})
	fake.recordInvocation("Plugins", []interface{}{})
	fake.pluginsMutex.Unlock()
	if fake.PluginsStub != nil {
		return fake.PluginsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pluginsReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) PluginsCallCount() int {
	fake.pluginsMutex.RLock()
	defer fake.pluginsMutex.RUnlock()
	return len(fake.pluginsArgsForCall)
}

func (fake *FakeConfig) PluginsCalls(stub func() []configv3.Plugin) {
	fake.pluginsMutex.Lock()
	defer fake.pluginsMutex.Unlock()
	fake.PluginsStub = stub
}

func (fake *FakeConfig) PluginsReturns(result1 []configv3.Plugin) {
	fake.pluginsMutex.Lock()
	defer fake.pluginsMutex.Unlock()
	fake.PluginsStub = nil
	fake.pluginsReturns = struct {
		result1 []configv3.Plugin
	}{result1}
}

func (fake *FakeConfig) PluginsReturnsOnCall(i int, result1 []configv3.Plugin) {
	fake.pluginsMutex.Lock()
	defer fake.pluginsMutex.Unlock()
	fake.PluginsStub = nil
	if fake.pluginsReturnsOnCall == nil {
		fake.pluginsReturnsOnCall = make(map[int]struct {
			result1 []configv3.Plugin
		})
	}
	fake.pluginsReturnsOnCall[i] = struct {
		result1 []configv3.Plugin
	}{result1}
}

func (fake *FakeConfig) PollingInterval() time.Duration {
	fake.pollingIntervalMutex.Lock()
	ret, specificReturn := fake.pollingIntervalReturnsOnCall[len(fake.pollingIntervalArgsForCall)]
	fake.pollingIntervalArgsForCall = append(fake.pollingIntervalArgsForCall, struct {
	}{})
	fake.recordInvocation("PollingInterval", []interface{}{})
	fake.pollingIntervalMutex.Unlock()
	if fake.PollingIntervalStub != nil {
		return fake.PollingIntervalStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pollingIntervalReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) PollingIntervalCallCount() int {
	fake.pollingIntervalMutex.RLock()
	defer fake.pollingIntervalMutex.RUnlock()
	return len(fake.pollingIntervalArgsForCall)
}

func (fake *FakeConfig) PollingIntervalCalls(stub func() time.Duration) {
	fake.pollingIntervalMutex.Lock()
	defer fake.pollingIntervalMutex.Unlock()
	fake.PollingIntervalStub = stub
}

func (fake *FakeConfig) PollingIntervalReturns(result1 time.Duration) {
	fake.pollingIntervalMutex.Lock()
	defer fake.pollingIntervalMutex.Unlock()
	fake.PollingIntervalStub = nil
	fake.pollingIntervalReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) PollingIntervalReturnsOnCall(i int, result1 time.Duration) {
	fake.pollingIntervalMutex.Lock()
	defer fake.pollingIntervalMutex.Unlock()
	fake.PollingIntervalStub = nil
	if fake.pollingIntervalReturnsOnCall == nil {
		fake.pollingIntervalReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.pollingIntervalReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) RefreshToken() string {
	fake.refreshTokenMutex.Lock()
	ret, specificReturn := fake.refreshTokenReturnsOnCall[len(fake.refreshTokenArgsForCall)]
	fake.refreshTokenArgsForCall = append(fake.refreshTokenArgsForCall, struct {
	}{})
	fake.recordInvocation("RefreshToken", []interface{}{})
	fake.refreshTokenMutex.Unlock()
	if fake.RefreshTokenStub != nil {
		return fake.RefreshTokenStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.refreshTokenReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) RefreshTokenCallCount() int {
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	return len(fake.refreshTokenArgsForCall)
}

func (fake *FakeConfig) RefreshTokenCalls(stub func() string) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = stub
}

func (fake *FakeConfig) RefreshTokenReturns(result1 string) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = nil
	fake.refreshTokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) RefreshTokenReturnsOnCall(i int, result1 string) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = nil
	if fake.refreshTokenReturnsOnCall == nil {
		fake.refreshTokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.refreshTokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) RemovePlugin(arg1 string) {
	fake.removePluginMutex.Lock()
	fake.removePluginArgsForCall = append(fake.removePluginArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("RemovePlugin", []interface{}{arg1})
	fake.removePluginMutex.Unlock()
	if fake.RemovePluginStub != nil {
		fake.RemovePluginStub(arg1)
	}
}

func (fake *FakeConfig) RemovePluginCallCount() int {
	fake.removePluginMutex.RLock()
	defer fake.removePluginMutex.RUnlock()
	return len(fake.removePluginArgsForCall)
}

func (fake *FakeConfig) RemovePluginCalls(stub func(string)) {
	fake.removePluginMutex.Lock()
	defer fake.removePluginMutex.Unlock()
	fake.RemovePluginStub = stub
}

func (fake *FakeConfig) RemovePluginArgsForCall(i int) string {
	fake.removePluginMutex.RLock()
	defer fake.removePluginMutex.RUnlock()
	argsForCall := fake.removePluginArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConfig) RequestRetryCount() int {
	fake.requestRetryCountMutex.Lock()
	ret, specificReturn := fake.requestRetryCountReturnsOnCall[len(fake.requestRetryCountArgsForCall)]
	fake.requestRetryCountArgsForCall = append(fake.requestRetryCountArgsForCall, struct {
	}{})
	fake.recordInvocation("RequestRetryCount", []interface{}{})
	fake.requestRetryCountMutex.Unlock()
	if fake.RequestRetryCountStub != nil {
		return fake.RequestRetryCountStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.requestRetryCountReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) RequestRetryCountCallCount() int {
	fake.requestRetryCountMutex.RLock()
	defer fake.requestRetryCountMutex.RUnlock()
	return len(fake.requestRetryCountArgsForCall)
}

func (fake *FakeConfig) RequestRetryCountCalls(stub func() int) {
	fake.requestRetryCountMutex.Lock()
	defer fake.requestRetryCountMutex.Unlock()
	fake.RequestRetryCountStub = stub
}

func (fake *FakeConfig) RequestRetryCountReturns(result1 int) {
	fake.requestRetryCountMutex.Lock()
	defer fake.requestRetryCountMutex.Unlock()
	fake.RequestRetryCountStub = nil
	fake.requestRetryCountReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeConfig) RequestRetryCountReturnsOnCall(i int, result1 int) {
	fake.requestRetryCountMutex.Lock()
	defer fake.requestRetryCountMutex.Unlock()
	fake.RequestRetryCountStub = nil
	if fake.requestRetryCountReturnsOnCall == nil {
		fake.requestRetryCountReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.requestRetryCountReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeConfig) RoutingEndpoint() string {
	fake.routingEndpointMutex.Lock()
	ret, specificReturn := fake.routingEndpointReturnsOnCall[len(fake.routingEndpointArgsForCall)]
	fake.routingEndpointArgsForCall = append(fake.routingEndpointArgsForCall, struct {
	}{})
	fake.recordInvocation("RoutingEndpoint", []interface{}{})
	fake.routingEndpointMutex.Unlock()
	if fake.RoutingEndpointStub != nil {
		return fake.RoutingEndpointStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.routingEndpointReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) RoutingEndpointCallCount() int {
	fake.routingEndpointMutex.RLock()
	defer fake.routingEndpointMutex.RUnlock()
	return len(fake.routingEndpointArgsForCall)
}

func (fake *FakeConfig) RoutingEndpointCalls(stub func() string) {
	fake.routingEndpointMutex.Lock()
	defer fake.routingEndpointMutex.Unlock()
	fake.RoutingEndpointStub = stub
}

func (fake *FakeConfig) RoutingEndpointReturns(result1 string) {
	fake.routingEndpointMutex.Lock()
	defer fake.routingEndpointMutex.Unlock()
	fake.RoutingEndpointStub = nil
	fake.routingEndpointReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) RoutingEndpointReturnsOnCall(i int, result1 string) {
	fake.routingEndpointMutex.Lock()
	defer fake.routingEndpointMutex.Unlock()
	fake.RoutingEndpointStub = nil
	if fake.routingEndpointReturnsOnCall == nil {
		fake.routingEndpointReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.routingEndpointReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) SSHOAuthClient() string {
	fake.sSHOAuthClientMutex.Lock()
	ret, specificReturn := fake.sSHOAuthClientReturnsOnCall[len(fake.sSHOAuthClientArgsForCall)]
	fake.sSHOAuthClientArgsForCall = append(fake.sSHOAuthClientArgsForCall, struct {
	}{})
	fake.recordInvocation("SSHOAuthClient", []interface{}{})
	fake.sSHOAuthClientMutex.Unlock()
	if fake.SSHOAuthClientStub != nil {
		return fake.SSHOAuthClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sSHOAuthClientReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) SSHOAuthClientCallCount() int {
	fake.sSHOAuthClientMutex.RLock()
	defer fake.sSHOAuthClientMutex.RUnlock()
	return len(fake.sSHOAuthClientArgsForCall)
}

func (fake *FakeConfig) SSHOAuthClientCalls(stub func() string) {
	fake.sSHOAuthClientMutex.Lock()
	defer fake.sSHOAuthClientMutex.Unlock()
	fake.SSHOAuthClientStub = stub
}

func (fake *FakeConfig) SSHOAuthClientReturns(result1 string) {
	fake.sSHOAuthClientMutex.Lock()
	defer fake.sSHOAuthClientMutex.Unlock()
	fake.SSHOAuthClientStub = nil
	fake.sSHOAuthClientReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) SSHOAuthClientReturnsOnCall(i int, result1 string) {
	fake.sSHOAuthClientMutex.Lock()
	defer fake.sSHOAuthClientMutex.Unlock()
	fake.SSHOAuthClientStub = nil
	if fake.sSHOAuthClientReturnsOnCall == nil {
		fake.sSHOAuthClientReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.sSHOAuthClientReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) SetAccessToken(arg1 string) {
	fake.setAccessTokenMutex.Lock()
	fake.setAccessTokenArgsForCall = append(fake.setAccessTokenArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetAccessToken", []interface{}{arg1})
	fake.setAccessTokenMutex.Unlock()
	if fake.SetAccessTokenStub != nil {
		fake.SetAccessTokenStub(arg1)
	}
}

func (fake *FakeConfig) SetAccessTokenCallCount() int {
	fake.setAccessTokenMutex.RLock()
	defer fake.setAccessTokenMutex.RUnlock()
	return len(fake.setAccessTokenArgsForCall)
}

func (fake *FakeConfig) SetAccessTokenCalls(stub func(string)) {
	fake.setAccessTokenMutex.Lock()
	defer fake.setAccessTokenMutex.Unlock()
	fake.SetAccessTokenStub = stub
}

func (fake *FakeConfig) SetAccessTokenArgsForCall(i int) string {
	fake.setAccessTokenMutex.RLock()
	defer fake.setAccessTokenMutex.RUnlock()
	argsForCall := fake.setAccessTokenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConfig) SetOrganizationInformation(arg1 string, arg2 string) {
	fake.setOrganizationInformationMutex.Lock()
	fake.setOrganizationInformationArgsForCall = append(fake.setOrganizationInformationArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SetOrganizationInformation", []interface{}{arg1, arg2})
	fake.setOrganizationInformationMutex.Unlock()
	if fake.SetOrganizationInformationStub != nil {
		fake.SetOrganizationInformationStub(arg1, arg2)
	}
}

func (fake *FakeConfig) SetOrganizationInformationCallCount() int {
	fake.setOrganizationInformationMutex.RLock()
	defer fake.setOrganizationInformationMutex.RUnlock()
	return len(fake.setOrganizationInformationArgsForCall)
}

func (fake *FakeConfig) SetOrganizationInformationCalls(stub func(string, string)) {
	fake.setOrganizationInformationMutex.Lock()
	defer fake.setOrganizationInformationMutex.Unlock()
	fake.SetOrganizationInformationStub = stub
}

func (fake *FakeConfig) SetOrganizationInformationArgsForCall(i int) (string, string) {
	fake.setOrganizationInformationMutex.RLock()
	defer fake.setOrganizationInformationMutex.RUnlock()
	argsForCall := fake.setOrganizationInformationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConfig) SetRefreshToken(arg1 string) {
	fake.setRefreshTokenMutex.Lock()
	fake.setRefreshTokenArgsForCall = append(fake.setRefreshTokenArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetRefreshToken", []interface{}{arg1})
	fake.setRefreshTokenMutex.Unlock()
	if fake.SetRefreshTokenStub != nil {
		fake.SetRefreshTokenStub(arg1)
	}
}

func (fake *FakeConfig) SetRefreshTokenCallCount() int {
	fake.setRefreshTokenMutex.RLock()
	defer fake.setRefreshTokenMutex.RUnlock()
	return len(fake.setRefreshTokenArgsForCall)
}

func (fake *FakeConfig) SetRefreshTokenCalls(stub func(string)) {
	fake.setRefreshTokenMutex.Lock()
	defer fake.setRefreshTokenMutex.Unlock()
	fake.SetRefreshTokenStub = stub
}

func (fake *FakeConfig) SetRefreshTokenArgsForCall(i int) string {
	fake.setRefreshTokenMutex.RLock()
	defer fake.setRefreshTokenMutex.RUnlock()
	argsForCall := fake.setRefreshTokenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConfig) SetSpaceInformation(arg1 string, arg2 string, arg3 bool) {
	fake.setSpaceInformationMutex.Lock()
	fake.setSpaceInformationArgsForCall = append(fake.setSpaceInformationArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("SetSpaceInformation", []interface{}{arg1, arg2, arg3})
	fake.setSpaceInformationMutex.Unlock()
	if fake.SetSpaceInformationStub != nil {
		fake.SetSpaceInformationStub(arg1, arg2, arg3)
	}
}

func (fake *FakeConfig) SetSpaceInformationCallCount() int {
	fake.setSpaceInformationMutex.RLock()
	defer fake.setSpaceInformationMutex.RUnlock()
	return len(fake.setSpaceInformationArgsForCall)
}

func (fake *FakeConfig) SetSpaceInformationCalls(stub func(string, string, bool)) {
	fake.setSpaceInformationMutex.Lock()
	defer fake.setSpaceInformationMutex.Unlock()
	fake.SetSpaceInformationStub = stub
}

func (fake *FakeConfig) SetSpaceInformationArgsForCall(i int) (string, string, bool) {
	fake.setSpaceInformationMutex.RLock()
	defer fake.setSpaceInformationMutex.RUnlock()
	argsForCall := fake.setSpaceInformationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeConfig) SetTargetInformation(arg1 string, arg2 string, arg3 string, arg4 string, arg5 string, arg6 string, arg7 bool) {
	fake.setTargetInformationMutex.Lock()
	fake.setTargetInformationArgsForCall = append(fake.setTargetInformationArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 bool
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.recordInvocation("SetTargetInformation", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.setTargetInformationMutex.Unlock()
	if fake.SetTargetInformationStub != nil {
		fake.SetTargetInformationStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
}

func (fake *FakeConfig) SetTargetInformationCallCount() int {
	fake.setTargetInformationMutex.RLock()
	defer fake.setTargetInformationMutex.RUnlock()
	return len(fake.setTargetInformationArgsForCall)
}

func (fake *FakeConfig) SetTargetInformationCalls(stub func(string, string, string, string, string, string, bool)) {
	fake.setTargetInformationMutex.Lock()
	defer fake.setTargetInformationMutex.Unlock()
	fake.SetTargetInformationStub = stub
}

func (fake *FakeConfig) SetTargetInformationArgsForCall(i int) (string, string, string, string, string, string, bool) {
	fake.setTargetInformationMutex.RLock()
	defer fake.setTargetInformationMutex.RUnlock()
	argsForCall := fake.setTargetInformationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeConfig) SetTokenInformation(arg1 string, arg2 string, arg3 string) {
	fake.setTokenInformationMutex.Lock()
	fake.setTokenInformationArgsForCall = append(fake.setTokenInformationArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("SetTokenInformation", []interface{}{arg1, arg2, arg3})
	fake.setTokenInformationMutex.Unlock()
	if fake.SetTokenInformationStub != nil {
		fake.SetTokenInformationStub(arg1, arg2, arg3)
	}
}

func (fake *FakeConfig) SetTokenInformationCallCount() int {
	fake.setTokenInformationMutex.RLock()
	defer fake.setTokenInformationMutex.RUnlock()
	return len(fake.setTokenInformationArgsForCall)
}

func (fake *FakeConfig) SetTokenInformationCalls(stub func(string, string, string)) {
	fake.setTokenInformationMutex.Lock()
	defer fake.setTokenInformationMutex.Unlock()
	fake.SetTokenInformationStub = stub
}

func (fake *FakeConfig) SetTokenInformationArgsForCall(i int) (string, string, string) {
	fake.setTokenInformationMutex.RLock()
	defer fake.setTokenInformationMutex.RUnlock()
	argsForCall := fake.setTokenInformationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeConfig) SetUAAClientCredentials(arg1 string, arg2 string) {
	fake.setUAAClientCredentialsMutex.Lock()
	fake.setUAAClientCredentialsArgsForCall = append(fake.setUAAClientCredentialsArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SetUAAClientCredentials", []interface{}{arg1, arg2})
	fake.setUAAClientCredentialsMutex.Unlock()
	if fake.SetUAAClientCredentialsStub != nil {
		fake.SetUAAClientCredentialsStub(arg1, arg2)
	}
}

func (fake *FakeConfig) SetUAAClientCredentialsCallCount() int {
	fake.setUAAClientCredentialsMutex.RLock()
	defer fake.setUAAClientCredentialsMutex.RUnlock()
	return len(fake.setUAAClientCredentialsArgsForCall)
}

func (fake *FakeConfig) SetUAAClientCredentialsCalls(stub func(string, string)) {
	fake.setUAAClientCredentialsMutex.Lock()
	defer fake.setUAAClientCredentialsMutex.Unlock()
	fake.SetUAAClientCredentialsStub = stub
}

func (fake *FakeConfig) SetUAAClientCredentialsArgsForCall(i int) (string, string) {
	fake.setUAAClientCredentialsMutex.RLock()
	defer fake.setUAAClientCredentialsMutex.RUnlock()
	argsForCall := fake.setUAAClientCredentialsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConfig) SetUAAEndpoint(arg1 string) {
	fake.setUAAEndpointMutex.Lock()
	fake.setUAAEndpointArgsForCall = append(fake.setUAAEndpointArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetUAAEndpoint", []interface{}{arg1})
	fake.setUAAEndpointMutex.Unlock()
	if fake.SetUAAEndpointStub != nil {
		fake.SetUAAEndpointStub(arg1)
	}
}

func (fake *FakeConfig) SetUAAEndpointCallCount() int {
	fake.setUAAEndpointMutex.RLock()
	defer fake.setUAAEndpointMutex.RUnlock()
	return len(fake.setUAAEndpointArgsForCall)
}

func (fake *FakeConfig) SetUAAEndpointCalls(stub func(string)) {
	fake.setUAAEndpointMutex.Lock()
	defer fake.setUAAEndpointMutex.Unlock()
	fake.SetUAAEndpointStub = stub
}

func (fake *FakeConfig) SetUAAEndpointArgsForCall(i int) string {
	fake.setUAAEndpointMutex.RLock()
	defer fake.setUAAEndpointMutex.RUnlock()
	argsForCall := fake.setUAAEndpointArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConfig) SetUAAGrantType(arg1 string) {
	fake.setUAAGrantTypeMutex.Lock()
	fake.setUAAGrantTypeArgsForCall = append(fake.setUAAGrantTypeArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetUAAGrantType", []interface{}{arg1})
	fake.setUAAGrantTypeMutex.Unlock()
	if fake.SetUAAGrantTypeStub != nil {
		fake.SetUAAGrantTypeStub(arg1)
	}
}

func (fake *FakeConfig) SetUAAGrantTypeCallCount() int {
	fake.setUAAGrantTypeMutex.RLock()
	defer fake.setUAAGrantTypeMutex.RUnlock()
	return len(fake.setUAAGrantTypeArgsForCall)
}

func (fake *FakeConfig) SetUAAGrantTypeCalls(stub func(string)) {
	fake.setUAAGrantTypeMutex.Lock()
	defer fake.setUAAGrantTypeMutex.Unlock()
	fake.SetUAAGrantTypeStub = stub
}

func (fake *FakeConfig) SetUAAGrantTypeArgsForCall(i int) string {
	fake.setUAAGrantTypeMutex.RLock()
	defer fake.setUAAGrantTypeMutex.RUnlock()
	argsForCall := fake.setUAAGrantTypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConfig) SkipSSLValidation() bool {
	fake.skipSSLValidationMutex.Lock()
	ret, specificReturn := fake.skipSSLValidationReturnsOnCall[len(fake.skipSSLValidationArgsForCall)]
	fake.skipSSLValidationArgsForCall = append(fake.skipSSLValidationArgsForCall, struct {
	}{})
	fake.recordInvocation("SkipSSLValidation", []interface{}{})
	fake.skipSSLValidationMutex.Unlock()
	if fake.SkipSSLValidationStub != nil {
		return fake.SkipSSLValidationStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.skipSSLValidationReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) SkipSSLValidationCallCount() int {
	fake.skipSSLValidationMutex.RLock()
	defer fake.skipSSLValidationMutex.RUnlock()
	return len(fake.skipSSLValidationArgsForCall)
}

func (fake *FakeConfig) SkipSSLValidationCalls(stub func() bool) {
	fake.skipSSLValidationMutex.Lock()
	defer fake.skipSSLValidationMutex.Unlock()
	fake.SkipSSLValidationStub = stub
}

func (fake *FakeConfig) SkipSSLValidationReturns(result1 bool) {
	fake.skipSSLValidationMutex.Lock()
	defer fake.skipSSLValidationMutex.Unlock()
	fake.SkipSSLValidationStub = nil
	fake.skipSSLValidationReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) SkipSSLValidationReturnsOnCall(i int, result1 bool) {
	fake.skipSSLValidationMutex.Lock()
	defer fake.skipSSLValidationMutex.Unlock()
	fake.SkipSSLValidationStub = nil
	if fake.skipSSLValidationReturnsOnCall == nil {
		fake.skipSSLValidationReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.skipSSLValidationReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) StagingTimeout() time.Duration {
	fake.stagingTimeoutMutex.Lock()
	ret, specificReturn := fake.stagingTimeoutReturnsOnCall[len(fake.stagingTimeoutArgsForCall)]
	fake.stagingTimeoutArgsForCall = append(fake.stagingTimeoutArgsForCall, struct {
	}{})
	fake.recordInvocation("StagingTimeout", []interface{}{})
	fake.stagingTimeoutMutex.Unlock()
	if fake.StagingTimeoutStub != nil {
		return fake.StagingTimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.stagingTimeoutReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) StagingTimeoutCallCount() int {
	fake.stagingTimeoutMutex.RLock()
	defer fake.stagingTimeoutMutex.RUnlock()
	return len(fake.stagingTimeoutArgsForCall)
}

func (fake *FakeConfig) StagingTimeoutCalls(stub func() time.Duration) {
	fake.stagingTimeoutMutex.Lock()
	defer fake.stagingTimeoutMutex.Unlock()
	fake.StagingTimeoutStub = stub
}

func (fake *FakeConfig) StagingTimeoutReturns(result1 time.Duration) {
	fake.stagingTimeoutMutex.Lock()
	defer fake.stagingTimeoutMutex.Unlock()
	fake.StagingTimeoutStub = nil
	fake.stagingTimeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) StagingTimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.stagingTimeoutMutex.Lock()
	defer fake.stagingTimeoutMutex.Unlock()
	fake.StagingTimeoutStub = nil
	if fake.stagingTimeoutReturnsOnCall == nil {
		fake.stagingTimeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.stagingTimeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) StartupTimeout() time.Duration {
	fake.startupTimeoutMutex.Lock()
	ret, specificReturn := fake.startupTimeoutReturnsOnCall[len(fake.startupTimeoutArgsForCall)]
	fake.startupTimeoutArgsForCall = append(fake.startupTimeoutArgsForCall, struct {
	}{})
	fake.recordInvocation("StartupTimeout", []interface{}{})
	fake.startupTimeoutMutex.Unlock()
	if fake.StartupTimeoutStub != nil {
		return fake.StartupTimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.startupTimeoutReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) StartupTimeoutCallCount() int {
	fake.startupTimeoutMutex.RLock()
	defer fake.startupTimeoutMutex.RUnlock()
	return len(fake.startupTimeoutArgsForCall)
}

func (fake *FakeConfig) StartupTimeoutCalls(stub func() time.Duration) {
	fake.startupTimeoutMutex.Lock()
	defer fake.startupTimeoutMutex.Unlock()
	fake.StartupTimeoutStub = stub
}

func (fake *FakeConfig) StartupTimeoutReturns(result1 time.Duration) {
	fake.startupTimeoutMutex.Lock()
	defer fake.startupTimeoutMutex.Unlock()
	fake.StartupTimeoutStub = nil
	fake.startupTimeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) StartupTimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.startupTimeoutMutex.Lock()
	defer fake.startupTimeoutMutex.Unlock()
	fake.StartupTimeoutStub = nil
	if fake.startupTimeoutReturnsOnCall == nil {
		fake.startupTimeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.startupTimeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) Target() string {
	fake.targetMutex.Lock()
	ret, specificReturn := fake.targetReturnsOnCall[len(fake.targetArgsForCall)]
	fake.targetArgsForCall = append(fake.targetArgsForCall, struct {
	}{})
	fake.recordInvocation("Target", []interface{}{})
	fake.targetMutex.Unlock()
	if fake.TargetStub != nil {
		return fake.TargetStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.targetReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) TargetCallCount() int {
	fake.targetMutex.RLock()
	defer fake.targetMutex.RUnlock()
	return len(fake.targetArgsForCall)
}

func (fake *FakeConfig) TargetCalls(stub func() string) {
	fake.targetMutex.Lock()
	defer fake.targetMutex.Unlock()
	fake.TargetStub = stub
}

func (fake *FakeConfig) TargetReturns(result1 string) {
	fake.targetMutex.Lock()
	defer fake.targetMutex.Unlock()
	fake.TargetStub = nil
	fake.targetReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) TargetReturnsOnCall(i int, result1 string) {
	fake.targetMutex.Lock()
	defer fake.targetMutex.Unlock()
	fake.TargetStub = nil
	if fake.targetReturnsOnCall == nil {
		fake.targetReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.targetReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) TargetedOrganization() configv3.Organization {
	fake.targetedOrganizationMutex.Lock()
	ret, specificReturn := fake.targetedOrganizationReturnsOnCall[len(fake.targetedOrganizationArgsForCall)]
	fake.targetedOrganizationArgsForCall = append(fake.targetedOrganizationArgsForCall, struct {
	}{})
	fake.recordInvocation("TargetedOrganization", []interface{}{})
	fake.targetedOrganizationMutex.Unlock()
	if fake.TargetedOrganizationStub != nil {
		return fake.TargetedOrganizationStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.targetedOrganizationReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) TargetedOrganizationCallCount() int {
	fake.targetedOrganizationMutex.RLock()
	defer fake.targetedOrganizationMutex.RUnlock()
	return len(fake.targetedOrganizationArgsForCall)
}

func (fake *FakeConfig) TargetedOrganizationCalls(stub func() configv3.Organization) {
	fake.targetedOrganizationMutex.Lock()
	defer fake.targetedOrganizationMutex.Unlock()
	fake.TargetedOrganizationStub = stub
}

func (fake *FakeConfig) TargetedOrganizationReturns(result1 configv3.Organization) {
	fake.targetedOrganizationMutex.Lock()
	defer fake.targetedOrganizationMutex.Unlock()
	fake.TargetedOrganizationStub = nil
	fake.targetedOrganizationReturns = struct {
		result1 configv3.Organization
	}{result1}
}

func (fake *FakeConfig) TargetedOrganizationReturnsOnCall(i int, result1 configv3.Organization) {
	fake.targetedOrganizationMutex.Lock()
	defer fake.targetedOrganizationMutex.Unlock()
	fake.TargetedOrganizationStub = nil
	if fake.targetedOrganizationReturnsOnCall == nil {
		fake.targetedOrganizationReturnsOnCall = make(map[int]struct {
			result1 configv3.Organization
		})
	}
	fake.targetedOrganizationReturnsOnCall[i] = struct {
		result1 configv3.Organization
	}{result1}
}

func (fake *FakeConfig) TargetedOrganizationName() string {
	fake.targetedOrganizationNameMutex.Lock()
	ret, specificReturn := fake.targetedOrganizationNameReturnsOnCall[len(fake.targetedOrganizationNameArgsForCall)]
	fake.targetedOrganizationNameArgsForCall = append(fake.targetedOrganizationNameArgsForCall, struct {
	}{})
	fake.recordInvocation("TargetedOrganizationName", []interface{}{})
	fake.targetedOrganizationNameMutex.Unlock()
	if fake.TargetedOrganizationNameStub != nil {
		return fake.TargetedOrganizationNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.targetedOrganizationNameReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) TargetedOrganizationNameCallCount() int {
	fake.targetedOrganizationNameMutex.RLock()
	defer fake.targetedOrganizationNameMutex.RUnlock()
	return len(fake.targetedOrganizationNameArgsForCall)
}

func (fake *FakeConfig) TargetedOrganizationNameCalls(stub func() string) {
	fake.targetedOrganizationNameMutex.Lock()
	defer fake.targetedOrganizationNameMutex.Unlock()
	fake.TargetedOrganizationNameStub = stub
}

func (fake *FakeConfig) TargetedOrganizationNameReturns(result1 string) {
	fake.targetedOrganizationNameMutex.Lock()
	defer fake.targetedOrganizationNameMutex.Unlock()
	fake.TargetedOrganizationNameStub = nil
	fake.targetedOrganizationNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) TargetedOrganizationNameReturnsOnCall(i int, result1 string) {
	fake.targetedOrganizationNameMutex.Lock()
	defer fake.targetedOrganizationNameMutex.Unlock()
	fake.TargetedOrganizationNameStub = nil
	if fake.targetedOrganizationNameReturnsOnCall == nil {
		fake.targetedOrganizationNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.targetedOrganizationNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) TargetedSpace() configv3.Space {
	fake.targetedSpaceMutex.Lock()
	ret, specificReturn := fake.targetedSpaceReturnsOnCall[len(fake.targetedSpaceArgsForCall)]
	fake.targetedSpaceArgsForCall = append(fake.targetedSpaceArgsForCall, struct {
	}{})
	fake.recordInvocation("TargetedSpace", []interface{}{})
	fake.targetedSpaceMutex.Unlock()
	if fake.TargetedSpaceStub != nil {
		return fake.TargetedSpaceStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.targetedSpaceReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) TargetedSpaceCallCount() int {
	fake.targetedSpaceMutex.RLock()
	defer fake.targetedSpaceMutex.RUnlock()
	return len(fake.targetedSpaceArgsForCall)
}

func (fake *FakeConfig) TargetedSpaceCalls(stub func() configv3.Space) {
	fake.targetedSpaceMutex.Lock()
	defer fake.targetedSpaceMutex.Unlock()
	fake.TargetedSpaceStub = stub
}

func (fake *FakeConfig) TargetedSpaceReturns(result1 configv3.Space) {
	fake.targetedSpaceMutex.Lock()
	defer fake.targetedSpaceMutex.Unlock()
	fake.TargetedSpaceStub = nil
	fake.targetedSpaceReturns = struct {
		result1 configv3.Space
	}{result1}
}

func (fake *FakeConfig) TargetedSpaceReturnsOnCall(i int, result1 configv3.Space) {
	fake.targetedSpaceMutex.Lock()
	defer fake.targetedSpaceMutex.Unlock()
	fake.TargetedSpaceStub = nil
	if fake.targetedSpaceReturnsOnCall == nil {
		fake.targetedSpaceReturnsOnCall = make(map[int]struct {
			result1 configv3.Space
		})
	}
	fake.targetedSpaceReturnsOnCall[i] = struct {
		result1 configv3.Space
	}{result1}
}

func (fake *FakeConfig) UAADisableKeepAlives() bool {
	fake.uAADisableKeepAlivesMutex.Lock()
	ret, specificReturn := fake.uAADisableKeepAlivesReturnsOnCall[len(fake.uAADisableKeepAlivesArgsForCall)]
	fake.uAADisableKeepAlivesArgsForCall = append(fake.uAADisableKeepAlivesArgsForCall, struct {
	}{})
	fake.recordInvocation("UAADisableKeepAlives", []interface{}{})
	fake.uAADisableKeepAlivesMutex.Unlock()
	if fake.UAADisableKeepAlivesStub != nil {
		return fake.UAADisableKeepAlivesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uAADisableKeepAlivesReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) UAADisableKeepAlivesCallCount() int {
	fake.uAADisableKeepAlivesMutex.RLock()
	defer fake.uAADisableKeepAlivesMutex.RUnlock()
	return len(fake.uAADisableKeepAlivesArgsForCall)
}

func (fake *FakeConfig) UAADisableKeepAlivesCalls(stub func() bool) {
	fake.uAADisableKeepAlivesMutex.Lock()
	defer fake.uAADisableKeepAlivesMutex.Unlock()
	fake.UAADisableKeepAlivesStub = stub
}

func (fake *FakeConfig) UAADisableKeepAlivesReturns(result1 bool) {
	fake.uAADisableKeepAlivesMutex.Lock()
	defer fake.uAADisableKeepAlivesMutex.Unlock()
	fake.UAADisableKeepAlivesStub = nil
	fake.uAADisableKeepAlivesReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) UAADisableKeepAlivesReturnsOnCall(i int, result1 bool) {
	fake.uAADisableKeepAlivesMutex.Lock()
	defer fake.uAADisableKeepAlivesMutex.Unlock()
	fake.UAADisableKeepAlivesStub = nil
	if fake.uAADisableKeepAlivesReturnsOnCall == nil {
		fake.uAADisableKeepAlivesReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.uAADisableKeepAlivesReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) UAAGrantType() string {
	fake.uAAGrantTypeMutex.Lock()
	ret, specificReturn := fake.uAAGrantTypeReturnsOnCall[len(fake.uAAGrantTypeArgsForCall)]
	fake.uAAGrantTypeArgsForCall = append(fake.uAAGrantTypeArgsForCall, struct {
	}{})
	fake.recordInvocation("UAAGrantType", []interface{}{})
	fake.uAAGrantTypeMutex.Unlock()
	if fake.UAAGrantTypeStub != nil {
		return fake.UAAGrantTypeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uAAGrantTypeReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) UAAGrantTypeCallCount() int {
	fake.uAAGrantTypeMutex.RLock()
	defer fake.uAAGrantTypeMutex.RUnlock()
	return len(fake.uAAGrantTypeArgsForCall)
}

func (fake *FakeConfig) UAAGrantTypeCalls(stub func() string) {
	fake.uAAGrantTypeMutex.Lock()
	defer fake.uAAGrantTypeMutex.Unlock()
	fake.UAAGrantTypeStub = stub
}

func (fake *FakeConfig) UAAGrantTypeReturns(result1 string) {
	fake.uAAGrantTypeMutex.Lock()
	defer fake.uAAGrantTypeMutex.Unlock()
	fake.UAAGrantTypeStub = nil
	fake.uAAGrantTypeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAGrantTypeReturnsOnCall(i int, result1 string) {
	fake.uAAGrantTypeMutex.Lock()
	defer fake.uAAGrantTypeMutex.Unlock()
	fake.UAAGrantTypeStub = nil
	if fake.uAAGrantTypeReturnsOnCall == nil {
		fake.uAAGrantTypeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uAAGrantTypeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClient() string {
	fake.uAAOAuthClientMutex.Lock()
	ret, specificReturn := fake.uAAOAuthClientReturnsOnCall[len(fake.uAAOAuthClientArgsForCall)]
	fake.uAAOAuthClientArgsForCall = append(fake.uAAOAuthClientArgsForCall, struct {
	}{})
	fake.recordInvocation("UAAOAuthClient", []interface{}{})
	fake.uAAOAuthClientMutex.Unlock()
	if fake.UAAOAuthClientStub != nil {
		return fake.UAAOAuthClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uAAOAuthClientReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) UAAOAuthClientCallCount() int {
	fake.uAAOAuthClientMutex.RLock()
	defer fake.uAAOAuthClientMutex.RUnlock()
	return len(fake.uAAOAuthClientArgsForCall)
}

func (fake *FakeConfig) UAAOAuthClientCalls(stub func() string) {
	fake.uAAOAuthClientMutex.Lock()
	defer fake.uAAOAuthClientMutex.Unlock()
	fake.UAAOAuthClientStub = stub
}

func (fake *FakeConfig) UAAOAuthClientReturns(result1 string) {
	fake.uAAOAuthClientMutex.Lock()
	defer fake.uAAOAuthClientMutex.Unlock()
	fake.UAAOAuthClientStub = nil
	fake.uAAOAuthClientReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClientReturnsOnCall(i int, result1 string) {
	fake.uAAOAuthClientMutex.Lock()
	defer fake.uAAOAuthClientMutex.Unlock()
	fake.UAAOAuthClientStub = nil
	if fake.uAAOAuthClientReturnsOnCall == nil {
		fake.uAAOAuthClientReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uAAOAuthClientReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClientSecret() string {
	fake.uAAOAuthClientSecretMutex.Lock()
	ret, specificReturn := fake.uAAOAuthClientSecretReturnsOnCall[len(fake.uAAOAuthClientSecretArgsForCall)]
	fake.uAAOAuthClientSecretArgsForCall = append(fake.uAAOAuthClientSecretArgsForCall, struct {
	}{})
	fake.recordInvocation("UAAOAuthClientSecret", []interface{}{})
	fake.uAAOAuthClientSecretMutex.Unlock()
	if fake.UAAOAuthClientSecretStub != nil {
		return fake.UAAOAuthClientSecretStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uAAOAuthClientSecretReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) UAAOAuthClientSecretCallCount() int {
	fake.uAAOAuthClientSecretMutex.RLock()
	defer fake.uAAOAuthClientSecretMutex.RUnlock()
	return len(fake.uAAOAuthClientSecretArgsForCall)
}

func (fake *FakeConfig) UAAOAuthClientSecretCalls(stub func() string) {
	fake.uAAOAuthClientSecretMutex.Lock()
	defer fake.uAAOAuthClientSecretMutex.Unlock()
	fake.UAAOAuthClientSecretStub = stub
}

func (fake *FakeConfig) UAAOAuthClientSecretReturns(result1 string) {
	fake.uAAOAuthClientSecretMutex.Lock()
	defer fake.uAAOAuthClientSecretMutex.Unlock()
	fake.UAAOAuthClientSecretStub = nil
	fake.uAAOAuthClientSecretReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClientSecretReturnsOnCall(i int, result1 string) {
	fake.uAAOAuthClientSecretMutex.Lock()
	defer fake.uAAOAuthClientSecretMutex.Unlock()
	fake.UAAOAuthClientSecretStub = nil
	if fake.uAAOAuthClientSecretReturnsOnCall == nil {
		fake.uAAOAuthClientSecretReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uAAOAuthClientSecretReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UnsetOrganizationAndSpaceInformation() {
	fake.unsetOrganizationAndSpaceInformationMutex.Lock()
	fake.unsetOrganizationAndSpaceInformationArgsForCall = append(fake.unsetOrganizationAndSpaceInformationArgsForCall, struct {
	}{})
	fake.recordInvocation("UnsetOrganizationAndSpaceInformation", []interface{}{})
	fake.unsetOrganizationAndSpaceInformationMutex.Unlock()
	if fake.UnsetOrganizationAndSpaceInformationStub != nil {
		fake.UnsetOrganizationAndSpaceInformationStub()
	}
}

func (fake *FakeConfig) UnsetOrganizationAndSpaceInformationCallCount() int {
	fake.unsetOrganizationAndSpaceInformationMutex.RLock()
	defer fake.unsetOrganizationAndSpaceInformationMutex.RUnlock()
	return len(fake.unsetOrganizationAndSpaceInformationArgsForCall)
}

func (fake *FakeConfig) UnsetOrganizationAndSpaceInformationCalls(stub func()) {
	fake.unsetOrganizationAndSpaceInformationMutex.Lock()
	defer fake.unsetOrganizationAndSpaceInformationMutex.Unlock()
	fake.UnsetOrganizationAndSpaceInformationStub = stub
}

func (fake *FakeConfig) UnsetSpaceInformation() {
	fake.unsetSpaceInformationMutex.Lock()
	fake.unsetSpaceInformationArgsForCall = append(fake.unsetSpaceInformationArgsForCall, struct {
	}{})
	fake.recordInvocation("UnsetSpaceInformation", []interface{}{})
	fake.unsetSpaceInformationMutex.Unlock()
	if fake.UnsetSpaceInformationStub != nil {
		fake.UnsetSpaceInformationStub()
	}
}

func (fake *FakeConfig) UnsetSpaceInformationCallCount() int {
	fake.unsetSpaceInformationMutex.RLock()
	defer fake.unsetSpaceInformationMutex.RUnlock()
	return len(fake.unsetSpaceInformationArgsForCall)
}

func (fake *FakeConfig) UnsetSpaceInformationCalls(stub func()) {
	fake.unsetSpaceInformationMutex.Lock()
	defer fake.unsetSpaceInformationMutex.Unlock()
	fake.UnsetSpaceInformationStub = stub
}

func (fake *FakeConfig) UnsetUserInformation() {
	fake.unsetUserInformationMutex.Lock()
	fake.unsetUserInformationArgsForCall = append(fake.unsetUserInformationArgsForCall, struct {
	}{})
	fake.recordInvocation("UnsetUserInformation", []interface{}{})
	fake.unsetUserInformationMutex.Unlock()
	if fake.UnsetUserInformationStub != nil {
		fake.UnsetUserInformationStub()
	}
}

func (fake *FakeConfig) UnsetUserInformationCallCount() int {
	fake.unsetUserInformationMutex.RLock()
	defer fake.unsetUserInformationMutex.RUnlock()
	return len(fake.unsetUserInformationArgsForCall)
}

func (fake *FakeConfig) UnsetUserInformationCalls(stub func()) {
	fake.unsetUserInformationMutex.Lock()
	defer fake.unsetUserInformationMutex.Unlock()
	fake.UnsetUserInformationStub = stub
}

func (fake *FakeConfig) Verbose() (bool, []string) {
	fake.verboseMutex.Lock()
	ret, specificReturn := fake.verboseReturnsOnCall[len(fake.verboseArgsForCall)]
	fake.verboseArgsForCall = append(fake.verboseArgsForCall, struct {
	}{})
	fake.recordInvocation("Verbose", []interface{}{})
	fake.verboseMutex.Unlock()
	if fake.VerboseStub != nil {
		return fake.VerboseStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.verboseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConfig) VerboseCallCount() int {
	fake.verboseMutex.RLock()
	defer fake.verboseMutex.RUnlock()
	return len(fake.verboseArgsForCall)
}

func (fake *FakeConfig) VerboseCalls(stub func() (bool, []string)) {
	fake.verboseMutex.Lock()
	defer fake.verboseMutex.Unlock()
	fake.VerboseStub = stub
}

func (fake *FakeConfig) VerboseReturns(result1 bool, result2 []string) {
	fake.verboseMutex.Lock()
	defer fake.verboseMutex.Unlock()
	fake.VerboseStub = nil
	fake.verboseReturns = struct {
		result1 bool
		result2 []string
	}{result1, result2}
}

func (fake *FakeConfig) VerboseReturnsOnCall(i int, result1 bool, result2 []string) {
	fake.verboseMutex.Lock()
	defer fake.verboseMutex.Unlock()
	fake.VerboseStub = nil
	if fake.verboseReturnsOnCall == nil {
		fake.verboseReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 []string
		})
	}
	fake.verboseReturnsOnCall[i] = struct {
		result1 bool
		result2 []string
	}{result1, result2}
}

func (fake *FakeConfig) WritePluginConfig() error {
	fake.writePluginConfigMutex.Lock()
	ret, specificReturn := fake.writePluginConfigReturnsOnCall[len(fake.writePluginConfigArgsForCall)]
	fake.writePluginConfigArgsForCall = append(fake.writePluginConfigArgsForCall, struct {
	}{})
	fake.recordInvocation("WritePluginConfig", []interface{}{})
	fake.writePluginConfigMutex.Unlock()
	if fake.WritePluginConfigStub != nil {
		return fake.WritePluginConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.writePluginConfigReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) WritePluginConfigCallCount() int {
	fake.writePluginConfigMutex.RLock()
	defer fake.writePluginConfigMutex.RUnlock()
	return len(fake.writePluginConfigArgsForCall)
}

func (fake *FakeConfig) WritePluginConfigCalls(stub func() error) {
	fake.writePluginConfigMutex.Lock()
	defer fake.writePluginConfigMutex.Unlock()
	fake.WritePluginConfigStub = stub
}

func (fake *FakeConfig) WritePluginConfigReturns(result1 error) {
	fake.writePluginConfigMutex.Lock()
	defer fake.writePluginConfigMutex.Unlock()
	fake.WritePluginConfigStub = nil
	fake.writePluginConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConfig) WritePluginConfigReturnsOnCall(i int, result1 error) {
	fake.writePluginConfigMutex.Lock()
	defer fake.writePluginConfigMutex.Unlock()
	fake.WritePluginConfigStub = nil
	if fake.writePluginConfigReturnsOnCall == nil {
		fake.writePluginConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writePluginConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConfig) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.aPIVersionMutex.RLock()
	defer fake.aPIVersionMutex.RUnlock()
	fake.accessTokenMutex.RLock()
	defer fake.accessTokenMutex.RUnlock()
	fake.addPluginMutex.RLock()
	defer fake.addPluginMutex.RUnlock()
	fake.addPluginRepositoryMutex.RLock()
	defer fake.addPluginRepositoryMutex.RUnlock()
	fake.binaryNameMutex.RLock()
	defer fake.binaryNameMutex.RUnlock()
	fake.binaryVersionMutex.RLock()
	defer fake.binaryVersionMutex.RUnlock()
	fake.cFPasswordMutex.RLock()
	defer fake.cFPasswordMutex.RUnlock()
	fake.cFUsernameMutex.RLock()
	defer fake.cFUsernameMutex.RUnlock()
	fake.colorEnabledMutex.RLock()
	defer fake.colorEnabledMutex.RUnlock()
	fake.currentUserMutex.RLock()
	defer fake.currentUserMutex.RUnlock()
	fake.currentUserNameMutex.RLock()
	defer fake.currentUserNameMutex.RUnlock()
	fake.dialTimeoutMutex.RLock()
	defer fake.dialTimeoutMutex.RUnlock()
	fake.dockerPasswordMutex.RLock()
	defer fake.dockerPasswordMutex.RUnlock()
	fake.experimentalMutex.RLock()
	defer fake.experimentalMutex.RUnlock()
	fake.getPluginMutex.RLock()
	defer fake.getPluginMutex.RUnlock()
	fake.getPluginCaseInsensitiveMutex.RLock()
	defer fake.getPluginCaseInsensitiveMutex.RUnlock()
	fake.hasTargetedOrganizationMutex.RLock()
	defer fake.hasTargetedOrganizationMutex.RUnlock()
	fake.hasTargetedSpaceMutex.RLock()
	defer fake.hasTargetedSpaceMutex.RUnlock()
	fake.localeMutex.RLock()
	defer fake.localeMutex.RUnlock()
	fake.minCLIVersionMutex.RLock()
	defer fake.minCLIVersionMutex.RUnlock()
	fake.nOAARequestRetryCountMutex.RLock()
	defer fake.nOAARequestRetryCountMutex.RUnlock()
	fake.overallPollingTimeoutMutex.RLock()
	defer fake.overallPollingTimeoutMutex.RUnlock()
	fake.pluginHomeMutex.RLock()
	defer fake.pluginHomeMutex.RUnlock()
	fake.pluginRepositoriesMutex.RLock()
	defer fake.pluginRepositoriesMutex.RUnlock()
	fake.pluginsMutex.RLock()
	defer fake.pluginsMutex.RUnlock()
	fake.pollingIntervalMutex.RLock()
	defer fake.pollingIntervalMutex.RUnlock()
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	fake.removePluginMutex.RLock()
	defer fake.removePluginMutex.RUnlock()
	fake.requestRetryCountMutex.RLock()
	defer fake.requestRetryCountMutex.RUnlock()
	fake.routingEndpointMutex.RLock()
	defer fake.routingEndpointMutex.RUnlock()
	fake.sSHOAuthClientMutex.RLock()
	defer fake.sSHOAuthClientMutex.RUnlock()
	fake.setAccessTokenMutex.RLock()
	defer fake.setAccessTokenMutex.RUnlock()
	fake.setOrganizationInformationMutex.RLock()
	defer fake.setOrganizationInformationMutex.RUnlock()
	fake.setRefreshTokenMutex.RLock()
	defer fake.setRefreshTokenMutex.RUnlock()
	fake.setSpaceInformationMutex.RLock()
	defer fake.setSpaceInformationMutex.RUnlock()
	fake.setTargetInformationMutex.RLock()
	defer fake.setTargetInformationMutex.RUnlock()
	fake.setTokenInformationMutex.RLock()
	defer fake.setTokenInformationMutex.RUnlock()
	fake.setUAAClientCredentialsMutex.RLock()
	defer fake.setUAAClientCredentialsMutex.RUnlock()
	fake.setUAAEndpointMutex.RLock()
	defer fake.setUAAEndpointMutex.RUnlock()
	fake.setUAAGrantTypeMutex.RLock()
	defer fake.setUAAGrantTypeMutex.RUnlock()
	fake.skipSSLValidationMutex.RLock()
	defer fake.skipSSLValidationMutex.RUnlock()
	fake.stagingTimeoutMutex.RLock()
	defer fake.stagingTimeoutMutex.RUnlock()
	fake.startupTimeoutMutex.RLock()
	defer fake.startupTimeoutMutex.RUnlock()
	fake.targetMutex.RLock()
	defer fake.targetMutex.RUnlock()
	fake.targetedOrganizationMutex.RLock()
	defer fake.targetedOrganizationMutex.RUnlock()
	fake.targetedOrganizationNameMutex.RLock()
	defer fake.targetedOrganizationNameMutex.RUnlock()
	fake.targetedSpaceMutex.RLock()
	defer fake.targetedSpaceMutex.RUnlock()
	fake.uAADisableKeepAlivesMutex.RLock()
	defer fake.uAADisableKeepAlivesMutex.RUnlock()
	fake.uAAGrantTypeMutex.RLock()
	defer fake.uAAGrantTypeMutex.RUnlock()
	fake.uAAOAuthClientMutex.RLock()
	defer fake.uAAOAuthClientMutex.RUnlock()
	fake.uAAOAuthClientSecretMutex.RLock()
	defer fake.uAAOAuthClientSecretMutex.RUnlock()
	fake.unsetOrganizationAndSpaceInformationMutex.RLock()
	defer fake.unsetOrganizationAndSpaceInformationMutex.RUnlock()
	fake.unsetSpaceInformationMutex.RLock()
	defer fake.unsetSpaceInformationMutex.RUnlock()
	fake.unsetUserInformationMutex.RLock()
	defer fake.unsetUserInformationMutex.RUnlock()
	fake.verboseMutex.RLock()
	defer fake.verboseMutex.RUnlock()
	fake.writePluginConfigMutex.RLock()
	defer fake.writePluginConfigMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeConfig) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ command.Config = new(FakeConfig)
