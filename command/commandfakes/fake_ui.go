// Code generated by counterfeiter. DO NOT EDIT.
package commandfakes

import (
	"io"
	"sync"
	"time"

	"code.cloudfoundry.org/cli/command"
	"code.cloudfoundry.org/cli/util/ui"
)

type FakeUI struct {
	DeferTextStub        func(string, ...map[string]interface{})
	deferTextMutex       sync.RWMutex
	deferTextArgsForCall []struct {
		arg1 string
		arg2 []map[string]interface{}
	}
	DisplayBoolPromptStub        func(bool, string, ...map[string]interface{}) (bool, error)
	displayBoolPromptMutex       sync.RWMutex
	displayBoolPromptArgsForCall []struct {
		arg1 bool
		arg2 string
		arg3 []map[string]interface{}
	}
	displayBoolPromptReturns struct {
		result1 bool
		result2 error
	}
	displayBoolPromptReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DisplayChangesForPushStub        func([]ui.Change) error
	displayChangesForPushMutex       sync.RWMutex
	displayChangesForPushArgsForCall []struct {
		arg1 []ui.Change
	}
	displayChangesForPushReturns struct {
		result1 error
	}
	displayChangesForPushReturnsOnCall map[int]struct {
		result1 error
	}
	DisplayDeprecationWarningStub        func()
	displayDeprecationWarningMutex       sync.RWMutex
	displayDeprecationWarningArgsForCall []struct {
	}
	DisplayDiffAdditionStub        func(string, int, bool)
	displayDiffAdditionMutex       sync.RWMutex
	displayDiffAdditionArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 bool
	}
	DisplayDiffRemovalStub        func(string, int, bool)
	displayDiffRemovalMutex       sync.RWMutex
	displayDiffRemovalArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 bool
	}
	DisplayDiffUnchangedStub        func(string, int, bool)
	displayDiffUnchangedMutex       sync.RWMutex
	displayDiffUnchangedArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 bool
	}
	DisplayErrorStub        func(error)
	displayErrorMutex       sync.RWMutex
	displayErrorArgsForCall []struct {
		arg1 error
	}
	DisplayFileDeprecationWarningStub        func()
	displayFileDeprecationWarningMutex       sync.RWMutex
	displayFileDeprecationWarningArgsForCall []struct {
	}
	DisplayHeaderStub        func(string)
	displayHeaderMutex       sync.RWMutex
	displayHeaderArgsForCall []struct {
		arg1 string
	}
	DisplayInstancesTableForAppStub        func([][]string)
	displayInstancesTableForAppMutex       sync.RWMutex
	displayInstancesTableForAppArgsForCall []struct {
		arg1 [][]string
	}
	DisplayJSONStub        func(string, interface{}) error
	displayJSONMutex       sync.RWMutex
	displayJSONArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	displayJSONReturns struct {
		result1 error
	}
	displayJSONReturnsOnCall map[int]struct {
		result1 error
	}
	DisplayKeyValueTableStub        func(string, [][]string, int)
	displayKeyValueTableMutex       sync.RWMutex
	displayKeyValueTableArgsForCall []struct {
		arg1 string
		arg2 [][]string
		arg3 int
	}
	DisplayKeyValueTableForAppStub        func([][]string)
	displayKeyValueTableForAppMutex       sync.RWMutex
	displayKeyValueTableForAppArgsForCall []struct {
		arg1 [][]string
	}
	DisplayLogMessageStub        func(ui.LogMessage, bool)
	displayLogMessageMutex       sync.RWMutex
	displayLogMessageArgsForCall []struct {
		arg1 ui.LogMessage
		arg2 bool
	}
	DisplayNewlineStub        func()
	displayNewlineMutex       sync.RWMutex
	displayNewlineArgsForCall []struct {
	}
	DisplayNonWrappingTableStub        func(string, [][]string, int)
	displayNonWrappingTableMutex       sync.RWMutex
	displayNonWrappingTableArgsForCall []struct {
		arg1 string
		arg2 [][]string
		arg3 int
	}
	DisplayOKStub        func()
	displayOKMutex       sync.RWMutex
	displayOKArgsForCall []struct {
	}
	DisplayOptionalTextPromptStub        func(string, string, ...map[string]interface{}) (string, error)
	displayOptionalTextPromptMutex       sync.RWMutex
	displayOptionalTextPromptArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []map[string]interface{}
	}
	displayOptionalTextPromptReturns struct {
		result1 string
		result2 error
	}
	displayOptionalTextPromptReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DisplayPasswordPromptStub        func(string, ...map[string]interface{}) (string, error)
	displayPasswordPromptMutex       sync.RWMutex
	displayPasswordPromptArgsForCall []struct {
		arg1 string
		arg2 []map[string]interface{}
	}
	displayPasswordPromptReturns struct {
		result1 string
		result2 error
	}
	displayPasswordPromptReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DisplayTableWithHeaderStub        func(string, [][]string, int)
	displayTableWithHeaderMutex       sync.RWMutex
	displayTableWithHeaderArgsForCall []struct {
		arg1 string
		arg2 [][]string
		arg3 int
	}
	DisplayTextStub        func(string, ...map[string]interface{})
	displayTextMutex       sync.RWMutex
	displayTextArgsForCall []struct {
		arg1 string
		arg2 []map[string]interface{}
	}
	DisplayTextLiteralStub        func(string)
	displayTextLiteralMutex       sync.RWMutex
	displayTextLiteralArgsForCall []struct {
		arg1 string
	}
	DisplayTextMenuStub        func([]string, string, ...map[string]interface{}) (string, error)
	displayTextMenuMutex       sync.RWMutex
	displayTextMenuArgsForCall []struct {
		arg1 []string
		arg2 string
		arg3 []map[string]interface{}
	}
	displayTextMenuReturns struct {
		result1 string
		result2 error
	}
	displayTextMenuReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DisplayTextPromptStub        func(string, ...map[string]interface{}) (string, error)
	displayTextPromptMutex       sync.RWMutex
	displayTextPromptArgsForCall []struct {
		arg1 string
		arg2 []map[string]interface{}
	}
	displayTextPromptReturns struct {
		result1 string
		result2 error
	}
	displayTextPromptReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DisplayTextWithBoldStub        func(string, ...map[string]interface{})
	displayTextWithBoldMutex       sync.RWMutex
	displayTextWithBoldArgsForCall []struct {
		arg1 string
		arg2 []map[string]interface{}
	}
	DisplayTextWithFlavorStub        func(string, ...map[string]interface{})
	displayTextWithFlavorMutex       sync.RWMutex
	displayTextWithFlavorArgsForCall []struct {
		arg1 string
		arg2 []map[string]interface{}
	}
	DisplayWarningStub        func(string, ...map[string]interface{})
	displayWarningMutex       sync.RWMutex
	displayWarningArgsForCall []struct {
		arg1 string
		arg2 []map[string]interface{}
	}
	DisplayWarningsStub        func([]string)
	displayWarningsMutex       sync.RWMutex
	displayWarningsArgsForCall []struct {
		arg1 []string
	}
	GetErrStub        func() io.Writer
	getErrMutex       sync.RWMutex
	getErrArgsForCall []struct {
	}
	getErrReturns struct {
		result1 io.Writer
	}
	getErrReturnsOnCall map[int]struct {
		result1 io.Writer
	}
	GetInStub        func() io.Reader
	getInMutex       sync.RWMutex
	getInArgsForCall []struct {
	}
	getInReturns struct {
		result1 io.Reader
	}
	getInReturnsOnCall map[int]struct {
		result1 io.Reader
	}
	GetOutStub        func() io.Writer
	getOutMutex       sync.RWMutex
	getOutArgsForCall []struct {
	}
	getOutReturns struct {
		result1 io.Writer
	}
	getOutReturnsOnCall map[int]struct {
		result1 io.Writer
	}
	RequestLoggerFileWriterStub        func([]string) *ui.RequestLoggerFileWriter
	requestLoggerFileWriterMutex       sync.RWMutex
	requestLoggerFileWriterArgsForCall []struct {
		arg1 []string
	}
	requestLoggerFileWriterReturns struct {
		result1 *ui.RequestLoggerFileWriter
	}
	requestLoggerFileWriterReturnsOnCall map[int]struct {
		result1 *ui.RequestLoggerFileWriter
	}
	RequestLoggerTerminalDisplayStub        func() *ui.RequestLoggerTerminalDisplay
	requestLoggerTerminalDisplayMutex       sync.RWMutex
	requestLoggerTerminalDisplayArgsForCall []struct {
	}
	requestLoggerTerminalDisplayReturns struct {
		result1 *ui.RequestLoggerTerminalDisplay
	}
	requestLoggerTerminalDisplayReturnsOnCall map[int]struct {
		result1 *ui.RequestLoggerTerminalDisplay
	}
	TranslateTextStub        func(string, ...map[string]interface{}) string
	translateTextMutex       sync.RWMutex
	translateTextArgsForCall []struct {
		arg1 string
		arg2 []map[string]interface{}
	}
	translateTextReturns struct {
		result1 string
	}
	translateTextReturnsOnCall map[int]struct {
		result1 string
	}
	UserFriendlyDateStub        func(time.Time) string
	userFriendlyDateMutex       sync.RWMutex
	userFriendlyDateArgsForCall []struct {
		arg1 time.Time
	}
	userFriendlyDateReturns struct {
		result1 string
	}
	userFriendlyDateReturnsOnCall map[int]struct {
		result1 string
	}
	WriterStub        func() io.Writer
	writerMutex       sync.RWMutex
	writerArgsForCall []struct {
	}
	writerReturns struct {
		result1 io.Writer
	}
	writerReturnsOnCall map[int]struct {
		result1 io.Writer
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUI) DeferText(arg1 string, arg2 ...map[string]interface{}) {
	fake.deferTextMutex.Lock()
	fake.deferTextArgsForCall = append(fake.deferTextArgsForCall, struct {
		arg1 string
		arg2 []map[string]interface{}
	}{arg1, arg2})
	stub := fake.DeferTextStub
	fake.recordInvocation("DeferText", []interface{}{arg1, arg2})
	fake.deferTextMutex.Unlock()
	if stub != nil {
		fake.DeferTextStub(arg1, arg2...)
	}
}

func (fake *FakeUI) DeferTextCallCount() int {
	fake.deferTextMutex.RLock()
	defer fake.deferTextMutex.RUnlock()
	return len(fake.deferTextArgsForCall)
}

func (fake *FakeUI) DeferTextCalls(stub func(string, ...map[string]interface{})) {
	fake.deferTextMutex.Lock()
	defer fake.deferTextMutex.Unlock()
	fake.DeferTextStub = stub
}

func (fake *FakeUI) DeferTextArgsForCall(i int) (string, []map[string]interface{}) {
	fake.deferTextMutex.RLock()
	defer fake.deferTextMutex.RUnlock()
	argsForCall := fake.deferTextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) DisplayBoolPrompt(arg1 bool, arg2 string, arg3 ...map[string]interface{}) (bool, error) {
	fake.displayBoolPromptMutex.Lock()
	ret, specificReturn := fake.displayBoolPromptReturnsOnCall[len(fake.displayBoolPromptArgsForCall)]
	fake.displayBoolPromptArgsForCall = append(fake.displayBoolPromptArgsForCall, struct {
		arg1 bool
		arg2 string
		arg3 []map[string]interface{}
	}{arg1, arg2, arg3})
	stub := fake.DisplayBoolPromptStub
	fakeReturns := fake.displayBoolPromptReturns
	fake.recordInvocation("DisplayBoolPrompt", []interface{}{arg1, arg2, arg3})
	fake.displayBoolPromptMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUI) DisplayBoolPromptCallCount() int {
	fake.displayBoolPromptMutex.RLock()
	defer fake.displayBoolPromptMutex.RUnlock()
	return len(fake.displayBoolPromptArgsForCall)
}

func (fake *FakeUI) DisplayBoolPromptCalls(stub func(bool, string, ...map[string]interface{}) (bool, error)) {
	fake.displayBoolPromptMutex.Lock()
	defer fake.displayBoolPromptMutex.Unlock()
	fake.DisplayBoolPromptStub = stub
}

func (fake *FakeUI) DisplayBoolPromptArgsForCall(i int) (bool, string, []map[string]interface{}) {
	fake.displayBoolPromptMutex.RLock()
	defer fake.displayBoolPromptMutex.RUnlock()
	argsForCall := fake.displayBoolPromptArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUI) DisplayBoolPromptReturns(result1 bool, result2 error) {
	fake.displayBoolPromptMutex.Lock()
	defer fake.displayBoolPromptMutex.Unlock()
	fake.DisplayBoolPromptStub = nil
	fake.displayBoolPromptReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUI) DisplayBoolPromptReturnsOnCall(i int, result1 bool, result2 error) {
	fake.displayBoolPromptMutex.Lock()
	defer fake.displayBoolPromptMutex.Unlock()
	fake.DisplayBoolPromptStub = nil
	if fake.displayBoolPromptReturnsOnCall == nil {
		fake.displayBoolPromptReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.displayBoolPromptReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUI) DisplayChangesForPush(arg1 []ui.Change) error {
	var arg1Copy []ui.Change
	if arg1 != nil {
		arg1Copy = make([]ui.Change, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.displayChangesForPushMutex.Lock()
	ret, specificReturn := fake.displayChangesForPushReturnsOnCall[len(fake.displayChangesForPushArgsForCall)]
	fake.displayChangesForPushArgsForCall = append(fake.displayChangesForPushArgsForCall, struct {
		arg1 []ui.Change
	}{arg1Copy})
	stub := fake.DisplayChangesForPushStub
	fakeReturns := fake.displayChangesForPushReturns
	fake.recordInvocation("DisplayChangesForPush", []interface{}{arg1Copy})
	fake.displayChangesForPushMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUI) DisplayChangesForPushCallCount() int {
	fake.displayChangesForPushMutex.RLock()
	defer fake.displayChangesForPushMutex.RUnlock()
	return len(fake.displayChangesForPushArgsForCall)
}

func (fake *FakeUI) DisplayChangesForPushCalls(stub func([]ui.Change) error) {
	fake.displayChangesForPushMutex.Lock()
	defer fake.displayChangesForPushMutex.Unlock()
	fake.DisplayChangesForPushStub = stub
}

func (fake *FakeUI) DisplayChangesForPushArgsForCall(i int) []ui.Change {
	fake.displayChangesForPushMutex.RLock()
	defer fake.displayChangesForPushMutex.RUnlock()
	argsForCall := fake.displayChangesForPushArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) DisplayChangesForPushReturns(result1 error) {
	fake.displayChangesForPushMutex.Lock()
	defer fake.displayChangesForPushMutex.Unlock()
	fake.DisplayChangesForPushStub = nil
	fake.displayChangesForPushReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUI) DisplayChangesForPushReturnsOnCall(i int, result1 error) {
	fake.displayChangesForPushMutex.Lock()
	defer fake.displayChangesForPushMutex.Unlock()
	fake.DisplayChangesForPushStub = nil
	if fake.displayChangesForPushReturnsOnCall == nil {
		fake.displayChangesForPushReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.displayChangesForPushReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUI) DisplayDeprecationWarning() {
	fake.displayDeprecationWarningMutex.Lock()
	fake.displayDeprecationWarningArgsForCall = append(fake.displayDeprecationWarningArgsForCall, struct {
	}{})
	stub := fake.DisplayDeprecationWarningStub
	fake.recordInvocation("DisplayDeprecationWarning", []interface{}{})
	fake.displayDeprecationWarningMutex.Unlock()
	if stub != nil {
		fake.DisplayDeprecationWarningStub()
	}
}

func (fake *FakeUI) DisplayDeprecationWarningCallCount() int {
	fake.displayDeprecationWarningMutex.RLock()
	defer fake.displayDeprecationWarningMutex.RUnlock()
	return len(fake.displayDeprecationWarningArgsForCall)
}

func (fake *FakeUI) DisplayDeprecationWarningCalls(stub func()) {
	fake.displayDeprecationWarningMutex.Lock()
	defer fake.displayDeprecationWarningMutex.Unlock()
	fake.DisplayDeprecationWarningStub = stub
}

func (fake *FakeUI) DisplayDiffAddition(arg1 string, arg2 int, arg3 bool) {
	fake.displayDiffAdditionMutex.Lock()
	fake.displayDiffAdditionArgsForCall = append(fake.displayDiffAdditionArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.DisplayDiffAdditionStub
	fake.recordInvocation("DisplayDiffAddition", []interface{}{arg1, arg2, arg3})
	fake.displayDiffAdditionMutex.Unlock()
	if stub != nil {
		fake.DisplayDiffAdditionStub(arg1, arg2, arg3)
	}
}

func (fake *FakeUI) DisplayDiffAdditionCallCount() int {
	fake.displayDiffAdditionMutex.RLock()
	defer fake.displayDiffAdditionMutex.RUnlock()
	return len(fake.displayDiffAdditionArgsForCall)
}

func (fake *FakeUI) DisplayDiffAdditionCalls(stub func(string, int, bool)) {
	fake.displayDiffAdditionMutex.Lock()
	defer fake.displayDiffAdditionMutex.Unlock()
	fake.DisplayDiffAdditionStub = stub
}

func (fake *FakeUI) DisplayDiffAdditionArgsForCall(i int) (string, int, bool) {
	fake.displayDiffAdditionMutex.RLock()
	defer fake.displayDiffAdditionMutex.RUnlock()
	argsForCall := fake.displayDiffAdditionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUI) DisplayDiffRemoval(arg1 string, arg2 int, arg3 bool) {
	fake.displayDiffRemovalMutex.Lock()
	fake.displayDiffRemovalArgsForCall = append(fake.displayDiffRemovalArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.DisplayDiffRemovalStub
	fake.recordInvocation("DisplayDiffRemoval", []interface{}{arg1, arg2, arg3})
	fake.displayDiffRemovalMutex.Unlock()
	if stub != nil {
		fake.DisplayDiffRemovalStub(arg1, arg2, arg3)
	}
}

func (fake *FakeUI) DisplayDiffRemovalCallCount() int {
	fake.displayDiffRemovalMutex.RLock()
	defer fake.displayDiffRemovalMutex.RUnlock()
	return len(fake.displayDiffRemovalArgsForCall)
}

func (fake *FakeUI) DisplayDiffRemovalCalls(stub func(string, int, bool)) {
	fake.displayDiffRemovalMutex.Lock()
	defer fake.displayDiffRemovalMutex.Unlock()
	fake.DisplayDiffRemovalStub = stub
}

func (fake *FakeUI) DisplayDiffRemovalArgsForCall(i int) (string, int, bool) {
	fake.displayDiffRemovalMutex.RLock()
	defer fake.displayDiffRemovalMutex.RUnlock()
	argsForCall := fake.displayDiffRemovalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUI) DisplayDiffUnchanged(arg1 string, arg2 int, arg3 bool) {
	fake.displayDiffUnchangedMutex.Lock()
	fake.displayDiffUnchangedArgsForCall = append(fake.displayDiffUnchangedArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.DisplayDiffUnchangedStub
	fake.recordInvocation("DisplayDiffUnchanged", []interface{}{arg1, arg2, arg3})
	fake.displayDiffUnchangedMutex.Unlock()
	if stub != nil {
		fake.DisplayDiffUnchangedStub(arg1, arg2, arg3)
	}
}

func (fake *FakeUI) DisplayDiffUnchangedCallCount() int {
	fake.displayDiffUnchangedMutex.RLock()
	defer fake.displayDiffUnchangedMutex.RUnlock()
	return len(fake.displayDiffUnchangedArgsForCall)
}

func (fake *FakeUI) DisplayDiffUnchangedCalls(stub func(string, int, bool)) {
	fake.displayDiffUnchangedMutex.Lock()
	defer fake.displayDiffUnchangedMutex.Unlock()
	fake.DisplayDiffUnchangedStub = stub
}

func (fake *FakeUI) DisplayDiffUnchangedArgsForCall(i int) (string, int, bool) {
	fake.displayDiffUnchangedMutex.RLock()
	defer fake.displayDiffUnchangedMutex.RUnlock()
	argsForCall := fake.displayDiffUnchangedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUI) DisplayError(arg1 error) {
	fake.displayErrorMutex.Lock()
	fake.displayErrorArgsForCall = append(fake.displayErrorArgsForCall, struct {
		arg1 error
	}{arg1})
	stub := fake.DisplayErrorStub
	fake.recordInvocation("DisplayError", []interface{}{arg1})
	fake.displayErrorMutex.Unlock()
	if stub != nil {
		fake.DisplayErrorStub(arg1)
	}
}

func (fake *FakeUI) DisplayErrorCallCount() int {
	fake.displayErrorMutex.RLock()
	defer fake.displayErrorMutex.RUnlock()
	return len(fake.displayErrorArgsForCall)
}

func (fake *FakeUI) DisplayErrorCalls(stub func(error)) {
	fake.displayErrorMutex.Lock()
	defer fake.displayErrorMutex.Unlock()
	fake.DisplayErrorStub = stub
}

func (fake *FakeUI) DisplayErrorArgsForCall(i int) error {
	fake.displayErrorMutex.RLock()
	defer fake.displayErrorMutex.RUnlock()
	argsForCall := fake.displayErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) DisplayFileDeprecationWarning() {
	fake.displayFileDeprecationWarningMutex.Lock()
	fake.displayFileDeprecationWarningArgsForCall = append(fake.displayFileDeprecationWarningArgsForCall, struct {
	}{})
	stub := fake.DisplayFileDeprecationWarningStub
	fake.recordInvocation("DisplayFileDeprecationWarning", []interface{}{})
	fake.displayFileDeprecationWarningMutex.Unlock()
	if stub != nil {
		fake.DisplayFileDeprecationWarningStub()
	}
}

func (fake *FakeUI) DisplayFileDeprecationWarningCallCount() int {
	fake.displayFileDeprecationWarningMutex.RLock()
	defer fake.displayFileDeprecationWarningMutex.RUnlock()
	return len(fake.displayFileDeprecationWarningArgsForCall)
}

func (fake *FakeUI) DisplayFileDeprecationWarningCalls(stub func()) {
	fake.displayFileDeprecationWarningMutex.Lock()
	defer fake.displayFileDeprecationWarningMutex.Unlock()
	fake.DisplayFileDeprecationWarningStub = stub
}

func (fake *FakeUI) DisplayHeader(arg1 string) {
	fake.displayHeaderMutex.Lock()
	fake.displayHeaderArgsForCall = append(fake.displayHeaderArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DisplayHeaderStub
	fake.recordInvocation("DisplayHeader", []interface{}{arg1})
	fake.displayHeaderMutex.Unlock()
	if stub != nil {
		fake.DisplayHeaderStub(arg1)
	}
}

func (fake *FakeUI) DisplayHeaderCallCount() int {
	fake.displayHeaderMutex.RLock()
	defer fake.displayHeaderMutex.RUnlock()
	return len(fake.displayHeaderArgsForCall)
}

func (fake *FakeUI) DisplayHeaderCalls(stub func(string)) {
	fake.displayHeaderMutex.Lock()
	defer fake.displayHeaderMutex.Unlock()
	fake.DisplayHeaderStub = stub
}

func (fake *FakeUI) DisplayHeaderArgsForCall(i int) string {
	fake.displayHeaderMutex.RLock()
	defer fake.displayHeaderMutex.RUnlock()
	argsForCall := fake.displayHeaderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) DisplayInstancesTableForApp(arg1 [][]string) {
	var arg1Copy [][]string
	if arg1 != nil {
		arg1Copy = make([][]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.displayInstancesTableForAppMutex.Lock()
	fake.displayInstancesTableForAppArgsForCall = append(fake.displayInstancesTableForAppArgsForCall, struct {
		arg1 [][]string
	}{arg1Copy})
	stub := fake.DisplayInstancesTableForAppStub
	fake.recordInvocation("DisplayInstancesTableForApp", []interface{}{arg1Copy})
	fake.displayInstancesTableForAppMutex.Unlock()
	if stub != nil {
		fake.DisplayInstancesTableForAppStub(arg1)
	}
}

func (fake *FakeUI) DisplayInstancesTableForAppCallCount() int {
	fake.displayInstancesTableForAppMutex.RLock()
	defer fake.displayInstancesTableForAppMutex.RUnlock()
	return len(fake.displayInstancesTableForAppArgsForCall)
}

func (fake *FakeUI) DisplayInstancesTableForAppCalls(stub func([][]string)) {
	fake.displayInstancesTableForAppMutex.Lock()
	defer fake.displayInstancesTableForAppMutex.Unlock()
	fake.DisplayInstancesTableForAppStub = stub
}

func (fake *FakeUI) DisplayInstancesTableForAppArgsForCall(i int) [][]string {
	fake.displayInstancesTableForAppMutex.RLock()
	defer fake.displayInstancesTableForAppMutex.RUnlock()
	argsForCall := fake.displayInstancesTableForAppArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) DisplayJSON(arg1 string, arg2 interface{}) error {
	fake.displayJSONMutex.Lock()
	ret, specificReturn := fake.displayJSONReturnsOnCall[len(fake.displayJSONArgsForCall)]
	fake.displayJSONArgsForCall = append(fake.displayJSONArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	fake.recordInvocation("DisplayJSON", []interface{}{arg1, arg2})
	fake.displayJSONMutex.Unlock()
	if fake.DisplayJSONStub != nil {
		return fake.DisplayJSONStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.displayJSONReturns
	return fakeReturns.result1
}

func (fake *FakeUI) DisplayJSONCallCount() int {
	fake.displayJSONMutex.RLock()
	defer fake.displayJSONMutex.RUnlock()
	return len(fake.displayJSONArgsForCall)
}

func (fake *FakeUI) DisplayJSONCalls(stub func(string, interface{}) error) {
	fake.displayJSONMutex.Lock()
	defer fake.displayJSONMutex.Unlock()
	fake.DisplayJSONStub = stub
}

func (fake *FakeUI) DisplayJSONArgsForCall(i int) (string, interface{}) {
	fake.displayJSONMutex.RLock()
	defer fake.displayJSONMutex.RUnlock()
	argsForCall := fake.displayJSONArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) DisplayJSONReturns(result1 error) {
	fake.displayJSONMutex.Lock()
	defer fake.displayJSONMutex.Unlock()
	fake.DisplayJSONStub = nil
	fake.displayJSONReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUI) DisplayJSONReturnsOnCall(i int, result1 error) {
	fake.displayJSONMutex.Lock()
	defer fake.displayJSONMutex.Unlock()
	fake.DisplayJSONStub = nil
	if fake.displayJSONReturnsOnCall == nil {
		fake.displayJSONReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.displayJSONReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUI) DisplayKeyValueTable(arg1 string, arg2 [][]string, arg3 int) {
	var arg2Copy [][]string
	if arg2 != nil {
		arg2Copy = make([][]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.displayKeyValueTableMutex.Lock()
	fake.displayKeyValueTableArgsForCall = append(fake.displayKeyValueTableArgsForCall, struct {
		arg1 string
		arg2 [][]string
		arg3 int
	}{arg1, arg2Copy, arg3})
	stub := fake.DisplayKeyValueTableStub
	fake.recordInvocation("DisplayKeyValueTable", []interface{}{arg1, arg2Copy, arg3})
	fake.displayKeyValueTableMutex.Unlock()
	if stub != nil {
		fake.DisplayKeyValueTableStub(arg1, arg2, arg3)
	}
}

func (fake *FakeUI) DisplayKeyValueTableCallCount() int {
	fake.displayKeyValueTableMutex.RLock()
	defer fake.displayKeyValueTableMutex.RUnlock()
	return len(fake.displayKeyValueTableArgsForCall)
}

func (fake *FakeUI) DisplayKeyValueTableCalls(stub func(string, [][]string, int)) {
	fake.displayKeyValueTableMutex.Lock()
	defer fake.displayKeyValueTableMutex.Unlock()
	fake.DisplayKeyValueTableStub = stub
}

func (fake *FakeUI) DisplayKeyValueTableArgsForCall(i int) (string, [][]string, int) {
	fake.displayKeyValueTableMutex.RLock()
	defer fake.displayKeyValueTableMutex.RUnlock()
	argsForCall := fake.displayKeyValueTableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUI) DisplayKeyValueTableForApp(arg1 [][]string) {
	var arg1Copy [][]string
	if arg1 != nil {
		arg1Copy = make([][]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.displayKeyValueTableForAppMutex.Lock()
	fake.displayKeyValueTableForAppArgsForCall = append(fake.displayKeyValueTableForAppArgsForCall, struct {
		arg1 [][]string
	}{arg1Copy})
	stub := fake.DisplayKeyValueTableForAppStub
	fake.recordInvocation("DisplayKeyValueTableForApp", []interface{}{arg1Copy})
	fake.displayKeyValueTableForAppMutex.Unlock()
	if stub != nil {
		fake.DisplayKeyValueTableForAppStub(arg1)
	}
}

func (fake *FakeUI) DisplayKeyValueTableForAppCallCount() int {
	fake.displayKeyValueTableForAppMutex.RLock()
	defer fake.displayKeyValueTableForAppMutex.RUnlock()
	return len(fake.displayKeyValueTableForAppArgsForCall)
}

func (fake *FakeUI) DisplayKeyValueTableForAppCalls(stub func([][]string)) {
	fake.displayKeyValueTableForAppMutex.Lock()
	defer fake.displayKeyValueTableForAppMutex.Unlock()
	fake.DisplayKeyValueTableForAppStub = stub
}

func (fake *FakeUI) DisplayKeyValueTableForAppArgsForCall(i int) [][]string {
	fake.displayKeyValueTableForAppMutex.RLock()
	defer fake.displayKeyValueTableForAppMutex.RUnlock()
	argsForCall := fake.displayKeyValueTableForAppArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) DisplayLogMessage(arg1 ui.LogMessage, arg2 bool) {
	fake.displayLogMessageMutex.Lock()
	fake.displayLogMessageArgsForCall = append(fake.displayLogMessageArgsForCall, struct {
		arg1 ui.LogMessage
		arg2 bool
	}{arg1, arg2})
	stub := fake.DisplayLogMessageStub
	fake.recordInvocation("DisplayLogMessage", []interface{}{arg1, arg2})
	fake.displayLogMessageMutex.Unlock()
	if stub != nil {
		fake.DisplayLogMessageStub(arg1, arg2)
	}
}

func (fake *FakeUI) DisplayLogMessageCallCount() int {
	fake.displayLogMessageMutex.RLock()
	defer fake.displayLogMessageMutex.RUnlock()
	return len(fake.displayLogMessageArgsForCall)
}

func (fake *FakeUI) DisplayLogMessageCalls(stub func(ui.LogMessage, bool)) {
	fake.displayLogMessageMutex.Lock()
	defer fake.displayLogMessageMutex.Unlock()
	fake.DisplayLogMessageStub = stub
}

func (fake *FakeUI) DisplayLogMessageArgsForCall(i int) (ui.LogMessage, bool) {
	fake.displayLogMessageMutex.RLock()
	defer fake.displayLogMessageMutex.RUnlock()
	argsForCall := fake.displayLogMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) DisplayNewline() {
	fake.displayNewlineMutex.Lock()
	fake.displayNewlineArgsForCall = append(fake.displayNewlineArgsForCall, struct {
	}{})
	stub := fake.DisplayNewlineStub
	fake.recordInvocation("DisplayNewline", []interface{}{})
	fake.displayNewlineMutex.Unlock()
	if stub != nil {
		fake.DisplayNewlineStub()
	}
}

func (fake *FakeUI) DisplayNewlineCallCount() int {
	fake.displayNewlineMutex.RLock()
	defer fake.displayNewlineMutex.RUnlock()
	return len(fake.displayNewlineArgsForCall)
}

func (fake *FakeUI) DisplayNewlineCalls(stub func()) {
	fake.displayNewlineMutex.Lock()
	defer fake.displayNewlineMutex.Unlock()
	fake.DisplayNewlineStub = stub
}

func (fake *FakeUI) DisplayNonWrappingTable(arg1 string, arg2 [][]string, arg3 int) {
	var arg2Copy [][]string
	if arg2 != nil {
		arg2Copy = make([][]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.displayNonWrappingTableMutex.Lock()
	fake.displayNonWrappingTableArgsForCall = append(fake.displayNonWrappingTableArgsForCall, struct {
		arg1 string
		arg2 [][]string
		arg3 int
	}{arg1, arg2Copy, arg3})
	stub := fake.DisplayNonWrappingTableStub
	fake.recordInvocation("DisplayNonWrappingTable", []interface{}{arg1, arg2Copy, arg3})
	fake.displayNonWrappingTableMutex.Unlock()
	if stub != nil {
		fake.DisplayNonWrappingTableStub(arg1, arg2, arg3)
	}
}

func (fake *FakeUI) DisplayNonWrappingTableCallCount() int {
	fake.displayNonWrappingTableMutex.RLock()
	defer fake.displayNonWrappingTableMutex.RUnlock()
	return len(fake.displayNonWrappingTableArgsForCall)
}

func (fake *FakeUI) DisplayNonWrappingTableCalls(stub func(string, [][]string, int)) {
	fake.displayNonWrappingTableMutex.Lock()
	defer fake.displayNonWrappingTableMutex.Unlock()
	fake.DisplayNonWrappingTableStub = stub
}

func (fake *FakeUI) DisplayNonWrappingTableArgsForCall(i int) (string, [][]string, int) {
	fake.displayNonWrappingTableMutex.RLock()
	defer fake.displayNonWrappingTableMutex.RUnlock()
	argsForCall := fake.displayNonWrappingTableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUI) DisplayOK() {
	fake.displayOKMutex.Lock()
	fake.displayOKArgsForCall = append(fake.displayOKArgsForCall, struct {
	}{})
	stub := fake.DisplayOKStub
	fake.recordInvocation("DisplayOK", []interface{}{})
	fake.displayOKMutex.Unlock()
	if stub != nil {
		fake.DisplayOKStub()
	}
}

func (fake *FakeUI) DisplayOKCallCount() int {
	fake.displayOKMutex.RLock()
	defer fake.displayOKMutex.RUnlock()
	return len(fake.displayOKArgsForCall)
}

func (fake *FakeUI) DisplayOKCalls(stub func()) {
	fake.displayOKMutex.Lock()
	defer fake.displayOKMutex.Unlock()
	fake.DisplayOKStub = stub
}

func (fake *FakeUI) DisplayOptionalTextPrompt(arg1 string, arg2 string, arg3 ...map[string]interface{}) (string, error) {
	fake.displayOptionalTextPromptMutex.Lock()
	ret, specificReturn := fake.displayOptionalTextPromptReturnsOnCall[len(fake.displayOptionalTextPromptArgsForCall)]
	fake.displayOptionalTextPromptArgsForCall = append(fake.displayOptionalTextPromptArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []map[string]interface{}
	}{arg1, arg2, arg3})
	stub := fake.DisplayOptionalTextPromptStub
	fakeReturns := fake.displayOptionalTextPromptReturns
	fake.recordInvocation("DisplayOptionalTextPrompt", []interface{}{arg1, arg2, arg3})
	fake.displayOptionalTextPromptMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUI) DisplayOptionalTextPromptCallCount() int {
	fake.displayOptionalTextPromptMutex.RLock()
	defer fake.displayOptionalTextPromptMutex.RUnlock()
	return len(fake.displayOptionalTextPromptArgsForCall)
}

func (fake *FakeUI) DisplayOptionalTextPromptCalls(stub func(string, string, ...map[string]interface{}) (string, error)) {
	fake.displayOptionalTextPromptMutex.Lock()
	defer fake.displayOptionalTextPromptMutex.Unlock()
	fake.DisplayOptionalTextPromptStub = stub
}

func (fake *FakeUI) DisplayOptionalTextPromptArgsForCall(i int) (string, string, []map[string]interface{}) {
	fake.displayOptionalTextPromptMutex.RLock()
	defer fake.displayOptionalTextPromptMutex.RUnlock()
	argsForCall := fake.displayOptionalTextPromptArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUI) DisplayOptionalTextPromptReturns(result1 string, result2 error) {
	fake.displayOptionalTextPromptMutex.Lock()
	defer fake.displayOptionalTextPromptMutex.Unlock()
	fake.DisplayOptionalTextPromptStub = nil
	fake.displayOptionalTextPromptReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUI) DisplayOptionalTextPromptReturnsOnCall(i int, result1 string, result2 error) {
	fake.displayOptionalTextPromptMutex.Lock()
	defer fake.displayOptionalTextPromptMutex.Unlock()
	fake.DisplayOptionalTextPromptStub = nil
	if fake.displayOptionalTextPromptReturnsOnCall == nil {
		fake.displayOptionalTextPromptReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.displayOptionalTextPromptReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUI) DisplayPasswordPrompt(arg1 string, arg2 ...map[string]interface{}) (string, error) {
	fake.displayPasswordPromptMutex.Lock()
	ret, specificReturn := fake.displayPasswordPromptReturnsOnCall[len(fake.displayPasswordPromptArgsForCall)]
	fake.displayPasswordPromptArgsForCall = append(fake.displayPasswordPromptArgsForCall, struct {
		arg1 string
		arg2 []map[string]interface{}
	}{arg1, arg2})
	stub := fake.DisplayPasswordPromptStub
	fakeReturns := fake.displayPasswordPromptReturns
	fake.recordInvocation("DisplayPasswordPrompt", []interface{}{arg1, arg2})
	fake.displayPasswordPromptMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUI) DisplayPasswordPromptCallCount() int {
	fake.displayPasswordPromptMutex.RLock()
	defer fake.displayPasswordPromptMutex.RUnlock()
	return len(fake.displayPasswordPromptArgsForCall)
}

func (fake *FakeUI) DisplayPasswordPromptCalls(stub func(string, ...map[string]interface{}) (string, error)) {
	fake.displayPasswordPromptMutex.Lock()
	defer fake.displayPasswordPromptMutex.Unlock()
	fake.DisplayPasswordPromptStub = stub
}

func (fake *FakeUI) DisplayPasswordPromptArgsForCall(i int) (string, []map[string]interface{}) {
	fake.displayPasswordPromptMutex.RLock()
	defer fake.displayPasswordPromptMutex.RUnlock()
	argsForCall := fake.displayPasswordPromptArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) DisplayPasswordPromptReturns(result1 string, result2 error) {
	fake.displayPasswordPromptMutex.Lock()
	defer fake.displayPasswordPromptMutex.Unlock()
	fake.DisplayPasswordPromptStub = nil
	fake.displayPasswordPromptReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUI) DisplayPasswordPromptReturnsOnCall(i int, result1 string, result2 error) {
	fake.displayPasswordPromptMutex.Lock()
	defer fake.displayPasswordPromptMutex.Unlock()
	fake.DisplayPasswordPromptStub = nil
	if fake.displayPasswordPromptReturnsOnCall == nil {
		fake.displayPasswordPromptReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.displayPasswordPromptReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUI) DisplayTableWithHeader(arg1 string, arg2 [][]string, arg3 int) {
	var arg2Copy [][]string
	if arg2 != nil {
		arg2Copy = make([][]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.displayTableWithHeaderMutex.Lock()
	fake.displayTableWithHeaderArgsForCall = append(fake.displayTableWithHeaderArgsForCall, struct {
		arg1 string
		arg2 [][]string
		arg3 int
	}{arg1, arg2Copy, arg3})
	stub := fake.DisplayTableWithHeaderStub
	fake.recordInvocation("DisplayTableWithHeader", []interface{}{arg1, arg2Copy, arg3})
	fake.displayTableWithHeaderMutex.Unlock()
	if stub != nil {
		fake.DisplayTableWithHeaderStub(arg1, arg2, arg3)
	}
}

func (fake *FakeUI) DisplayTableWithHeaderCallCount() int {
	fake.displayTableWithHeaderMutex.RLock()
	defer fake.displayTableWithHeaderMutex.RUnlock()
	return len(fake.displayTableWithHeaderArgsForCall)
}

func (fake *FakeUI) DisplayTableWithHeaderCalls(stub func(string, [][]string, int)) {
	fake.displayTableWithHeaderMutex.Lock()
	defer fake.displayTableWithHeaderMutex.Unlock()
	fake.DisplayTableWithHeaderStub = stub
}

func (fake *FakeUI) DisplayTableWithHeaderArgsForCall(i int) (string, [][]string, int) {
	fake.displayTableWithHeaderMutex.RLock()
	defer fake.displayTableWithHeaderMutex.RUnlock()
	argsForCall := fake.displayTableWithHeaderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUI) DisplayText(arg1 string, arg2 ...map[string]interface{}) {
	fake.displayTextMutex.Lock()
	fake.displayTextArgsForCall = append(fake.displayTextArgsForCall, struct {
		arg1 string
		arg2 []map[string]interface{}
	}{arg1, arg2})
	stub := fake.DisplayTextStub
	fake.recordInvocation("DisplayText", []interface{}{arg1, arg2})
	fake.displayTextMutex.Unlock()
	if stub != nil {
		fake.DisplayTextStub(arg1, arg2...)
	}
}

func (fake *FakeUI) DisplayTextCallCount() int {
	fake.displayTextMutex.RLock()
	defer fake.displayTextMutex.RUnlock()
	return len(fake.displayTextArgsForCall)
}

func (fake *FakeUI) DisplayTextCalls(stub func(string, ...map[string]interface{})) {
	fake.displayTextMutex.Lock()
	defer fake.displayTextMutex.Unlock()
	fake.DisplayTextStub = stub
}

func (fake *FakeUI) DisplayTextArgsForCall(i int) (string, []map[string]interface{}) {
	fake.displayTextMutex.RLock()
	defer fake.displayTextMutex.RUnlock()
	argsForCall := fake.displayTextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) DisplayTextLiteral(arg1 string) {
	fake.displayTextLiteralMutex.Lock()
	fake.displayTextLiteralArgsForCall = append(fake.displayTextLiteralArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DisplayTextLiteralStub
	fake.recordInvocation("DisplayTextLiteral", []interface{}{arg1})
	fake.displayTextLiteralMutex.Unlock()
	if stub != nil {
		fake.DisplayTextLiteralStub(arg1)
	}
}

func (fake *FakeUI) DisplayTextLiteralCallCount() int {
	fake.displayTextLiteralMutex.RLock()
	defer fake.displayTextLiteralMutex.RUnlock()
	return len(fake.displayTextLiteralArgsForCall)
}

func (fake *FakeUI) DisplayTextLiteralCalls(stub func(string)) {
	fake.displayTextLiteralMutex.Lock()
	defer fake.displayTextLiteralMutex.Unlock()
	fake.DisplayTextLiteralStub = stub
}

func (fake *FakeUI) DisplayTextLiteralArgsForCall(i int) string {
	fake.displayTextLiteralMutex.RLock()
	defer fake.displayTextLiteralMutex.RUnlock()
	argsForCall := fake.displayTextLiteralArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) DisplayTextMenu(arg1 []string, arg2 string, arg3 ...map[string]interface{}) (string, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.displayTextMenuMutex.Lock()
	ret, specificReturn := fake.displayTextMenuReturnsOnCall[len(fake.displayTextMenuArgsForCall)]
	fake.displayTextMenuArgsForCall = append(fake.displayTextMenuArgsForCall, struct {
		arg1 []string
		arg2 string
		arg3 []map[string]interface{}
	}{arg1Copy, arg2, arg3})
	stub := fake.DisplayTextMenuStub
	fakeReturns := fake.displayTextMenuReturns
	fake.recordInvocation("DisplayTextMenu", []interface{}{arg1Copy, arg2, arg3})
	fake.displayTextMenuMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUI) DisplayTextMenuCallCount() int {
	fake.displayTextMenuMutex.RLock()
	defer fake.displayTextMenuMutex.RUnlock()
	return len(fake.displayTextMenuArgsForCall)
}

func (fake *FakeUI) DisplayTextMenuCalls(stub func([]string, string, ...map[string]interface{}) (string, error)) {
	fake.displayTextMenuMutex.Lock()
	defer fake.displayTextMenuMutex.Unlock()
	fake.DisplayTextMenuStub = stub
}

func (fake *FakeUI) DisplayTextMenuArgsForCall(i int) ([]string, string, []map[string]interface{}) {
	fake.displayTextMenuMutex.RLock()
	defer fake.displayTextMenuMutex.RUnlock()
	argsForCall := fake.displayTextMenuArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUI) DisplayTextMenuReturns(result1 string, result2 error) {
	fake.displayTextMenuMutex.Lock()
	defer fake.displayTextMenuMutex.Unlock()
	fake.DisplayTextMenuStub = nil
	fake.displayTextMenuReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUI) DisplayTextMenuReturnsOnCall(i int, result1 string, result2 error) {
	fake.displayTextMenuMutex.Lock()
	defer fake.displayTextMenuMutex.Unlock()
	fake.DisplayTextMenuStub = nil
	if fake.displayTextMenuReturnsOnCall == nil {
		fake.displayTextMenuReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.displayTextMenuReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUI) DisplayTextPrompt(arg1 string, arg2 ...map[string]interface{}) (string, error) {
	fake.displayTextPromptMutex.Lock()
	ret, specificReturn := fake.displayTextPromptReturnsOnCall[len(fake.displayTextPromptArgsForCall)]
	fake.displayTextPromptArgsForCall = append(fake.displayTextPromptArgsForCall, struct {
		arg1 string
		arg2 []map[string]interface{}
	}{arg1, arg2})
	stub := fake.DisplayTextPromptStub
	fakeReturns := fake.displayTextPromptReturns
	fake.recordInvocation("DisplayTextPrompt", []interface{}{arg1, arg2})
	fake.displayTextPromptMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUI) DisplayTextPromptCallCount() int {
	fake.displayTextPromptMutex.RLock()
	defer fake.displayTextPromptMutex.RUnlock()
	return len(fake.displayTextPromptArgsForCall)
}

func (fake *FakeUI) DisplayTextPromptCalls(stub func(string, ...map[string]interface{}) (string, error)) {
	fake.displayTextPromptMutex.Lock()
	defer fake.displayTextPromptMutex.Unlock()
	fake.DisplayTextPromptStub = stub
}

func (fake *FakeUI) DisplayTextPromptArgsForCall(i int) (string, []map[string]interface{}) {
	fake.displayTextPromptMutex.RLock()
	defer fake.displayTextPromptMutex.RUnlock()
	argsForCall := fake.displayTextPromptArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) DisplayTextPromptReturns(result1 string, result2 error) {
	fake.displayTextPromptMutex.Lock()
	defer fake.displayTextPromptMutex.Unlock()
	fake.DisplayTextPromptStub = nil
	fake.displayTextPromptReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUI) DisplayTextPromptReturnsOnCall(i int, result1 string, result2 error) {
	fake.displayTextPromptMutex.Lock()
	defer fake.displayTextPromptMutex.Unlock()
	fake.DisplayTextPromptStub = nil
	if fake.displayTextPromptReturnsOnCall == nil {
		fake.displayTextPromptReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.displayTextPromptReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUI) DisplayTextWithBold(arg1 string, arg2 ...map[string]interface{}) {
	fake.displayTextWithBoldMutex.Lock()
	fake.displayTextWithBoldArgsForCall = append(fake.displayTextWithBoldArgsForCall, struct {
		arg1 string
		arg2 []map[string]interface{}
	}{arg1, arg2})
	stub := fake.DisplayTextWithBoldStub
	fake.recordInvocation("DisplayTextWithBold", []interface{}{arg1, arg2})
	fake.displayTextWithBoldMutex.Unlock()
	if stub != nil {
		fake.DisplayTextWithBoldStub(arg1, arg2...)
	}
}

func (fake *FakeUI) DisplayTextWithBoldCallCount() int {
	fake.displayTextWithBoldMutex.RLock()
	defer fake.displayTextWithBoldMutex.RUnlock()
	return len(fake.displayTextWithBoldArgsForCall)
}

func (fake *FakeUI) DisplayTextWithBoldCalls(stub func(string, ...map[string]interface{})) {
	fake.displayTextWithBoldMutex.Lock()
	defer fake.displayTextWithBoldMutex.Unlock()
	fake.DisplayTextWithBoldStub = stub
}

func (fake *FakeUI) DisplayTextWithBoldArgsForCall(i int) (string, []map[string]interface{}) {
	fake.displayTextWithBoldMutex.RLock()
	defer fake.displayTextWithBoldMutex.RUnlock()
	argsForCall := fake.displayTextWithBoldArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) DisplayTextWithFlavor(arg1 string, arg2 ...map[string]interface{}) {
	fake.displayTextWithFlavorMutex.Lock()
	fake.displayTextWithFlavorArgsForCall = append(fake.displayTextWithFlavorArgsForCall, struct {
		arg1 string
		arg2 []map[string]interface{}
	}{arg1, arg2})
	stub := fake.DisplayTextWithFlavorStub
	fake.recordInvocation("DisplayTextWithFlavor", []interface{}{arg1, arg2})
	fake.displayTextWithFlavorMutex.Unlock()
	if stub != nil {
		fake.DisplayTextWithFlavorStub(arg1, arg2...)
	}
}

func (fake *FakeUI) DisplayTextWithFlavorCallCount() int {
	fake.displayTextWithFlavorMutex.RLock()
	defer fake.displayTextWithFlavorMutex.RUnlock()
	return len(fake.displayTextWithFlavorArgsForCall)
}

func (fake *FakeUI) DisplayTextWithFlavorCalls(stub func(string, ...map[string]interface{})) {
	fake.displayTextWithFlavorMutex.Lock()
	defer fake.displayTextWithFlavorMutex.Unlock()
	fake.DisplayTextWithFlavorStub = stub
}

func (fake *FakeUI) DisplayTextWithFlavorArgsForCall(i int) (string, []map[string]interface{}) {
	fake.displayTextWithFlavorMutex.RLock()
	defer fake.displayTextWithFlavorMutex.RUnlock()
	argsForCall := fake.displayTextWithFlavorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) DisplayWarning(arg1 string, arg2 ...map[string]interface{}) {
	fake.displayWarningMutex.Lock()
	fake.displayWarningArgsForCall = append(fake.displayWarningArgsForCall, struct {
		arg1 string
		arg2 []map[string]interface{}
	}{arg1, arg2})
	stub := fake.DisplayWarningStub
	fake.recordInvocation("DisplayWarning", []interface{}{arg1, arg2})
	fake.displayWarningMutex.Unlock()
	if stub != nil {
		fake.DisplayWarningStub(arg1, arg2...)
	}
}

func (fake *FakeUI) DisplayWarningCallCount() int {
	fake.displayWarningMutex.RLock()
	defer fake.displayWarningMutex.RUnlock()
	return len(fake.displayWarningArgsForCall)
}

func (fake *FakeUI) DisplayWarningCalls(stub func(string, ...map[string]interface{})) {
	fake.displayWarningMutex.Lock()
	defer fake.displayWarningMutex.Unlock()
	fake.DisplayWarningStub = stub
}

func (fake *FakeUI) DisplayWarningArgsForCall(i int) (string, []map[string]interface{}) {
	fake.displayWarningMutex.RLock()
	defer fake.displayWarningMutex.RUnlock()
	argsForCall := fake.displayWarningArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) DisplayWarnings(arg1 []string) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.displayWarningsMutex.Lock()
	fake.displayWarningsArgsForCall = append(fake.displayWarningsArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.DisplayWarningsStub
	fake.recordInvocation("DisplayWarnings", []interface{}{arg1Copy})
	fake.displayWarningsMutex.Unlock()
	if stub != nil {
		fake.DisplayWarningsStub(arg1)
	}
}

func (fake *FakeUI) DisplayWarningsCallCount() int {
	fake.displayWarningsMutex.RLock()
	defer fake.displayWarningsMutex.RUnlock()
	return len(fake.displayWarningsArgsForCall)
}

func (fake *FakeUI) DisplayWarningsCalls(stub func([]string)) {
	fake.displayWarningsMutex.Lock()
	defer fake.displayWarningsMutex.Unlock()
	fake.DisplayWarningsStub = stub
}

func (fake *FakeUI) DisplayWarningsArgsForCall(i int) []string {
	fake.displayWarningsMutex.RLock()
	defer fake.displayWarningsMutex.RUnlock()
	argsForCall := fake.displayWarningsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) GetErr() io.Writer {
	fake.getErrMutex.Lock()
	ret, specificReturn := fake.getErrReturnsOnCall[len(fake.getErrArgsForCall)]
	fake.getErrArgsForCall = append(fake.getErrArgsForCall, struct {
	}{})
	stub := fake.GetErrStub
	fakeReturns := fake.getErrReturns
	fake.recordInvocation("GetErr", []interface{}{})
	fake.getErrMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUI) GetErrCallCount() int {
	fake.getErrMutex.RLock()
	defer fake.getErrMutex.RUnlock()
	return len(fake.getErrArgsForCall)
}

func (fake *FakeUI) GetErrCalls(stub func() io.Writer) {
	fake.getErrMutex.Lock()
	defer fake.getErrMutex.Unlock()
	fake.GetErrStub = stub
}

func (fake *FakeUI) GetErrReturns(result1 io.Writer) {
	fake.getErrMutex.Lock()
	defer fake.getErrMutex.Unlock()
	fake.GetErrStub = nil
	fake.getErrReturns = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeUI) GetErrReturnsOnCall(i int, result1 io.Writer) {
	fake.getErrMutex.Lock()
	defer fake.getErrMutex.Unlock()
	fake.GetErrStub = nil
	if fake.getErrReturnsOnCall == nil {
		fake.getErrReturnsOnCall = make(map[int]struct {
			result1 io.Writer
		})
	}
	fake.getErrReturnsOnCall[i] = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeUI) GetIn() io.Reader {
	fake.getInMutex.Lock()
	ret, specificReturn := fake.getInReturnsOnCall[len(fake.getInArgsForCall)]
	fake.getInArgsForCall = append(fake.getInArgsForCall, struct {
	}{})
	stub := fake.GetInStub
	fakeReturns := fake.getInReturns
	fake.recordInvocation("GetIn", []interface{}{})
	fake.getInMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUI) GetInCallCount() int {
	fake.getInMutex.RLock()
	defer fake.getInMutex.RUnlock()
	return len(fake.getInArgsForCall)
}

func (fake *FakeUI) GetInCalls(stub func() io.Reader) {
	fake.getInMutex.Lock()
	defer fake.getInMutex.Unlock()
	fake.GetInStub = stub
}

func (fake *FakeUI) GetInReturns(result1 io.Reader) {
	fake.getInMutex.Lock()
	defer fake.getInMutex.Unlock()
	fake.GetInStub = nil
	fake.getInReturns = struct {
		result1 io.Reader
	}{result1}
}

func (fake *FakeUI) GetInReturnsOnCall(i int, result1 io.Reader) {
	fake.getInMutex.Lock()
	defer fake.getInMutex.Unlock()
	fake.GetInStub = nil
	if fake.getInReturnsOnCall == nil {
		fake.getInReturnsOnCall = make(map[int]struct {
			result1 io.Reader
		})
	}
	fake.getInReturnsOnCall[i] = struct {
		result1 io.Reader
	}{result1}
}

func (fake *FakeUI) GetOut() io.Writer {
	fake.getOutMutex.Lock()
	ret, specificReturn := fake.getOutReturnsOnCall[len(fake.getOutArgsForCall)]
	fake.getOutArgsForCall = append(fake.getOutArgsForCall, struct {
	}{})
	stub := fake.GetOutStub
	fakeReturns := fake.getOutReturns
	fake.recordInvocation("GetOut", []interface{}{})
	fake.getOutMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUI) GetOutCallCount() int {
	fake.getOutMutex.RLock()
	defer fake.getOutMutex.RUnlock()
	return len(fake.getOutArgsForCall)
}

func (fake *FakeUI) GetOutCalls(stub func() io.Writer) {
	fake.getOutMutex.Lock()
	defer fake.getOutMutex.Unlock()
	fake.GetOutStub = stub
}

func (fake *FakeUI) GetOutReturns(result1 io.Writer) {
	fake.getOutMutex.Lock()
	defer fake.getOutMutex.Unlock()
	fake.GetOutStub = nil
	fake.getOutReturns = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeUI) GetOutReturnsOnCall(i int, result1 io.Writer) {
	fake.getOutMutex.Lock()
	defer fake.getOutMutex.Unlock()
	fake.GetOutStub = nil
	if fake.getOutReturnsOnCall == nil {
		fake.getOutReturnsOnCall = make(map[int]struct {
			result1 io.Writer
		})
	}
	fake.getOutReturnsOnCall[i] = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeUI) RequestLoggerFileWriter(arg1 []string) *ui.RequestLoggerFileWriter {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.requestLoggerFileWriterMutex.Lock()
	ret, specificReturn := fake.requestLoggerFileWriterReturnsOnCall[len(fake.requestLoggerFileWriterArgsForCall)]
	fake.requestLoggerFileWriterArgsForCall = append(fake.requestLoggerFileWriterArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.RequestLoggerFileWriterStub
	fakeReturns := fake.requestLoggerFileWriterReturns
	fake.recordInvocation("RequestLoggerFileWriter", []interface{}{arg1Copy})
	fake.requestLoggerFileWriterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUI) RequestLoggerFileWriterCallCount() int {
	fake.requestLoggerFileWriterMutex.RLock()
	defer fake.requestLoggerFileWriterMutex.RUnlock()
	return len(fake.requestLoggerFileWriterArgsForCall)
}

func (fake *FakeUI) RequestLoggerFileWriterCalls(stub func([]string) *ui.RequestLoggerFileWriter) {
	fake.requestLoggerFileWriterMutex.Lock()
	defer fake.requestLoggerFileWriterMutex.Unlock()
	fake.RequestLoggerFileWriterStub = stub
}

func (fake *FakeUI) RequestLoggerFileWriterArgsForCall(i int) []string {
	fake.requestLoggerFileWriterMutex.RLock()
	defer fake.requestLoggerFileWriterMutex.RUnlock()
	argsForCall := fake.requestLoggerFileWriterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) RequestLoggerFileWriterReturns(result1 *ui.RequestLoggerFileWriter) {
	fake.requestLoggerFileWriterMutex.Lock()
	defer fake.requestLoggerFileWriterMutex.Unlock()
	fake.RequestLoggerFileWriterStub = nil
	fake.requestLoggerFileWriterReturns = struct {
		result1 *ui.RequestLoggerFileWriter
	}{result1}
}

func (fake *FakeUI) RequestLoggerFileWriterReturnsOnCall(i int, result1 *ui.RequestLoggerFileWriter) {
	fake.requestLoggerFileWriterMutex.Lock()
	defer fake.requestLoggerFileWriterMutex.Unlock()
	fake.RequestLoggerFileWriterStub = nil
	if fake.requestLoggerFileWriterReturnsOnCall == nil {
		fake.requestLoggerFileWriterReturnsOnCall = make(map[int]struct {
			result1 *ui.RequestLoggerFileWriter
		})
	}
	fake.requestLoggerFileWriterReturnsOnCall[i] = struct {
		result1 *ui.RequestLoggerFileWriter
	}{result1}
}

func (fake *FakeUI) RequestLoggerTerminalDisplay() *ui.RequestLoggerTerminalDisplay {
	fake.requestLoggerTerminalDisplayMutex.Lock()
	ret, specificReturn := fake.requestLoggerTerminalDisplayReturnsOnCall[len(fake.requestLoggerTerminalDisplayArgsForCall)]
	fake.requestLoggerTerminalDisplayArgsForCall = append(fake.requestLoggerTerminalDisplayArgsForCall, struct {
	}{})
	stub := fake.RequestLoggerTerminalDisplayStub
	fakeReturns := fake.requestLoggerTerminalDisplayReturns
	fake.recordInvocation("RequestLoggerTerminalDisplay", []interface{}{})
	fake.requestLoggerTerminalDisplayMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUI) RequestLoggerTerminalDisplayCallCount() int {
	fake.requestLoggerTerminalDisplayMutex.RLock()
	defer fake.requestLoggerTerminalDisplayMutex.RUnlock()
	return len(fake.requestLoggerTerminalDisplayArgsForCall)
}

func (fake *FakeUI) RequestLoggerTerminalDisplayCalls(stub func() *ui.RequestLoggerTerminalDisplay) {
	fake.requestLoggerTerminalDisplayMutex.Lock()
	defer fake.requestLoggerTerminalDisplayMutex.Unlock()
	fake.RequestLoggerTerminalDisplayStub = stub
}

func (fake *FakeUI) RequestLoggerTerminalDisplayReturns(result1 *ui.RequestLoggerTerminalDisplay) {
	fake.requestLoggerTerminalDisplayMutex.Lock()
	defer fake.requestLoggerTerminalDisplayMutex.Unlock()
	fake.RequestLoggerTerminalDisplayStub = nil
	fake.requestLoggerTerminalDisplayReturns = struct {
		result1 *ui.RequestLoggerTerminalDisplay
	}{result1}
}

func (fake *FakeUI) RequestLoggerTerminalDisplayReturnsOnCall(i int, result1 *ui.RequestLoggerTerminalDisplay) {
	fake.requestLoggerTerminalDisplayMutex.Lock()
	defer fake.requestLoggerTerminalDisplayMutex.Unlock()
	fake.RequestLoggerTerminalDisplayStub = nil
	if fake.requestLoggerTerminalDisplayReturnsOnCall == nil {
		fake.requestLoggerTerminalDisplayReturnsOnCall = make(map[int]struct {
			result1 *ui.RequestLoggerTerminalDisplay
		})
	}
	fake.requestLoggerTerminalDisplayReturnsOnCall[i] = struct {
		result1 *ui.RequestLoggerTerminalDisplay
	}{result1}
}

func (fake *FakeUI) TranslateText(arg1 string, arg2 ...map[string]interface{}) string {
	fake.translateTextMutex.Lock()
	ret, specificReturn := fake.translateTextReturnsOnCall[len(fake.translateTextArgsForCall)]
	fake.translateTextArgsForCall = append(fake.translateTextArgsForCall, struct {
		arg1 string
		arg2 []map[string]interface{}
	}{arg1, arg2})
	stub := fake.TranslateTextStub
	fakeReturns := fake.translateTextReturns
	fake.recordInvocation("TranslateText", []interface{}{arg1, arg2})
	fake.translateTextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUI) TranslateTextCallCount() int {
	fake.translateTextMutex.RLock()
	defer fake.translateTextMutex.RUnlock()
	return len(fake.translateTextArgsForCall)
}

func (fake *FakeUI) TranslateTextCalls(stub func(string, ...map[string]interface{}) string) {
	fake.translateTextMutex.Lock()
	defer fake.translateTextMutex.Unlock()
	fake.TranslateTextStub = stub
}

func (fake *FakeUI) TranslateTextArgsForCall(i int) (string, []map[string]interface{}) {
	fake.translateTextMutex.RLock()
	defer fake.translateTextMutex.RUnlock()
	argsForCall := fake.translateTextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUI) TranslateTextReturns(result1 string) {
	fake.translateTextMutex.Lock()
	defer fake.translateTextMutex.Unlock()
	fake.TranslateTextStub = nil
	fake.translateTextReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUI) TranslateTextReturnsOnCall(i int, result1 string) {
	fake.translateTextMutex.Lock()
	defer fake.translateTextMutex.Unlock()
	fake.TranslateTextStub = nil
	if fake.translateTextReturnsOnCall == nil {
		fake.translateTextReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.translateTextReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUI) UserFriendlyDate(arg1 time.Time) string {
	fake.userFriendlyDateMutex.Lock()
	ret, specificReturn := fake.userFriendlyDateReturnsOnCall[len(fake.userFriendlyDateArgsForCall)]
	fake.userFriendlyDateArgsForCall = append(fake.userFriendlyDateArgsForCall, struct {
		arg1 time.Time
	}{arg1})
	stub := fake.UserFriendlyDateStub
	fakeReturns := fake.userFriendlyDateReturns
	fake.recordInvocation("UserFriendlyDate", []interface{}{arg1})
	fake.userFriendlyDateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUI) UserFriendlyDateCallCount() int {
	fake.userFriendlyDateMutex.RLock()
	defer fake.userFriendlyDateMutex.RUnlock()
	return len(fake.userFriendlyDateArgsForCall)
}

func (fake *FakeUI) UserFriendlyDateCalls(stub func(time.Time) string) {
	fake.userFriendlyDateMutex.Lock()
	defer fake.userFriendlyDateMutex.Unlock()
	fake.UserFriendlyDateStub = stub
}

func (fake *FakeUI) UserFriendlyDateArgsForCall(i int) time.Time {
	fake.userFriendlyDateMutex.RLock()
	defer fake.userFriendlyDateMutex.RUnlock()
	argsForCall := fake.userFriendlyDateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUI) UserFriendlyDateReturns(result1 string) {
	fake.userFriendlyDateMutex.Lock()
	defer fake.userFriendlyDateMutex.Unlock()
	fake.UserFriendlyDateStub = nil
	fake.userFriendlyDateReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUI) UserFriendlyDateReturnsOnCall(i int, result1 string) {
	fake.userFriendlyDateMutex.Lock()
	defer fake.userFriendlyDateMutex.Unlock()
	fake.UserFriendlyDateStub = nil
	if fake.userFriendlyDateReturnsOnCall == nil {
		fake.userFriendlyDateReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.userFriendlyDateReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUI) Writer() io.Writer {
	fake.writerMutex.Lock()
	ret, specificReturn := fake.writerReturnsOnCall[len(fake.writerArgsForCall)]
	fake.writerArgsForCall = append(fake.writerArgsForCall, struct {
	}{})
	stub := fake.WriterStub
	fakeReturns := fake.writerReturns
	fake.recordInvocation("Writer", []interface{}{})
	fake.writerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUI) WriterCallCount() int {
	fake.writerMutex.RLock()
	defer fake.writerMutex.RUnlock()
	return len(fake.writerArgsForCall)
}

func (fake *FakeUI) WriterCalls(stub func() io.Writer) {
	fake.writerMutex.Lock()
	defer fake.writerMutex.Unlock()
	fake.WriterStub = stub
}

func (fake *FakeUI) WriterReturns(result1 io.Writer) {
	fake.writerMutex.Lock()
	defer fake.writerMutex.Unlock()
	fake.WriterStub = nil
	fake.writerReturns = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeUI) WriterReturnsOnCall(i int, result1 io.Writer) {
	fake.writerMutex.Lock()
	defer fake.writerMutex.Unlock()
	fake.WriterStub = nil
	if fake.writerReturnsOnCall == nil {
		fake.writerReturnsOnCall = make(map[int]struct {
			result1 io.Writer
		})
	}
	fake.writerReturnsOnCall[i] = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeUI) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deferTextMutex.RLock()
	defer fake.deferTextMutex.RUnlock()
	fake.displayBoolPromptMutex.RLock()
	defer fake.displayBoolPromptMutex.RUnlock()
	fake.displayChangesForPushMutex.RLock()
	defer fake.displayChangesForPushMutex.RUnlock()
	fake.displayDeprecationWarningMutex.RLock()
	defer fake.displayDeprecationWarningMutex.RUnlock()
	fake.displayDiffAdditionMutex.RLock()
	defer fake.displayDiffAdditionMutex.RUnlock()
	fake.displayDiffRemovalMutex.RLock()
	defer fake.displayDiffRemovalMutex.RUnlock()
	fake.displayDiffUnchangedMutex.RLock()
	defer fake.displayDiffUnchangedMutex.RUnlock()
	fake.displayErrorMutex.RLock()
	defer fake.displayErrorMutex.RUnlock()
	fake.displayFileDeprecationWarningMutex.RLock()
	defer fake.displayFileDeprecationWarningMutex.RUnlock()
	fake.displayHeaderMutex.RLock()
	defer fake.displayHeaderMutex.RUnlock()
	fake.displayInstancesTableForAppMutex.RLock()
	defer fake.displayInstancesTableForAppMutex.RUnlock()
	fake.displayJSONMutex.RLock()
	defer fake.displayJSONMutex.RUnlock()
	fake.displayKeyValueTableMutex.RLock()
	defer fake.displayKeyValueTableMutex.RUnlock()
	fake.displayKeyValueTableForAppMutex.RLock()
	defer fake.displayKeyValueTableForAppMutex.RUnlock()
	fake.displayLogMessageMutex.RLock()
	defer fake.displayLogMessageMutex.RUnlock()
	fake.displayNewlineMutex.RLock()
	defer fake.displayNewlineMutex.RUnlock()
	fake.displayNonWrappingTableMutex.RLock()
	defer fake.displayNonWrappingTableMutex.RUnlock()
	fake.displayOKMutex.RLock()
	defer fake.displayOKMutex.RUnlock()
	fake.displayOptionalTextPromptMutex.RLock()
	defer fake.displayOptionalTextPromptMutex.RUnlock()
	fake.displayPasswordPromptMutex.RLock()
	defer fake.displayPasswordPromptMutex.RUnlock()
	fake.displayTableWithHeaderMutex.RLock()
	defer fake.displayTableWithHeaderMutex.RUnlock()
	fake.displayTextMutex.RLock()
	defer fake.displayTextMutex.RUnlock()
	fake.displayTextLiteralMutex.RLock()
	defer fake.displayTextLiteralMutex.RUnlock()
	fake.displayTextMenuMutex.RLock()
	defer fake.displayTextMenuMutex.RUnlock()
	fake.displayTextPromptMutex.RLock()
	defer fake.displayTextPromptMutex.RUnlock()
	fake.displayTextWithBoldMutex.RLock()
	defer fake.displayTextWithBoldMutex.RUnlock()
	fake.displayTextWithFlavorMutex.RLock()
	defer fake.displayTextWithFlavorMutex.RUnlock()
	fake.displayWarningMutex.RLock()
	defer fake.displayWarningMutex.RUnlock()
	fake.displayWarningsMutex.RLock()
	defer fake.displayWarningsMutex.RUnlock()
	fake.getErrMutex.RLock()
	defer fake.getErrMutex.RUnlock()
	fake.getInMutex.RLock()
	defer fake.getInMutex.RUnlock()
	fake.getOutMutex.RLock()
	defer fake.getOutMutex.RUnlock()
	fake.requestLoggerFileWriterMutex.RLock()
	defer fake.requestLoggerFileWriterMutex.RUnlock()
	fake.requestLoggerTerminalDisplayMutex.RLock()
	defer fake.requestLoggerTerminalDisplayMutex.RUnlock()
	fake.translateTextMutex.RLock()
	defer fake.translateTextMutex.RUnlock()
	fake.userFriendlyDateMutex.RLock()
	defer fake.userFriendlyDateMutex.RUnlock()
	fake.writerMutex.RLock()
	defer fake.writerMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUI) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ command.UI = new(FakeUI)
