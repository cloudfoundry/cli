// Code generated by counterfeiter. DO NOT EDIT.
package directorfakes

import (
	"io"
	"sync"

	"github.com/cloudfoundry/bosh-cli/director"
)

type FakeDirector struct {
	IsAuthenticatedStub        func() (bool, error)
	isAuthenticatedMutex       sync.RWMutex
	isAuthenticatedArgsForCall []struct{}
	isAuthenticatedReturns     struct {
		result1 bool
		result2 error
	}
	isAuthenticatedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	WithContextStub        func(id string) director.Director
	withContextMutex       sync.RWMutex
	withContextArgsForCall []struct {
		id string
	}
	withContextReturns struct {
		result1 director.Director
	}
	withContextReturnsOnCall map[int]struct {
		result1 director.Director
	}
	InfoStub        func() (director.Info, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct{}
	infoReturns     struct {
		result1 director.Info
		result2 error
	}
	infoReturnsOnCall map[int]struct {
		result1 director.Info
		result2 error
	}
	LocksStub        func() ([]director.Lock, error)
	locksMutex       sync.RWMutex
	locksArgsForCall []struct{}
	locksReturns     struct {
		result1 []director.Lock
		result2 error
	}
	locksReturnsOnCall map[int]struct {
		result1 []director.Lock
		result2 error
	}
	CurrentTasksStub        func(director.TasksFilter) ([]director.Task, error)
	currentTasksMutex       sync.RWMutex
	currentTasksArgsForCall []struct {
		arg1 director.TasksFilter
	}
	currentTasksReturns struct {
		result1 []director.Task
		result2 error
	}
	currentTasksReturnsOnCall map[int]struct {
		result1 []director.Task
		result2 error
	}
	RecentTasksStub        func(int, director.TasksFilter) ([]director.Task, error)
	recentTasksMutex       sync.RWMutex
	recentTasksArgsForCall []struct {
		arg1 int
		arg2 director.TasksFilter
	}
	recentTasksReturns struct {
		result1 []director.Task
		result2 error
	}
	recentTasksReturnsOnCall map[int]struct {
		result1 []director.Task
		result2 error
	}
	FindTaskStub        func(int) (director.Task, error)
	findTaskMutex       sync.RWMutex
	findTaskArgsForCall []struct {
		arg1 int
	}
	findTaskReturns struct {
		result1 director.Task
		result2 error
	}
	findTaskReturnsOnCall map[int]struct {
		result1 director.Task
		result2 error
	}
	FindTasksByContextIdStub        func(string) ([]director.Task, error)
	findTasksByContextIdMutex       sync.RWMutex
	findTasksByContextIdArgsForCall []struct {
		arg1 string
	}
	findTasksByContextIdReturns struct {
		result1 []director.Task
		result2 error
	}
	findTasksByContextIdReturnsOnCall map[int]struct {
		result1 []director.Task
		result2 error
	}
	EventsStub        func(director.EventsFilter) ([]director.Event, error)
	eventsMutex       sync.RWMutex
	eventsArgsForCall []struct {
		arg1 director.EventsFilter
	}
	eventsReturns struct {
		result1 []director.Event
		result2 error
	}
	eventsReturnsOnCall map[int]struct {
		result1 []director.Event
		result2 error
	}
	EventStub        func(string) (director.Event, error)
	eventMutex       sync.RWMutex
	eventArgsForCall []struct {
		arg1 string
	}
	eventReturns struct {
		result1 director.Event
		result2 error
	}
	eventReturnsOnCall map[int]struct {
		result1 director.Event
		result2 error
	}
	DeploymentsStub        func() ([]director.Deployment, error)
	deploymentsMutex       sync.RWMutex
	deploymentsArgsForCall []struct{}
	deploymentsReturns     struct {
		result1 []director.Deployment
		result2 error
	}
	deploymentsReturnsOnCall map[int]struct {
		result1 []director.Deployment
		result2 error
	}
	FindDeploymentStub        func(string) (director.Deployment, error)
	findDeploymentMutex       sync.RWMutex
	findDeploymentArgsForCall []struct {
		arg1 string
	}
	findDeploymentReturns struct {
		result1 director.Deployment
		result2 error
	}
	findDeploymentReturnsOnCall map[int]struct {
		result1 director.Deployment
		result2 error
	}
	ReleasesStub        func() ([]director.Release, error)
	releasesMutex       sync.RWMutex
	releasesArgsForCall []struct{}
	releasesReturns     struct {
		result1 []director.Release
		result2 error
	}
	releasesReturnsOnCall map[int]struct {
		result1 []director.Release
		result2 error
	}
	HasReleaseStub        func(name, version string, stemcell director.OSVersionSlug) (bool, error)
	hasReleaseMutex       sync.RWMutex
	hasReleaseArgsForCall []struct {
		name     string
		version  string
		stemcell director.OSVersionSlug
	}
	hasReleaseReturns struct {
		result1 bool
		result2 error
	}
	hasReleaseReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	FindReleaseStub        func(director.ReleaseSlug) (director.Release, error)
	findReleaseMutex       sync.RWMutex
	findReleaseArgsForCall []struct {
		arg1 director.ReleaseSlug
	}
	findReleaseReturns struct {
		result1 director.Release
		result2 error
	}
	findReleaseReturnsOnCall map[int]struct {
		result1 director.Release
		result2 error
	}
	FindReleaseSeriesStub        func(director.ReleaseSeriesSlug) (director.ReleaseSeries, error)
	findReleaseSeriesMutex       sync.RWMutex
	findReleaseSeriesArgsForCall []struct {
		arg1 director.ReleaseSeriesSlug
	}
	findReleaseSeriesReturns struct {
		result1 director.ReleaseSeries
		result2 error
	}
	findReleaseSeriesReturnsOnCall map[int]struct {
		result1 director.ReleaseSeries
		result2 error
	}
	UploadReleaseURLStub        func(url, sha1 string, rebase, fix bool) error
	uploadReleaseURLMutex       sync.RWMutex
	uploadReleaseURLArgsForCall []struct {
		url    string
		sha1   string
		rebase bool
		fix    bool
	}
	uploadReleaseURLReturns struct {
		result1 error
	}
	uploadReleaseURLReturnsOnCall map[int]struct {
		result1 error
	}
	UploadReleaseFileStub        func(file director.UploadFile, rebase, fix bool) error
	uploadReleaseFileMutex       sync.RWMutex
	uploadReleaseFileArgsForCall []struct {
		file   director.UploadFile
		rebase bool
		fix    bool
	}
	uploadReleaseFileReturns struct {
		result1 error
	}
	uploadReleaseFileReturnsOnCall map[int]struct {
		result1 error
	}
	MatchPackagesStub        func(manifest interface{}, compiled bool) ([]string, error)
	matchPackagesMutex       sync.RWMutex
	matchPackagesArgsForCall []struct {
		manifest interface{}
		compiled bool
	}
	matchPackagesReturns struct {
		result1 []string
		result2 error
	}
	matchPackagesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	StemcellsStub        func() ([]director.Stemcell, error)
	stemcellsMutex       sync.RWMutex
	stemcellsArgsForCall []struct{}
	stemcellsReturns     struct {
		result1 []director.Stemcell
		result2 error
	}
	stemcellsReturnsOnCall map[int]struct {
		result1 []director.Stemcell
		result2 error
	}
	HasStemcellStub        func(name, version string) (bool, error)
	hasStemcellMutex       sync.RWMutex
	hasStemcellArgsForCall []struct {
		name    string
		version string
	}
	hasStemcellReturns struct {
		result1 bool
		result2 error
	}
	hasStemcellReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	StemcellNeedsUploadStub        func(director.StemcellInfo) (bool, bool, error)
	stemcellNeedsUploadMutex       sync.RWMutex
	stemcellNeedsUploadArgsForCall []struct {
		arg1 director.StemcellInfo
	}
	stemcellNeedsUploadReturns struct {
		result1 bool
		result2 bool
		result3 error
	}
	stemcellNeedsUploadReturnsOnCall map[int]struct {
		result1 bool
		result2 bool
		result3 error
	}
	FindStemcellStub        func(director.StemcellSlug) (director.Stemcell, error)
	findStemcellMutex       sync.RWMutex
	findStemcellArgsForCall []struct {
		arg1 director.StemcellSlug
	}
	findStemcellReturns struct {
		result1 director.Stemcell
		result2 error
	}
	findStemcellReturnsOnCall map[int]struct {
		result1 director.Stemcell
		result2 error
	}
	UploadStemcellURLStub        func(url, sha1 string, fix bool) error
	uploadStemcellURLMutex       sync.RWMutex
	uploadStemcellURLArgsForCall []struct {
		url  string
		sha1 string
		fix  bool
	}
	uploadStemcellURLReturns struct {
		result1 error
	}
	uploadStemcellURLReturnsOnCall map[int]struct {
		result1 error
	}
	UploadStemcellFileStub        func(file director.UploadFile, fix bool) error
	uploadStemcellFileMutex       sync.RWMutex
	uploadStemcellFileArgsForCall []struct {
		file director.UploadFile
		fix  bool
	}
	uploadStemcellFileReturns struct {
		result1 error
	}
	uploadStemcellFileReturnsOnCall map[int]struct {
		result1 error
	}
	LatestConfigStub        func(configType string, name string) (director.Config, error)
	latestConfigMutex       sync.RWMutex
	latestConfigArgsForCall []struct {
		configType string
		name       string
	}
	latestConfigReturns struct {
		result1 director.Config
		result2 error
	}
	latestConfigReturnsOnCall map[int]struct {
		result1 director.Config
		result2 error
	}
	LatestConfigByIDStub        func(configID string) (director.Config, error)
	latestConfigByIDMutex       sync.RWMutex
	latestConfigByIDArgsForCall []struct {
		configID string
	}
	latestConfigByIDReturns struct {
		result1 director.Config
		result2 error
	}
	latestConfigByIDReturnsOnCall map[int]struct {
		result1 director.Config
		result2 error
	}
	ListConfigsStub        func(limit int, filter director.ConfigsFilter) ([]director.Config, error)
	listConfigsMutex       sync.RWMutex
	listConfigsArgsForCall []struct {
		limit  int
		filter director.ConfigsFilter
	}
	listConfigsReturns struct {
		result1 []director.Config
		result2 error
	}
	listConfigsReturnsOnCall map[int]struct {
		result1 []director.Config
		result2 error
	}
	UpdateConfigStub        func(configType string, name string, content []byte) (director.Config, error)
	updateConfigMutex       sync.RWMutex
	updateConfigArgsForCall []struct {
		configType string
		name       string
		content    []byte
	}
	updateConfigReturns struct {
		result1 director.Config
		result2 error
	}
	updateConfigReturnsOnCall map[int]struct {
		result1 director.Config
		result2 error
	}
	DeleteConfigStub        func(configType string, name string) (bool, error)
	deleteConfigMutex       sync.RWMutex
	deleteConfigArgsForCall []struct {
		configType string
		name       string
	}
	deleteConfigReturns struct {
		result1 bool
		result2 error
	}
	deleteConfigReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DeleteConfigByIDStub        func(configID string) (bool, error)
	deleteConfigByIDMutex       sync.RWMutex
	deleteConfigByIDArgsForCall []struct {
		configID string
	}
	deleteConfigByIDReturns struct {
		result1 bool
		result2 error
	}
	deleteConfigByIDReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DiffConfigStub        func(configType string, name string, manifest []byte) (director.ConfigDiff, error)
	diffConfigMutex       sync.RWMutex
	diffConfigArgsForCall []struct {
		configType string
		name       string
		manifest   []byte
	}
	diffConfigReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffConfigReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	DiffConfigByIDStub        func(fromID string, toID string) (director.ConfigDiff, error)
	diffConfigByIDMutex       sync.RWMutex
	diffConfigByIDArgsForCall []struct {
		fromID string
		toID   string
	}
	diffConfigByIDReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffConfigByIDReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	LatestCloudConfigStub        func() (director.CloudConfig, error)
	latestCloudConfigMutex       sync.RWMutex
	latestCloudConfigArgsForCall []struct{}
	latestCloudConfigReturns     struct {
		result1 director.CloudConfig
		result2 error
	}
	latestCloudConfigReturnsOnCall map[int]struct {
		result1 director.CloudConfig
		result2 error
	}
	UpdateCloudConfigStub        func([]byte) error
	updateCloudConfigMutex       sync.RWMutex
	updateCloudConfigArgsForCall []struct {
		arg1 []byte
	}
	updateCloudConfigReturns struct {
		result1 error
	}
	updateCloudConfigReturnsOnCall map[int]struct {
		result1 error
	}
	DiffCloudConfigStub        func(manifest []byte) (director.ConfigDiff, error)
	diffCloudConfigMutex       sync.RWMutex
	diffCloudConfigArgsForCall []struct {
		manifest []byte
	}
	diffCloudConfigReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffCloudConfigReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	LatestCPIConfigStub        func() (director.CPIConfig, error)
	latestCPIConfigMutex       sync.RWMutex
	latestCPIConfigArgsForCall []struct{}
	latestCPIConfigReturns     struct {
		result1 director.CPIConfig
		result2 error
	}
	latestCPIConfigReturnsOnCall map[int]struct {
		result1 director.CPIConfig
		result2 error
	}
	UpdateCPIConfigStub        func([]byte) error
	updateCPIConfigMutex       sync.RWMutex
	updateCPIConfigArgsForCall []struct {
		arg1 []byte
	}
	updateCPIConfigReturns struct {
		result1 error
	}
	updateCPIConfigReturnsOnCall map[int]struct {
		result1 error
	}
	DiffCPIConfigStub        func(manifest []byte, noRedact bool) (director.ConfigDiff, error)
	diffCPIConfigMutex       sync.RWMutex
	diffCPIConfigArgsForCall []struct {
		manifest []byte
		noRedact bool
	}
	diffCPIConfigReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffCPIConfigReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	LatestRuntimeConfigStub        func(name string) (director.RuntimeConfig, error)
	latestRuntimeConfigMutex       sync.RWMutex
	latestRuntimeConfigArgsForCall []struct {
		name string
	}
	latestRuntimeConfigReturns struct {
		result1 director.RuntimeConfig
		result2 error
	}
	latestRuntimeConfigReturnsOnCall map[int]struct {
		result1 director.RuntimeConfig
		result2 error
	}
	UpdateRuntimeConfigStub        func(name string, manifest []byte) error
	updateRuntimeConfigMutex       sync.RWMutex
	updateRuntimeConfigArgsForCall []struct {
		name     string
		manifest []byte
	}
	updateRuntimeConfigReturns struct {
		result1 error
	}
	updateRuntimeConfigReturnsOnCall map[int]struct {
		result1 error
	}
	DiffRuntimeConfigStub        func(name string, manifest []byte, noRedact bool) (director.ConfigDiff, error)
	diffRuntimeConfigMutex       sync.RWMutex
	diffRuntimeConfigArgsForCall []struct {
		name     string
		manifest []byte
		noRedact bool
	}
	diffRuntimeConfigReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffRuntimeConfigReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	FindOrphanDiskStub        func(string) (director.OrphanDisk, error)
	findOrphanDiskMutex       sync.RWMutex
	findOrphanDiskArgsForCall []struct {
		arg1 string
	}
	findOrphanDiskReturns struct {
		result1 director.OrphanDisk
		result2 error
	}
	findOrphanDiskReturnsOnCall map[int]struct {
		result1 director.OrphanDisk
		result2 error
	}
	OrphanDisksStub        func() ([]director.OrphanDisk, error)
	orphanDisksMutex       sync.RWMutex
	orphanDisksArgsForCall []struct{}
	orphanDisksReturns     struct {
		result1 []director.OrphanDisk
		result2 error
	}
	orphanDisksReturnsOnCall map[int]struct {
		result1 []director.OrphanDisk
		result2 error
	}
	OrphanDiskStub        func(string) error
	orphanDiskMutex       sync.RWMutex
	orphanDiskArgsForCall []struct {
		arg1 string
	}
	orphanDiskReturns struct {
		result1 error
	}
	orphanDiskReturnsOnCall map[int]struct {
		result1 error
	}
	EnableResurrectionStub        func(bool) error
	enableResurrectionMutex       sync.RWMutex
	enableResurrectionArgsForCall []struct {
		arg1 bool
	}
	enableResurrectionReturns struct {
		result1 error
	}
	enableResurrectionReturnsOnCall map[int]struct {
		result1 error
	}
	CleanUpStub        func(bool) error
	cleanUpMutex       sync.RWMutex
	cleanUpArgsForCall []struct {
		arg1 bool
	}
	cleanUpReturns struct {
		result1 error
	}
	cleanUpReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadResourceUncheckedStub        func(blobstoreID string, out io.Writer) error
	downloadResourceUncheckedMutex       sync.RWMutex
	downloadResourceUncheckedArgsForCall []struct {
		blobstoreID string
		out         io.Writer
	}
	downloadResourceUncheckedReturns struct {
		result1 error
	}
	downloadResourceUncheckedReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDirector) IsAuthenticated() (bool, error) {
	fake.isAuthenticatedMutex.Lock()
	ret, specificReturn := fake.isAuthenticatedReturnsOnCall[len(fake.isAuthenticatedArgsForCall)]
	fake.isAuthenticatedArgsForCall = append(fake.isAuthenticatedArgsForCall, struct{}{})
	fake.recordInvocation("IsAuthenticated", []interface{}{})
	fake.isAuthenticatedMutex.Unlock()
	if fake.IsAuthenticatedStub != nil {
		return fake.IsAuthenticatedStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.isAuthenticatedReturns.result1, fake.isAuthenticatedReturns.result2
}

func (fake *FakeDirector) IsAuthenticatedCallCount() int {
	fake.isAuthenticatedMutex.RLock()
	defer fake.isAuthenticatedMutex.RUnlock()
	return len(fake.isAuthenticatedArgsForCall)
}

func (fake *FakeDirector) IsAuthenticatedReturns(result1 bool, result2 error) {
	fake.IsAuthenticatedStub = nil
	fake.isAuthenticatedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) IsAuthenticatedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.IsAuthenticatedStub = nil
	if fake.isAuthenticatedReturnsOnCall == nil {
		fake.isAuthenticatedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isAuthenticatedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) WithContext(id string) director.Director {
	fake.withContextMutex.Lock()
	ret, specificReturn := fake.withContextReturnsOnCall[len(fake.withContextArgsForCall)]
	fake.withContextArgsForCall = append(fake.withContextArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("WithContext", []interface{}{id})
	fake.withContextMutex.Unlock()
	if fake.WithContextStub != nil {
		return fake.WithContextStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.withContextReturns.result1
}

func (fake *FakeDirector) WithContextCallCount() int {
	fake.withContextMutex.RLock()
	defer fake.withContextMutex.RUnlock()
	return len(fake.withContextArgsForCall)
}

func (fake *FakeDirector) WithContextArgsForCall(i int) string {
	fake.withContextMutex.RLock()
	defer fake.withContextMutex.RUnlock()
	return fake.withContextArgsForCall[i].id
}

func (fake *FakeDirector) WithContextReturns(result1 director.Director) {
	fake.WithContextStub = nil
	fake.withContextReturns = struct {
		result1 director.Director
	}{result1}
}

func (fake *FakeDirector) WithContextReturnsOnCall(i int, result1 director.Director) {
	fake.WithContextStub = nil
	if fake.withContextReturnsOnCall == nil {
		fake.withContextReturnsOnCall = make(map[int]struct {
			result1 director.Director
		})
	}
	fake.withContextReturnsOnCall[i] = struct {
		result1 director.Director
	}{result1}
}

func (fake *FakeDirector) Info() (director.Info, error) {
	fake.infoMutex.Lock()
	ret, specificReturn := fake.infoReturnsOnCall[len(fake.infoArgsForCall)]
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct{}{})
	fake.recordInvocation("Info", []interface{}{})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		return fake.InfoStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.infoReturns.result1, fake.infoReturns.result2
}

func (fake *FakeDirector) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeDirector) InfoReturns(result1 director.Info, result2 error) {
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 director.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) InfoReturnsOnCall(i int, result1 director.Info, result2 error) {
	fake.InfoStub = nil
	if fake.infoReturnsOnCall == nil {
		fake.infoReturnsOnCall = make(map[int]struct {
			result1 director.Info
			result2 error
		})
	}
	fake.infoReturnsOnCall[i] = struct {
		result1 director.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Locks() ([]director.Lock, error) {
	fake.locksMutex.Lock()
	ret, specificReturn := fake.locksReturnsOnCall[len(fake.locksArgsForCall)]
	fake.locksArgsForCall = append(fake.locksArgsForCall, struct{}{})
	fake.recordInvocation("Locks", []interface{}{})
	fake.locksMutex.Unlock()
	if fake.LocksStub != nil {
		return fake.LocksStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.locksReturns.result1, fake.locksReturns.result2
}

func (fake *FakeDirector) LocksCallCount() int {
	fake.locksMutex.RLock()
	defer fake.locksMutex.RUnlock()
	return len(fake.locksArgsForCall)
}

func (fake *FakeDirector) LocksReturns(result1 []director.Lock, result2 error) {
	fake.LocksStub = nil
	fake.locksReturns = struct {
		result1 []director.Lock
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LocksReturnsOnCall(i int, result1 []director.Lock, result2 error) {
	fake.LocksStub = nil
	if fake.locksReturnsOnCall == nil {
		fake.locksReturnsOnCall = make(map[int]struct {
			result1 []director.Lock
			result2 error
		})
	}
	fake.locksReturnsOnCall[i] = struct {
		result1 []director.Lock
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) CurrentTasks(arg1 director.TasksFilter) ([]director.Task, error) {
	fake.currentTasksMutex.Lock()
	ret, specificReturn := fake.currentTasksReturnsOnCall[len(fake.currentTasksArgsForCall)]
	fake.currentTasksArgsForCall = append(fake.currentTasksArgsForCall, struct {
		arg1 director.TasksFilter
	}{arg1})
	fake.recordInvocation("CurrentTasks", []interface{}{arg1})
	fake.currentTasksMutex.Unlock()
	if fake.CurrentTasksStub != nil {
		return fake.CurrentTasksStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.currentTasksReturns.result1, fake.currentTasksReturns.result2
}

func (fake *FakeDirector) CurrentTasksCallCount() int {
	fake.currentTasksMutex.RLock()
	defer fake.currentTasksMutex.RUnlock()
	return len(fake.currentTasksArgsForCall)
}

func (fake *FakeDirector) CurrentTasksArgsForCall(i int) director.TasksFilter {
	fake.currentTasksMutex.RLock()
	defer fake.currentTasksMutex.RUnlock()
	return fake.currentTasksArgsForCall[i].arg1
}

func (fake *FakeDirector) CurrentTasksReturns(result1 []director.Task, result2 error) {
	fake.CurrentTasksStub = nil
	fake.currentTasksReturns = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) CurrentTasksReturnsOnCall(i int, result1 []director.Task, result2 error) {
	fake.CurrentTasksStub = nil
	if fake.currentTasksReturnsOnCall == nil {
		fake.currentTasksReturnsOnCall = make(map[int]struct {
			result1 []director.Task
			result2 error
		})
	}
	fake.currentTasksReturnsOnCall[i] = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) RecentTasks(arg1 int, arg2 director.TasksFilter) ([]director.Task, error) {
	fake.recentTasksMutex.Lock()
	ret, specificReturn := fake.recentTasksReturnsOnCall[len(fake.recentTasksArgsForCall)]
	fake.recentTasksArgsForCall = append(fake.recentTasksArgsForCall, struct {
		arg1 int
		arg2 director.TasksFilter
	}{arg1, arg2})
	fake.recordInvocation("RecentTasks", []interface{}{arg1, arg2})
	fake.recentTasksMutex.Unlock()
	if fake.RecentTasksStub != nil {
		return fake.RecentTasksStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.recentTasksReturns.result1, fake.recentTasksReturns.result2
}

func (fake *FakeDirector) RecentTasksCallCount() int {
	fake.recentTasksMutex.RLock()
	defer fake.recentTasksMutex.RUnlock()
	return len(fake.recentTasksArgsForCall)
}

func (fake *FakeDirector) RecentTasksArgsForCall(i int) (int, director.TasksFilter) {
	fake.recentTasksMutex.RLock()
	defer fake.recentTasksMutex.RUnlock()
	return fake.recentTasksArgsForCall[i].arg1, fake.recentTasksArgsForCall[i].arg2
}

func (fake *FakeDirector) RecentTasksReturns(result1 []director.Task, result2 error) {
	fake.RecentTasksStub = nil
	fake.recentTasksReturns = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) RecentTasksReturnsOnCall(i int, result1 []director.Task, result2 error) {
	fake.RecentTasksStub = nil
	if fake.recentTasksReturnsOnCall == nil {
		fake.recentTasksReturnsOnCall = make(map[int]struct {
			result1 []director.Task
			result2 error
		})
	}
	fake.recentTasksReturnsOnCall[i] = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindTask(arg1 int) (director.Task, error) {
	fake.findTaskMutex.Lock()
	ret, specificReturn := fake.findTaskReturnsOnCall[len(fake.findTaskArgsForCall)]
	fake.findTaskArgsForCall = append(fake.findTaskArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("FindTask", []interface{}{arg1})
	fake.findTaskMutex.Unlock()
	if fake.FindTaskStub != nil {
		return fake.FindTaskStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findTaskReturns.result1, fake.findTaskReturns.result2
}

func (fake *FakeDirector) FindTaskCallCount() int {
	fake.findTaskMutex.RLock()
	defer fake.findTaskMutex.RUnlock()
	return len(fake.findTaskArgsForCall)
}

func (fake *FakeDirector) FindTaskArgsForCall(i int) int {
	fake.findTaskMutex.RLock()
	defer fake.findTaskMutex.RUnlock()
	return fake.findTaskArgsForCall[i].arg1
}

func (fake *FakeDirector) FindTaskReturns(result1 director.Task, result2 error) {
	fake.FindTaskStub = nil
	fake.findTaskReturns = struct {
		result1 director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindTaskReturnsOnCall(i int, result1 director.Task, result2 error) {
	fake.FindTaskStub = nil
	if fake.findTaskReturnsOnCall == nil {
		fake.findTaskReturnsOnCall = make(map[int]struct {
			result1 director.Task
			result2 error
		})
	}
	fake.findTaskReturnsOnCall[i] = struct {
		result1 director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindTasksByContextId(arg1 string) ([]director.Task, error) {
	fake.findTasksByContextIdMutex.Lock()
	ret, specificReturn := fake.findTasksByContextIdReturnsOnCall[len(fake.findTasksByContextIdArgsForCall)]
	fake.findTasksByContextIdArgsForCall = append(fake.findTasksByContextIdArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindTasksByContextId", []interface{}{arg1})
	fake.findTasksByContextIdMutex.Unlock()
	if fake.FindTasksByContextIdStub != nil {
		return fake.FindTasksByContextIdStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findTasksByContextIdReturns.result1, fake.findTasksByContextIdReturns.result2
}

func (fake *FakeDirector) FindTasksByContextIdCallCount() int {
	fake.findTasksByContextIdMutex.RLock()
	defer fake.findTasksByContextIdMutex.RUnlock()
	return len(fake.findTasksByContextIdArgsForCall)
}

func (fake *FakeDirector) FindTasksByContextIdArgsForCall(i int) string {
	fake.findTasksByContextIdMutex.RLock()
	defer fake.findTasksByContextIdMutex.RUnlock()
	return fake.findTasksByContextIdArgsForCall[i].arg1
}

func (fake *FakeDirector) FindTasksByContextIdReturns(result1 []director.Task, result2 error) {
	fake.FindTasksByContextIdStub = nil
	fake.findTasksByContextIdReturns = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindTasksByContextIdReturnsOnCall(i int, result1 []director.Task, result2 error) {
	fake.FindTasksByContextIdStub = nil
	if fake.findTasksByContextIdReturnsOnCall == nil {
		fake.findTasksByContextIdReturnsOnCall = make(map[int]struct {
			result1 []director.Task
			result2 error
		})
	}
	fake.findTasksByContextIdReturnsOnCall[i] = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Events(arg1 director.EventsFilter) ([]director.Event, error) {
	fake.eventsMutex.Lock()
	ret, specificReturn := fake.eventsReturnsOnCall[len(fake.eventsArgsForCall)]
	fake.eventsArgsForCall = append(fake.eventsArgsForCall, struct {
		arg1 director.EventsFilter
	}{arg1})
	fake.recordInvocation("Events", []interface{}{arg1})
	fake.eventsMutex.Unlock()
	if fake.EventsStub != nil {
		return fake.EventsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.eventsReturns.result1, fake.eventsReturns.result2
}

func (fake *FakeDirector) EventsCallCount() int {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return len(fake.eventsArgsForCall)
}

func (fake *FakeDirector) EventsArgsForCall(i int) director.EventsFilter {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return fake.eventsArgsForCall[i].arg1
}

func (fake *FakeDirector) EventsReturns(result1 []director.Event, result2 error) {
	fake.EventsStub = nil
	fake.eventsReturns = struct {
		result1 []director.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) EventsReturnsOnCall(i int, result1 []director.Event, result2 error) {
	fake.EventsStub = nil
	if fake.eventsReturnsOnCall == nil {
		fake.eventsReturnsOnCall = make(map[int]struct {
			result1 []director.Event
			result2 error
		})
	}
	fake.eventsReturnsOnCall[i] = struct {
		result1 []director.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Event(arg1 string) (director.Event, error) {
	fake.eventMutex.Lock()
	ret, specificReturn := fake.eventReturnsOnCall[len(fake.eventArgsForCall)]
	fake.eventArgsForCall = append(fake.eventArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Event", []interface{}{arg1})
	fake.eventMutex.Unlock()
	if fake.EventStub != nil {
		return fake.EventStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.eventReturns.result1, fake.eventReturns.result2
}

func (fake *FakeDirector) EventCallCount() int {
	fake.eventMutex.RLock()
	defer fake.eventMutex.RUnlock()
	return len(fake.eventArgsForCall)
}

func (fake *FakeDirector) EventArgsForCall(i int) string {
	fake.eventMutex.RLock()
	defer fake.eventMutex.RUnlock()
	return fake.eventArgsForCall[i].arg1
}

func (fake *FakeDirector) EventReturns(result1 director.Event, result2 error) {
	fake.EventStub = nil
	fake.eventReturns = struct {
		result1 director.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) EventReturnsOnCall(i int, result1 director.Event, result2 error) {
	fake.EventStub = nil
	if fake.eventReturnsOnCall == nil {
		fake.eventReturnsOnCall = make(map[int]struct {
			result1 director.Event
			result2 error
		})
	}
	fake.eventReturnsOnCall[i] = struct {
		result1 director.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Deployments() ([]director.Deployment, error) {
	fake.deploymentsMutex.Lock()
	ret, specificReturn := fake.deploymentsReturnsOnCall[len(fake.deploymentsArgsForCall)]
	fake.deploymentsArgsForCall = append(fake.deploymentsArgsForCall, struct{}{})
	fake.recordInvocation("Deployments", []interface{}{})
	fake.deploymentsMutex.Unlock()
	if fake.DeploymentsStub != nil {
		return fake.DeploymentsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deploymentsReturns.result1, fake.deploymentsReturns.result2
}

func (fake *FakeDirector) DeploymentsCallCount() int {
	fake.deploymentsMutex.RLock()
	defer fake.deploymentsMutex.RUnlock()
	return len(fake.deploymentsArgsForCall)
}

func (fake *FakeDirector) DeploymentsReturns(result1 []director.Deployment, result2 error) {
	fake.DeploymentsStub = nil
	fake.deploymentsReturns = struct {
		result1 []director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeploymentsReturnsOnCall(i int, result1 []director.Deployment, result2 error) {
	fake.DeploymentsStub = nil
	if fake.deploymentsReturnsOnCall == nil {
		fake.deploymentsReturnsOnCall = make(map[int]struct {
			result1 []director.Deployment
			result2 error
		})
	}
	fake.deploymentsReturnsOnCall[i] = struct {
		result1 []director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindDeployment(arg1 string) (director.Deployment, error) {
	fake.findDeploymentMutex.Lock()
	ret, specificReturn := fake.findDeploymentReturnsOnCall[len(fake.findDeploymentArgsForCall)]
	fake.findDeploymentArgsForCall = append(fake.findDeploymentArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindDeployment", []interface{}{arg1})
	fake.findDeploymentMutex.Unlock()
	if fake.FindDeploymentStub != nil {
		return fake.FindDeploymentStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findDeploymentReturns.result1, fake.findDeploymentReturns.result2
}

func (fake *FakeDirector) FindDeploymentCallCount() int {
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	return len(fake.findDeploymentArgsForCall)
}

func (fake *FakeDirector) FindDeploymentArgsForCall(i int) string {
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	return fake.findDeploymentArgsForCall[i].arg1
}

func (fake *FakeDirector) FindDeploymentReturns(result1 director.Deployment, result2 error) {
	fake.FindDeploymentStub = nil
	fake.findDeploymentReturns = struct {
		result1 director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindDeploymentReturnsOnCall(i int, result1 director.Deployment, result2 error) {
	fake.FindDeploymentStub = nil
	if fake.findDeploymentReturnsOnCall == nil {
		fake.findDeploymentReturnsOnCall = make(map[int]struct {
			result1 director.Deployment
			result2 error
		})
	}
	fake.findDeploymentReturnsOnCall[i] = struct {
		result1 director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Releases() ([]director.Release, error) {
	fake.releasesMutex.Lock()
	ret, specificReturn := fake.releasesReturnsOnCall[len(fake.releasesArgsForCall)]
	fake.releasesArgsForCall = append(fake.releasesArgsForCall, struct{}{})
	fake.recordInvocation("Releases", []interface{}{})
	fake.releasesMutex.Unlock()
	if fake.ReleasesStub != nil {
		return fake.ReleasesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.releasesReturns.result1, fake.releasesReturns.result2
}

func (fake *FakeDirector) ReleasesCallCount() int {
	fake.releasesMutex.RLock()
	defer fake.releasesMutex.RUnlock()
	return len(fake.releasesArgsForCall)
}

func (fake *FakeDirector) ReleasesReturns(result1 []director.Release, result2 error) {
	fake.ReleasesStub = nil
	fake.releasesReturns = struct {
		result1 []director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ReleasesReturnsOnCall(i int, result1 []director.Release, result2 error) {
	fake.ReleasesStub = nil
	if fake.releasesReturnsOnCall == nil {
		fake.releasesReturnsOnCall = make(map[int]struct {
			result1 []director.Release
			result2 error
		})
	}
	fake.releasesReturnsOnCall[i] = struct {
		result1 []director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) HasRelease(name string, version string, stemcell director.OSVersionSlug) (bool, error) {
	fake.hasReleaseMutex.Lock()
	ret, specificReturn := fake.hasReleaseReturnsOnCall[len(fake.hasReleaseArgsForCall)]
	fake.hasReleaseArgsForCall = append(fake.hasReleaseArgsForCall, struct {
		name     string
		version  string
		stemcell director.OSVersionSlug
	}{name, version, stemcell})
	fake.recordInvocation("HasRelease", []interface{}{name, version, stemcell})
	fake.hasReleaseMutex.Unlock()
	if fake.HasReleaseStub != nil {
		return fake.HasReleaseStub(name, version, stemcell)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.hasReleaseReturns.result1, fake.hasReleaseReturns.result2
}

func (fake *FakeDirector) HasReleaseCallCount() int {
	fake.hasReleaseMutex.RLock()
	defer fake.hasReleaseMutex.RUnlock()
	return len(fake.hasReleaseArgsForCall)
}

func (fake *FakeDirector) HasReleaseArgsForCall(i int) (string, string, director.OSVersionSlug) {
	fake.hasReleaseMutex.RLock()
	defer fake.hasReleaseMutex.RUnlock()
	return fake.hasReleaseArgsForCall[i].name, fake.hasReleaseArgsForCall[i].version, fake.hasReleaseArgsForCall[i].stemcell
}

func (fake *FakeDirector) HasReleaseReturns(result1 bool, result2 error) {
	fake.HasReleaseStub = nil
	fake.hasReleaseReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) HasReleaseReturnsOnCall(i int, result1 bool, result2 error) {
	fake.HasReleaseStub = nil
	if fake.hasReleaseReturnsOnCall == nil {
		fake.hasReleaseReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasReleaseReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindRelease(arg1 director.ReleaseSlug) (director.Release, error) {
	fake.findReleaseMutex.Lock()
	ret, specificReturn := fake.findReleaseReturnsOnCall[len(fake.findReleaseArgsForCall)]
	fake.findReleaseArgsForCall = append(fake.findReleaseArgsForCall, struct {
		arg1 director.ReleaseSlug
	}{arg1})
	fake.recordInvocation("FindRelease", []interface{}{arg1})
	fake.findReleaseMutex.Unlock()
	if fake.FindReleaseStub != nil {
		return fake.FindReleaseStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findReleaseReturns.result1, fake.findReleaseReturns.result2
}

func (fake *FakeDirector) FindReleaseCallCount() int {
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	return len(fake.findReleaseArgsForCall)
}

func (fake *FakeDirector) FindReleaseArgsForCall(i int) director.ReleaseSlug {
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	return fake.findReleaseArgsForCall[i].arg1
}

func (fake *FakeDirector) FindReleaseReturns(result1 director.Release, result2 error) {
	fake.FindReleaseStub = nil
	fake.findReleaseReturns = struct {
		result1 director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindReleaseReturnsOnCall(i int, result1 director.Release, result2 error) {
	fake.FindReleaseStub = nil
	if fake.findReleaseReturnsOnCall == nil {
		fake.findReleaseReturnsOnCall = make(map[int]struct {
			result1 director.Release
			result2 error
		})
	}
	fake.findReleaseReturnsOnCall[i] = struct {
		result1 director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindReleaseSeries(arg1 director.ReleaseSeriesSlug) (director.ReleaseSeries, error) {
	fake.findReleaseSeriesMutex.Lock()
	ret, specificReturn := fake.findReleaseSeriesReturnsOnCall[len(fake.findReleaseSeriesArgsForCall)]
	fake.findReleaseSeriesArgsForCall = append(fake.findReleaseSeriesArgsForCall, struct {
		arg1 director.ReleaseSeriesSlug
	}{arg1})
	fake.recordInvocation("FindReleaseSeries", []interface{}{arg1})
	fake.findReleaseSeriesMutex.Unlock()
	if fake.FindReleaseSeriesStub != nil {
		return fake.FindReleaseSeriesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findReleaseSeriesReturns.result1, fake.findReleaseSeriesReturns.result2
}

func (fake *FakeDirector) FindReleaseSeriesCallCount() int {
	fake.findReleaseSeriesMutex.RLock()
	defer fake.findReleaseSeriesMutex.RUnlock()
	return len(fake.findReleaseSeriesArgsForCall)
}

func (fake *FakeDirector) FindReleaseSeriesArgsForCall(i int) director.ReleaseSeriesSlug {
	fake.findReleaseSeriesMutex.RLock()
	defer fake.findReleaseSeriesMutex.RUnlock()
	return fake.findReleaseSeriesArgsForCall[i].arg1
}

func (fake *FakeDirector) FindReleaseSeriesReturns(result1 director.ReleaseSeries, result2 error) {
	fake.FindReleaseSeriesStub = nil
	fake.findReleaseSeriesReturns = struct {
		result1 director.ReleaseSeries
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindReleaseSeriesReturnsOnCall(i int, result1 director.ReleaseSeries, result2 error) {
	fake.FindReleaseSeriesStub = nil
	if fake.findReleaseSeriesReturnsOnCall == nil {
		fake.findReleaseSeriesReturnsOnCall = make(map[int]struct {
			result1 director.ReleaseSeries
			result2 error
		})
	}
	fake.findReleaseSeriesReturnsOnCall[i] = struct {
		result1 director.ReleaseSeries
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UploadReleaseURL(url string, sha1 string, rebase bool, fix bool) error {
	fake.uploadReleaseURLMutex.Lock()
	ret, specificReturn := fake.uploadReleaseURLReturnsOnCall[len(fake.uploadReleaseURLArgsForCall)]
	fake.uploadReleaseURLArgsForCall = append(fake.uploadReleaseURLArgsForCall, struct {
		url    string
		sha1   string
		rebase bool
		fix    bool
	}{url, sha1, rebase, fix})
	fake.recordInvocation("UploadReleaseURL", []interface{}{url, sha1, rebase, fix})
	fake.uploadReleaseURLMutex.Unlock()
	if fake.UploadReleaseURLStub != nil {
		return fake.UploadReleaseURLStub(url, sha1, rebase, fix)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.uploadReleaseURLReturns.result1
}

func (fake *FakeDirector) UploadReleaseURLCallCount() int {
	fake.uploadReleaseURLMutex.RLock()
	defer fake.uploadReleaseURLMutex.RUnlock()
	return len(fake.uploadReleaseURLArgsForCall)
}

func (fake *FakeDirector) UploadReleaseURLArgsForCall(i int) (string, string, bool, bool) {
	fake.uploadReleaseURLMutex.RLock()
	defer fake.uploadReleaseURLMutex.RUnlock()
	return fake.uploadReleaseURLArgsForCall[i].url, fake.uploadReleaseURLArgsForCall[i].sha1, fake.uploadReleaseURLArgsForCall[i].rebase, fake.uploadReleaseURLArgsForCall[i].fix
}

func (fake *FakeDirector) UploadReleaseURLReturns(result1 error) {
	fake.UploadReleaseURLStub = nil
	fake.uploadReleaseURLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadReleaseURLReturnsOnCall(i int, result1 error) {
	fake.UploadReleaseURLStub = nil
	if fake.uploadReleaseURLReturnsOnCall == nil {
		fake.uploadReleaseURLReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadReleaseURLReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadReleaseFile(file director.UploadFile, rebase bool, fix bool) error {
	fake.uploadReleaseFileMutex.Lock()
	ret, specificReturn := fake.uploadReleaseFileReturnsOnCall[len(fake.uploadReleaseFileArgsForCall)]
	fake.uploadReleaseFileArgsForCall = append(fake.uploadReleaseFileArgsForCall, struct {
		file   director.UploadFile
		rebase bool
		fix    bool
	}{file, rebase, fix})
	fake.recordInvocation("UploadReleaseFile", []interface{}{file, rebase, fix})
	fake.uploadReleaseFileMutex.Unlock()
	if fake.UploadReleaseFileStub != nil {
		return fake.UploadReleaseFileStub(file, rebase, fix)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.uploadReleaseFileReturns.result1
}

func (fake *FakeDirector) UploadReleaseFileCallCount() int {
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	return len(fake.uploadReleaseFileArgsForCall)
}

func (fake *FakeDirector) UploadReleaseFileArgsForCall(i int) (director.UploadFile, bool, bool) {
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	return fake.uploadReleaseFileArgsForCall[i].file, fake.uploadReleaseFileArgsForCall[i].rebase, fake.uploadReleaseFileArgsForCall[i].fix
}

func (fake *FakeDirector) UploadReleaseFileReturns(result1 error) {
	fake.UploadReleaseFileStub = nil
	fake.uploadReleaseFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadReleaseFileReturnsOnCall(i int, result1 error) {
	fake.UploadReleaseFileStub = nil
	if fake.uploadReleaseFileReturnsOnCall == nil {
		fake.uploadReleaseFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadReleaseFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) MatchPackages(manifest interface{}, compiled bool) ([]string, error) {
	fake.matchPackagesMutex.Lock()
	ret, specificReturn := fake.matchPackagesReturnsOnCall[len(fake.matchPackagesArgsForCall)]
	fake.matchPackagesArgsForCall = append(fake.matchPackagesArgsForCall, struct {
		manifest interface{}
		compiled bool
	}{manifest, compiled})
	fake.recordInvocation("MatchPackages", []interface{}{manifest, compiled})
	fake.matchPackagesMutex.Unlock()
	if fake.MatchPackagesStub != nil {
		return fake.MatchPackagesStub(manifest, compiled)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.matchPackagesReturns.result1, fake.matchPackagesReturns.result2
}

func (fake *FakeDirector) MatchPackagesCallCount() int {
	fake.matchPackagesMutex.RLock()
	defer fake.matchPackagesMutex.RUnlock()
	return len(fake.matchPackagesArgsForCall)
}

func (fake *FakeDirector) MatchPackagesArgsForCall(i int) (interface{}, bool) {
	fake.matchPackagesMutex.RLock()
	defer fake.matchPackagesMutex.RUnlock()
	return fake.matchPackagesArgsForCall[i].manifest, fake.matchPackagesArgsForCall[i].compiled
}

func (fake *FakeDirector) MatchPackagesReturns(result1 []string, result2 error) {
	fake.MatchPackagesStub = nil
	fake.matchPackagesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) MatchPackagesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.MatchPackagesStub = nil
	if fake.matchPackagesReturnsOnCall == nil {
		fake.matchPackagesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.matchPackagesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Stemcells() ([]director.Stemcell, error) {
	fake.stemcellsMutex.Lock()
	ret, specificReturn := fake.stemcellsReturnsOnCall[len(fake.stemcellsArgsForCall)]
	fake.stemcellsArgsForCall = append(fake.stemcellsArgsForCall, struct{}{})
	fake.recordInvocation("Stemcells", []interface{}{})
	fake.stemcellsMutex.Unlock()
	if fake.StemcellsStub != nil {
		return fake.StemcellsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.stemcellsReturns.result1, fake.stemcellsReturns.result2
}

func (fake *FakeDirector) StemcellsCallCount() int {
	fake.stemcellsMutex.RLock()
	defer fake.stemcellsMutex.RUnlock()
	return len(fake.stemcellsArgsForCall)
}

func (fake *FakeDirector) StemcellsReturns(result1 []director.Stemcell, result2 error) {
	fake.StemcellsStub = nil
	fake.stemcellsReturns = struct {
		result1 []director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) StemcellsReturnsOnCall(i int, result1 []director.Stemcell, result2 error) {
	fake.StemcellsStub = nil
	if fake.stemcellsReturnsOnCall == nil {
		fake.stemcellsReturnsOnCall = make(map[int]struct {
			result1 []director.Stemcell
			result2 error
		})
	}
	fake.stemcellsReturnsOnCall[i] = struct {
		result1 []director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) HasStemcell(name string, version string) (bool, error) {
	fake.hasStemcellMutex.Lock()
	ret, specificReturn := fake.hasStemcellReturnsOnCall[len(fake.hasStemcellArgsForCall)]
	fake.hasStemcellArgsForCall = append(fake.hasStemcellArgsForCall, struct {
		name    string
		version string
	}{name, version})
	fake.recordInvocation("HasStemcell", []interface{}{name, version})
	fake.hasStemcellMutex.Unlock()
	if fake.HasStemcellStub != nil {
		return fake.HasStemcellStub(name, version)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.hasStemcellReturns.result1, fake.hasStemcellReturns.result2
}

func (fake *FakeDirector) HasStemcellCallCount() int {
	fake.hasStemcellMutex.RLock()
	defer fake.hasStemcellMutex.RUnlock()
	return len(fake.hasStemcellArgsForCall)
}

func (fake *FakeDirector) HasStemcellArgsForCall(i int) (string, string) {
	fake.hasStemcellMutex.RLock()
	defer fake.hasStemcellMutex.RUnlock()
	return fake.hasStemcellArgsForCall[i].name, fake.hasStemcellArgsForCall[i].version
}

func (fake *FakeDirector) HasStemcellReturns(result1 bool, result2 error) {
	fake.HasStemcellStub = nil
	fake.hasStemcellReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) HasStemcellReturnsOnCall(i int, result1 bool, result2 error) {
	fake.HasStemcellStub = nil
	if fake.hasStemcellReturnsOnCall == nil {
		fake.hasStemcellReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasStemcellReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) StemcellNeedsUpload(arg1 director.StemcellInfo) (bool, bool, error) {
	fake.stemcellNeedsUploadMutex.Lock()
	ret, specificReturn := fake.stemcellNeedsUploadReturnsOnCall[len(fake.stemcellNeedsUploadArgsForCall)]
	fake.stemcellNeedsUploadArgsForCall = append(fake.stemcellNeedsUploadArgsForCall, struct {
		arg1 director.StemcellInfo
	}{arg1})
	fake.recordInvocation("StemcellNeedsUpload", []interface{}{arg1})
	fake.stemcellNeedsUploadMutex.Unlock()
	if fake.StemcellNeedsUploadStub != nil {
		return fake.StemcellNeedsUploadStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.stemcellNeedsUploadReturns.result1, fake.stemcellNeedsUploadReturns.result2, fake.stemcellNeedsUploadReturns.result3
}

func (fake *FakeDirector) StemcellNeedsUploadCallCount() int {
	fake.stemcellNeedsUploadMutex.RLock()
	defer fake.stemcellNeedsUploadMutex.RUnlock()
	return len(fake.stemcellNeedsUploadArgsForCall)
}

func (fake *FakeDirector) StemcellNeedsUploadArgsForCall(i int) director.StemcellInfo {
	fake.stemcellNeedsUploadMutex.RLock()
	defer fake.stemcellNeedsUploadMutex.RUnlock()
	return fake.stemcellNeedsUploadArgsForCall[i].arg1
}

func (fake *FakeDirector) StemcellNeedsUploadReturns(result1 bool, result2 bool, result3 error) {
	fake.StemcellNeedsUploadStub = nil
	fake.stemcellNeedsUploadReturns = struct {
		result1 bool
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDirector) StemcellNeedsUploadReturnsOnCall(i int, result1 bool, result2 bool, result3 error) {
	fake.StemcellNeedsUploadStub = nil
	if fake.stemcellNeedsUploadReturnsOnCall == nil {
		fake.stemcellNeedsUploadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 bool
			result3 error
		})
	}
	fake.stemcellNeedsUploadReturnsOnCall[i] = struct {
		result1 bool
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDirector) FindStemcell(arg1 director.StemcellSlug) (director.Stemcell, error) {
	fake.findStemcellMutex.Lock()
	ret, specificReturn := fake.findStemcellReturnsOnCall[len(fake.findStemcellArgsForCall)]
	fake.findStemcellArgsForCall = append(fake.findStemcellArgsForCall, struct {
		arg1 director.StemcellSlug
	}{arg1})
	fake.recordInvocation("FindStemcell", []interface{}{arg1})
	fake.findStemcellMutex.Unlock()
	if fake.FindStemcellStub != nil {
		return fake.FindStemcellStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findStemcellReturns.result1, fake.findStemcellReturns.result2
}

func (fake *FakeDirector) FindStemcellCallCount() int {
	fake.findStemcellMutex.RLock()
	defer fake.findStemcellMutex.RUnlock()
	return len(fake.findStemcellArgsForCall)
}

func (fake *FakeDirector) FindStemcellArgsForCall(i int) director.StemcellSlug {
	fake.findStemcellMutex.RLock()
	defer fake.findStemcellMutex.RUnlock()
	return fake.findStemcellArgsForCall[i].arg1
}

func (fake *FakeDirector) FindStemcellReturns(result1 director.Stemcell, result2 error) {
	fake.FindStemcellStub = nil
	fake.findStemcellReturns = struct {
		result1 director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindStemcellReturnsOnCall(i int, result1 director.Stemcell, result2 error) {
	fake.FindStemcellStub = nil
	if fake.findStemcellReturnsOnCall == nil {
		fake.findStemcellReturnsOnCall = make(map[int]struct {
			result1 director.Stemcell
			result2 error
		})
	}
	fake.findStemcellReturnsOnCall[i] = struct {
		result1 director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UploadStemcellURL(url string, sha1 string, fix bool) error {
	fake.uploadStemcellURLMutex.Lock()
	ret, specificReturn := fake.uploadStemcellURLReturnsOnCall[len(fake.uploadStemcellURLArgsForCall)]
	fake.uploadStemcellURLArgsForCall = append(fake.uploadStemcellURLArgsForCall, struct {
		url  string
		sha1 string
		fix  bool
	}{url, sha1, fix})
	fake.recordInvocation("UploadStemcellURL", []interface{}{url, sha1, fix})
	fake.uploadStemcellURLMutex.Unlock()
	if fake.UploadStemcellURLStub != nil {
		return fake.UploadStemcellURLStub(url, sha1, fix)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.uploadStemcellURLReturns.result1
}

func (fake *FakeDirector) UploadStemcellURLCallCount() int {
	fake.uploadStemcellURLMutex.RLock()
	defer fake.uploadStemcellURLMutex.RUnlock()
	return len(fake.uploadStemcellURLArgsForCall)
}

func (fake *FakeDirector) UploadStemcellURLArgsForCall(i int) (string, string, bool) {
	fake.uploadStemcellURLMutex.RLock()
	defer fake.uploadStemcellURLMutex.RUnlock()
	return fake.uploadStemcellURLArgsForCall[i].url, fake.uploadStemcellURLArgsForCall[i].sha1, fake.uploadStemcellURLArgsForCall[i].fix
}

func (fake *FakeDirector) UploadStemcellURLReturns(result1 error) {
	fake.UploadStemcellURLStub = nil
	fake.uploadStemcellURLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadStemcellURLReturnsOnCall(i int, result1 error) {
	fake.UploadStemcellURLStub = nil
	if fake.uploadStemcellURLReturnsOnCall == nil {
		fake.uploadStemcellURLReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadStemcellURLReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadStemcellFile(file director.UploadFile, fix bool) error {
	fake.uploadStemcellFileMutex.Lock()
	ret, specificReturn := fake.uploadStemcellFileReturnsOnCall[len(fake.uploadStemcellFileArgsForCall)]
	fake.uploadStemcellFileArgsForCall = append(fake.uploadStemcellFileArgsForCall, struct {
		file director.UploadFile
		fix  bool
	}{file, fix})
	fake.recordInvocation("UploadStemcellFile", []interface{}{file, fix})
	fake.uploadStemcellFileMutex.Unlock()
	if fake.UploadStemcellFileStub != nil {
		return fake.UploadStemcellFileStub(file, fix)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.uploadStemcellFileReturns.result1
}

func (fake *FakeDirector) UploadStemcellFileCallCount() int {
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	return len(fake.uploadStemcellFileArgsForCall)
}

func (fake *FakeDirector) UploadStemcellFileArgsForCall(i int) (director.UploadFile, bool) {
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	return fake.uploadStemcellFileArgsForCall[i].file, fake.uploadStemcellFileArgsForCall[i].fix
}

func (fake *FakeDirector) UploadStemcellFileReturns(result1 error) {
	fake.UploadStemcellFileStub = nil
	fake.uploadStemcellFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadStemcellFileReturnsOnCall(i int, result1 error) {
	fake.UploadStemcellFileStub = nil
	if fake.uploadStemcellFileReturnsOnCall == nil {
		fake.uploadStemcellFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadStemcellFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) LatestConfig(configType string, name string) (director.Config, error) {
	fake.latestConfigMutex.Lock()
	ret, specificReturn := fake.latestConfigReturnsOnCall[len(fake.latestConfigArgsForCall)]
	fake.latestConfigArgsForCall = append(fake.latestConfigArgsForCall, struct {
		configType string
		name       string
	}{configType, name})
	fake.recordInvocation("LatestConfig", []interface{}{configType, name})
	fake.latestConfigMutex.Unlock()
	if fake.LatestConfigStub != nil {
		return fake.LatestConfigStub(configType, name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.latestConfigReturns.result1, fake.latestConfigReturns.result2
}

func (fake *FakeDirector) LatestConfigCallCount() int {
	fake.latestConfigMutex.RLock()
	defer fake.latestConfigMutex.RUnlock()
	return len(fake.latestConfigArgsForCall)
}

func (fake *FakeDirector) LatestConfigArgsForCall(i int) (string, string) {
	fake.latestConfigMutex.RLock()
	defer fake.latestConfigMutex.RUnlock()
	return fake.latestConfigArgsForCall[i].configType, fake.latestConfigArgsForCall[i].name
}

func (fake *FakeDirector) LatestConfigReturns(result1 director.Config, result2 error) {
	fake.LatestConfigStub = nil
	fake.latestConfigReturns = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestConfigReturnsOnCall(i int, result1 director.Config, result2 error) {
	fake.LatestConfigStub = nil
	if fake.latestConfigReturnsOnCall == nil {
		fake.latestConfigReturnsOnCall = make(map[int]struct {
			result1 director.Config
			result2 error
		})
	}
	fake.latestConfigReturnsOnCall[i] = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestConfigByID(configID string) (director.Config, error) {
	fake.latestConfigByIDMutex.Lock()
	ret, specificReturn := fake.latestConfigByIDReturnsOnCall[len(fake.latestConfigByIDArgsForCall)]
	fake.latestConfigByIDArgsForCall = append(fake.latestConfigByIDArgsForCall, struct {
		configID string
	}{configID})
	fake.recordInvocation("LatestConfigByID", []interface{}{configID})
	fake.latestConfigByIDMutex.Unlock()
	if fake.LatestConfigByIDStub != nil {
		return fake.LatestConfigByIDStub(configID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.latestConfigByIDReturns.result1, fake.latestConfigByIDReturns.result2
}

func (fake *FakeDirector) LatestConfigByIDCallCount() int {
	fake.latestConfigByIDMutex.RLock()
	defer fake.latestConfigByIDMutex.RUnlock()
	return len(fake.latestConfigByIDArgsForCall)
}

func (fake *FakeDirector) LatestConfigByIDArgsForCall(i int) string {
	fake.latestConfigByIDMutex.RLock()
	defer fake.latestConfigByIDMutex.RUnlock()
	return fake.latestConfigByIDArgsForCall[i].configID
}

func (fake *FakeDirector) LatestConfigByIDReturns(result1 director.Config, result2 error) {
	fake.LatestConfigByIDStub = nil
	fake.latestConfigByIDReturns = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestConfigByIDReturnsOnCall(i int, result1 director.Config, result2 error) {
	fake.LatestConfigByIDStub = nil
	if fake.latestConfigByIDReturnsOnCall == nil {
		fake.latestConfigByIDReturnsOnCall = make(map[int]struct {
			result1 director.Config
			result2 error
		})
	}
	fake.latestConfigByIDReturnsOnCall[i] = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ListConfigs(limit int, filter director.ConfigsFilter) ([]director.Config, error) {
	fake.listConfigsMutex.Lock()
	ret, specificReturn := fake.listConfigsReturnsOnCall[len(fake.listConfigsArgsForCall)]
	fake.listConfigsArgsForCall = append(fake.listConfigsArgsForCall, struct {
		limit  int
		filter director.ConfigsFilter
	}{limit, filter})
	fake.recordInvocation("ListConfigs", []interface{}{limit, filter})
	fake.listConfigsMutex.Unlock()
	if fake.ListConfigsStub != nil {
		return fake.ListConfigsStub(limit, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listConfigsReturns.result1, fake.listConfigsReturns.result2
}

func (fake *FakeDirector) ListConfigsCallCount() int {
	fake.listConfigsMutex.RLock()
	defer fake.listConfigsMutex.RUnlock()
	return len(fake.listConfigsArgsForCall)
}

func (fake *FakeDirector) ListConfigsArgsForCall(i int) (int, director.ConfigsFilter) {
	fake.listConfigsMutex.RLock()
	defer fake.listConfigsMutex.RUnlock()
	return fake.listConfigsArgsForCall[i].limit, fake.listConfigsArgsForCall[i].filter
}

func (fake *FakeDirector) ListConfigsReturns(result1 []director.Config, result2 error) {
	fake.ListConfigsStub = nil
	fake.listConfigsReturns = struct {
		result1 []director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ListConfigsReturnsOnCall(i int, result1 []director.Config, result2 error) {
	fake.ListConfigsStub = nil
	if fake.listConfigsReturnsOnCall == nil {
		fake.listConfigsReturnsOnCall = make(map[int]struct {
			result1 []director.Config
			result2 error
		})
	}
	fake.listConfigsReturnsOnCall[i] = struct {
		result1 []director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UpdateConfig(configType string, name string, content []byte) (director.Config, error) {
	var contentCopy []byte
	if content != nil {
		contentCopy = make([]byte, len(content))
		copy(contentCopy, content)
	}
	fake.updateConfigMutex.Lock()
	ret, specificReturn := fake.updateConfigReturnsOnCall[len(fake.updateConfigArgsForCall)]
	fake.updateConfigArgsForCall = append(fake.updateConfigArgsForCall, struct {
		configType string
		name       string
		content    []byte
	}{configType, name, contentCopy})
	fake.recordInvocation("UpdateConfig", []interface{}{configType, name, contentCopy})
	fake.updateConfigMutex.Unlock()
	if fake.UpdateConfigStub != nil {
		return fake.UpdateConfigStub(configType, name, content)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateConfigReturns.result1, fake.updateConfigReturns.result2
}

func (fake *FakeDirector) UpdateConfigCallCount() int {
	fake.updateConfigMutex.RLock()
	defer fake.updateConfigMutex.RUnlock()
	return len(fake.updateConfigArgsForCall)
}

func (fake *FakeDirector) UpdateConfigArgsForCall(i int) (string, string, []byte) {
	fake.updateConfigMutex.RLock()
	defer fake.updateConfigMutex.RUnlock()
	return fake.updateConfigArgsForCall[i].configType, fake.updateConfigArgsForCall[i].name, fake.updateConfigArgsForCall[i].content
}

func (fake *FakeDirector) UpdateConfigReturns(result1 director.Config, result2 error) {
	fake.UpdateConfigStub = nil
	fake.updateConfigReturns = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UpdateConfigReturnsOnCall(i int, result1 director.Config, result2 error) {
	fake.UpdateConfigStub = nil
	if fake.updateConfigReturnsOnCall == nil {
		fake.updateConfigReturnsOnCall = make(map[int]struct {
			result1 director.Config
			result2 error
		})
	}
	fake.updateConfigReturnsOnCall[i] = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeleteConfig(configType string, name string) (bool, error) {
	fake.deleteConfigMutex.Lock()
	ret, specificReturn := fake.deleteConfigReturnsOnCall[len(fake.deleteConfigArgsForCall)]
	fake.deleteConfigArgsForCall = append(fake.deleteConfigArgsForCall, struct {
		configType string
		name       string
	}{configType, name})
	fake.recordInvocation("DeleteConfig", []interface{}{configType, name})
	fake.deleteConfigMutex.Unlock()
	if fake.DeleteConfigStub != nil {
		return fake.DeleteConfigStub(configType, name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deleteConfigReturns.result1, fake.deleteConfigReturns.result2
}

func (fake *FakeDirector) DeleteConfigCallCount() int {
	fake.deleteConfigMutex.RLock()
	defer fake.deleteConfigMutex.RUnlock()
	return len(fake.deleteConfigArgsForCall)
}

func (fake *FakeDirector) DeleteConfigArgsForCall(i int) (string, string) {
	fake.deleteConfigMutex.RLock()
	defer fake.deleteConfigMutex.RUnlock()
	return fake.deleteConfigArgsForCall[i].configType, fake.deleteConfigArgsForCall[i].name
}

func (fake *FakeDirector) DeleteConfigReturns(result1 bool, result2 error) {
	fake.DeleteConfigStub = nil
	fake.deleteConfigReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeleteConfigReturnsOnCall(i int, result1 bool, result2 error) {
	fake.DeleteConfigStub = nil
	if fake.deleteConfigReturnsOnCall == nil {
		fake.deleteConfigReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteConfigReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeleteConfigByID(configID string) (bool, error) {
	fake.deleteConfigByIDMutex.Lock()
	ret, specificReturn := fake.deleteConfigByIDReturnsOnCall[len(fake.deleteConfigByIDArgsForCall)]
	fake.deleteConfigByIDArgsForCall = append(fake.deleteConfigByIDArgsForCall, struct {
		configID string
	}{configID})
	fake.recordInvocation("DeleteConfigByID", []interface{}{configID})
	fake.deleteConfigByIDMutex.Unlock()
	if fake.DeleteConfigByIDStub != nil {
		return fake.DeleteConfigByIDStub(configID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deleteConfigByIDReturns.result1, fake.deleteConfigByIDReturns.result2
}

func (fake *FakeDirector) DeleteConfigByIDCallCount() int {
	fake.deleteConfigByIDMutex.RLock()
	defer fake.deleteConfigByIDMutex.RUnlock()
	return len(fake.deleteConfigByIDArgsForCall)
}

func (fake *FakeDirector) DeleteConfigByIDArgsForCall(i int) string {
	fake.deleteConfigByIDMutex.RLock()
	defer fake.deleteConfigByIDMutex.RUnlock()
	return fake.deleteConfigByIDArgsForCall[i].configID
}

func (fake *FakeDirector) DeleteConfigByIDReturns(result1 bool, result2 error) {
	fake.DeleteConfigByIDStub = nil
	fake.deleteConfigByIDReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeleteConfigByIDReturnsOnCall(i int, result1 bool, result2 error) {
	fake.DeleteConfigByIDStub = nil
	if fake.deleteConfigByIDReturnsOnCall == nil {
		fake.deleteConfigByIDReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteConfigByIDReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffConfig(configType string, name string, manifest []byte) (director.ConfigDiff, error) {
	var manifestCopy []byte
	if manifest != nil {
		manifestCopy = make([]byte, len(manifest))
		copy(manifestCopy, manifest)
	}
	fake.diffConfigMutex.Lock()
	ret, specificReturn := fake.diffConfigReturnsOnCall[len(fake.diffConfigArgsForCall)]
	fake.diffConfigArgsForCall = append(fake.diffConfigArgsForCall, struct {
		configType string
		name       string
		manifest   []byte
	}{configType, name, manifestCopy})
	fake.recordInvocation("DiffConfig", []interface{}{configType, name, manifestCopy})
	fake.diffConfigMutex.Unlock()
	if fake.DiffConfigStub != nil {
		return fake.DiffConfigStub(configType, name, manifest)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.diffConfigReturns.result1, fake.diffConfigReturns.result2
}

func (fake *FakeDirector) DiffConfigCallCount() int {
	fake.diffConfigMutex.RLock()
	defer fake.diffConfigMutex.RUnlock()
	return len(fake.diffConfigArgsForCall)
}

func (fake *FakeDirector) DiffConfigArgsForCall(i int) (string, string, []byte) {
	fake.diffConfigMutex.RLock()
	defer fake.diffConfigMutex.RUnlock()
	return fake.diffConfigArgsForCall[i].configType, fake.diffConfigArgsForCall[i].name, fake.diffConfigArgsForCall[i].manifest
}

func (fake *FakeDirector) DiffConfigReturns(result1 director.ConfigDiff, result2 error) {
	fake.DiffConfigStub = nil
	fake.diffConfigReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffConfigReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.DiffConfigStub = nil
	if fake.diffConfigReturnsOnCall == nil {
		fake.diffConfigReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffConfigReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffConfigByID(fromID string, toID string) (director.ConfigDiff, error) {
	fake.diffConfigByIDMutex.Lock()
	ret, specificReturn := fake.diffConfigByIDReturnsOnCall[len(fake.diffConfigByIDArgsForCall)]
	fake.diffConfigByIDArgsForCall = append(fake.diffConfigByIDArgsForCall, struct {
		fromID string
		toID   string
	}{fromID, toID})
	fake.recordInvocation("DiffConfigByID", []interface{}{fromID, toID})
	fake.diffConfigByIDMutex.Unlock()
	if fake.DiffConfigByIDStub != nil {
		return fake.DiffConfigByIDStub(fromID, toID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.diffConfigByIDReturns.result1, fake.diffConfigByIDReturns.result2
}

func (fake *FakeDirector) DiffConfigByIDCallCount() int {
	fake.diffConfigByIDMutex.RLock()
	defer fake.diffConfigByIDMutex.RUnlock()
	return len(fake.diffConfigByIDArgsForCall)
}

func (fake *FakeDirector) DiffConfigByIDArgsForCall(i int) (string, string) {
	fake.diffConfigByIDMutex.RLock()
	defer fake.diffConfigByIDMutex.RUnlock()
	return fake.diffConfigByIDArgsForCall[i].fromID, fake.diffConfigByIDArgsForCall[i].toID
}

func (fake *FakeDirector) DiffConfigByIDReturns(result1 director.ConfigDiff, result2 error) {
	fake.DiffConfigByIDStub = nil
	fake.diffConfigByIDReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffConfigByIDReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.DiffConfigByIDStub = nil
	if fake.diffConfigByIDReturnsOnCall == nil {
		fake.diffConfigByIDReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffConfigByIDReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestCloudConfig() (director.CloudConfig, error) {
	fake.latestCloudConfigMutex.Lock()
	ret, specificReturn := fake.latestCloudConfigReturnsOnCall[len(fake.latestCloudConfigArgsForCall)]
	fake.latestCloudConfigArgsForCall = append(fake.latestCloudConfigArgsForCall, struct{}{})
	fake.recordInvocation("LatestCloudConfig", []interface{}{})
	fake.latestCloudConfigMutex.Unlock()
	if fake.LatestCloudConfigStub != nil {
		return fake.LatestCloudConfigStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.latestCloudConfigReturns.result1, fake.latestCloudConfigReturns.result2
}

func (fake *FakeDirector) LatestCloudConfigCallCount() int {
	fake.latestCloudConfigMutex.RLock()
	defer fake.latestCloudConfigMutex.RUnlock()
	return len(fake.latestCloudConfigArgsForCall)
}

func (fake *FakeDirector) LatestCloudConfigReturns(result1 director.CloudConfig, result2 error) {
	fake.LatestCloudConfigStub = nil
	fake.latestCloudConfigReturns = struct {
		result1 director.CloudConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestCloudConfigReturnsOnCall(i int, result1 director.CloudConfig, result2 error) {
	fake.LatestCloudConfigStub = nil
	if fake.latestCloudConfigReturnsOnCall == nil {
		fake.latestCloudConfigReturnsOnCall = make(map[int]struct {
			result1 director.CloudConfig
			result2 error
		})
	}
	fake.latestCloudConfigReturnsOnCall[i] = struct {
		result1 director.CloudConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UpdateCloudConfig(arg1 []byte) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.updateCloudConfigMutex.Lock()
	ret, specificReturn := fake.updateCloudConfigReturnsOnCall[len(fake.updateCloudConfigArgsForCall)]
	fake.updateCloudConfigArgsForCall = append(fake.updateCloudConfigArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	fake.recordInvocation("UpdateCloudConfig", []interface{}{arg1Copy})
	fake.updateCloudConfigMutex.Unlock()
	if fake.UpdateCloudConfigStub != nil {
		return fake.UpdateCloudConfigStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateCloudConfigReturns.result1
}

func (fake *FakeDirector) UpdateCloudConfigCallCount() int {
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	return len(fake.updateCloudConfigArgsForCall)
}

func (fake *FakeDirector) UpdateCloudConfigArgsForCall(i int) []byte {
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	return fake.updateCloudConfigArgsForCall[i].arg1
}

func (fake *FakeDirector) UpdateCloudConfigReturns(result1 error) {
	fake.UpdateCloudConfigStub = nil
	fake.updateCloudConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UpdateCloudConfigReturnsOnCall(i int, result1 error) {
	fake.UpdateCloudConfigStub = nil
	if fake.updateCloudConfigReturnsOnCall == nil {
		fake.updateCloudConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateCloudConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) DiffCloudConfig(manifest []byte) (director.ConfigDiff, error) {
	var manifestCopy []byte
	if manifest != nil {
		manifestCopy = make([]byte, len(manifest))
		copy(manifestCopy, manifest)
	}
	fake.diffCloudConfigMutex.Lock()
	ret, specificReturn := fake.diffCloudConfigReturnsOnCall[len(fake.diffCloudConfigArgsForCall)]
	fake.diffCloudConfigArgsForCall = append(fake.diffCloudConfigArgsForCall, struct {
		manifest []byte
	}{manifestCopy})
	fake.recordInvocation("DiffCloudConfig", []interface{}{manifestCopy})
	fake.diffCloudConfigMutex.Unlock()
	if fake.DiffCloudConfigStub != nil {
		return fake.DiffCloudConfigStub(manifest)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.diffCloudConfigReturns.result1, fake.diffCloudConfigReturns.result2
}

func (fake *FakeDirector) DiffCloudConfigCallCount() int {
	fake.diffCloudConfigMutex.RLock()
	defer fake.diffCloudConfigMutex.RUnlock()
	return len(fake.diffCloudConfigArgsForCall)
}

func (fake *FakeDirector) DiffCloudConfigArgsForCall(i int) []byte {
	fake.diffCloudConfigMutex.RLock()
	defer fake.diffCloudConfigMutex.RUnlock()
	return fake.diffCloudConfigArgsForCall[i].manifest
}

func (fake *FakeDirector) DiffCloudConfigReturns(result1 director.ConfigDiff, result2 error) {
	fake.DiffCloudConfigStub = nil
	fake.diffCloudConfigReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffCloudConfigReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.DiffCloudConfigStub = nil
	if fake.diffCloudConfigReturnsOnCall == nil {
		fake.diffCloudConfigReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffCloudConfigReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestCPIConfig() (director.CPIConfig, error) {
	fake.latestCPIConfigMutex.Lock()
	ret, specificReturn := fake.latestCPIConfigReturnsOnCall[len(fake.latestCPIConfigArgsForCall)]
	fake.latestCPIConfigArgsForCall = append(fake.latestCPIConfigArgsForCall, struct{}{})
	fake.recordInvocation("LatestCPIConfig", []interface{}{})
	fake.latestCPIConfigMutex.Unlock()
	if fake.LatestCPIConfigStub != nil {
		return fake.LatestCPIConfigStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.latestCPIConfigReturns.result1, fake.latestCPIConfigReturns.result2
}

func (fake *FakeDirector) LatestCPIConfigCallCount() int {
	fake.latestCPIConfigMutex.RLock()
	defer fake.latestCPIConfigMutex.RUnlock()
	return len(fake.latestCPIConfigArgsForCall)
}

func (fake *FakeDirector) LatestCPIConfigReturns(result1 director.CPIConfig, result2 error) {
	fake.LatestCPIConfigStub = nil
	fake.latestCPIConfigReturns = struct {
		result1 director.CPIConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestCPIConfigReturnsOnCall(i int, result1 director.CPIConfig, result2 error) {
	fake.LatestCPIConfigStub = nil
	if fake.latestCPIConfigReturnsOnCall == nil {
		fake.latestCPIConfigReturnsOnCall = make(map[int]struct {
			result1 director.CPIConfig
			result2 error
		})
	}
	fake.latestCPIConfigReturnsOnCall[i] = struct {
		result1 director.CPIConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UpdateCPIConfig(arg1 []byte) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.updateCPIConfigMutex.Lock()
	ret, specificReturn := fake.updateCPIConfigReturnsOnCall[len(fake.updateCPIConfigArgsForCall)]
	fake.updateCPIConfigArgsForCall = append(fake.updateCPIConfigArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	fake.recordInvocation("UpdateCPIConfig", []interface{}{arg1Copy})
	fake.updateCPIConfigMutex.Unlock()
	if fake.UpdateCPIConfigStub != nil {
		return fake.UpdateCPIConfigStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateCPIConfigReturns.result1
}

func (fake *FakeDirector) UpdateCPIConfigCallCount() int {
	fake.updateCPIConfigMutex.RLock()
	defer fake.updateCPIConfigMutex.RUnlock()
	return len(fake.updateCPIConfigArgsForCall)
}

func (fake *FakeDirector) UpdateCPIConfigArgsForCall(i int) []byte {
	fake.updateCPIConfigMutex.RLock()
	defer fake.updateCPIConfigMutex.RUnlock()
	return fake.updateCPIConfigArgsForCall[i].arg1
}

func (fake *FakeDirector) UpdateCPIConfigReturns(result1 error) {
	fake.UpdateCPIConfigStub = nil
	fake.updateCPIConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UpdateCPIConfigReturnsOnCall(i int, result1 error) {
	fake.UpdateCPIConfigStub = nil
	if fake.updateCPIConfigReturnsOnCall == nil {
		fake.updateCPIConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateCPIConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) DiffCPIConfig(manifest []byte, noRedact bool) (director.ConfigDiff, error) {
	var manifestCopy []byte
	if manifest != nil {
		manifestCopy = make([]byte, len(manifest))
		copy(manifestCopy, manifest)
	}
	fake.diffCPIConfigMutex.Lock()
	ret, specificReturn := fake.diffCPIConfigReturnsOnCall[len(fake.diffCPIConfigArgsForCall)]
	fake.diffCPIConfigArgsForCall = append(fake.diffCPIConfigArgsForCall, struct {
		manifest []byte
		noRedact bool
	}{manifestCopy, noRedact})
	fake.recordInvocation("DiffCPIConfig", []interface{}{manifestCopy, noRedact})
	fake.diffCPIConfigMutex.Unlock()
	if fake.DiffCPIConfigStub != nil {
		return fake.DiffCPIConfigStub(manifest, noRedact)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.diffCPIConfigReturns.result1, fake.diffCPIConfigReturns.result2
}

func (fake *FakeDirector) DiffCPIConfigCallCount() int {
	fake.diffCPIConfigMutex.RLock()
	defer fake.diffCPIConfigMutex.RUnlock()
	return len(fake.diffCPIConfigArgsForCall)
}

func (fake *FakeDirector) DiffCPIConfigArgsForCall(i int) ([]byte, bool) {
	fake.diffCPIConfigMutex.RLock()
	defer fake.diffCPIConfigMutex.RUnlock()
	return fake.diffCPIConfigArgsForCall[i].manifest, fake.diffCPIConfigArgsForCall[i].noRedact
}

func (fake *FakeDirector) DiffCPIConfigReturns(result1 director.ConfigDiff, result2 error) {
	fake.DiffCPIConfigStub = nil
	fake.diffCPIConfigReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffCPIConfigReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.DiffCPIConfigStub = nil
	if fake.diffCPIConfigReturnsOnCall == nil {
		fake.diffCPIConfigReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffCPIConfigReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestRuntimeConfig(name string) (director.RuntimeConfig, error) {
	fake.latestRuntimeConfigMutex.Lock()
	ret, specificReturn := fake.latestRuntimeConfigReturnsOnCall[len(fake.latestRuntimeConfigArgsForCall)]
	fake.latestRuntimeConfigArgsForCall = append(fake.latestRuntimeConfigArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("LatestRuntimeConfig", []interface{}{name})
	fake.latestRuntimeConfigMutex.Unlock()
	if fake.LatestRuntimeConfigStub != nil {
		return fake.LatestRuntimeConfigStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.latestRuntimeConfigReturns.result1, fake.latestRuntimeConfigReturns.result2
}

func (fake *FakeDirector) LatestRuntimeConfigCallCount() int {
	fake.latestRuntimeConfigMutex.RLock()
	defer fake.latestRuntimeConfigMutex.RUnlock()
	return len(fake.latestRuntimeConfigArgsForCall)
}

func (fake *FakeDirector) LatestRuntimeConfigArgsForCall(i int) string {
	fake.latestRuntimeConfigMutex.RLock()
	defer fake.latestRuntimeConfigMutex.RUnlock()
	return fake.latestRuntimeConfigArgsForCall[i].name
}

func (fake *FakeDirector) LatestRuntimeConfigReturns(result1 director.RuntimeConfig, result2 error) {
	fake.LatestRuntimeConfigStub = nil
	fake.latestRuntimeConfigReturns = struct {
		result1 director.RuntimeConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestRuntimeConfigReturnsOnCall(i int, result1 director.RuntimeConfig, result2 error) {
	fake.LatestRuntimeConfigStub = nil
	if fake.latestRuntimeConfigReturnsOnCall == nil {
		fake.latestRuntimeConfigReturnsOnCall = make(map[int]struct {
			result1 director.RuntimeConfig
			result2 error
		})
	}
	fake.latestRuntimeConfigReturnsOnCall[i] = struct {
		result1 director.RuntimeConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UpdateRuntimeConfig(name string, manifest []byte) error {
	var manifestCopy []byte
	if manifest != nil {
		manifestCopy = make([]byte, len(manifest))
		copy(manifestCopy, manifest)
	}
	fake.updateRuntimeConfigMutex.Lock()
	ret, specificReturn := fake.updateRuntimeConfigReturnsOnCall[len(fake.updateRuntimeConfigArgsForCall)]
	fake.updateRuntimeConfigArgsForCall = append(fake.updateRuntimeConfigArgsForCall, struct {
		name     string
		manifest []byte
	}{name, manifestCopy})
	fake.recordInvocation("UpdateRuntimeConfig", []interface{}{name, manifestCopy})
	fake.updateRuntimeConfigMutex.Unlock()
	if fake.UpdateRuntimeConfigStub != nil {
		return fake.UpdateRuntimeConfigStub(name, manifest)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateRuntimeConfigReturns.result1
}

func (fake *FakeDirector) UpdateRuntimeConfigCallCount() int {
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	return len(fake.updateRuntimeConfigArgsForCall)
}

func (fake *FakeDirector) UpdateRuntimeConfigArgsForCall(i int) (string, []byte) {
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	return fake.updateRuntimeConfigArgsForCall[i].name, fake.updateRuntimeConfigArgsForCall[i].manifest
}

func (fake *FakeDirector) UpdateRuntimeConfigReturns(result1 error) {
	fake.UpdateRuntimeConfigStub = nil
	fake.updateRuntimeConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UpdateRuntimeConfigReturnsOnCall(i int, result1 error) {
	fake.UpdateRuntimeConfigStub = nil
	if fake.updateRuntimeConfigReturnsOnCall == nil {
		fake.updateRuntimeConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateRuntimeConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) DiffRuntimeConfig(name string, manifest []byte, noRedact bool) (director.ConfigDiff, error) {
	var manifestCopy []byte
	if manifest != nil {
		manifestCopy = make([]byte, len(manifest))
		copy(manifestCopy, manifest)
	}
	fake.diffRuntimeConfigMutex.Lock()
	ret, specificReturn := fake.diffRuntimeConfigReturnsOnCall[len(fake.diffRuntimeConfigArgsForCall)]
	fake.diffRuntimeConfigArgsForCall = append(fake.diffRuntimeConfigArgsForCall, struct {
		name     string
		manifest []byte
		noRedact bool
	}{name, manifestCopy, noRedact})
	fake.recordInvocation("DiffRuntimeConfig", []interface{}{name, manifestCopy, noRedact})
	fake.diffRuntimeConfigMutex.Unlock()
	if fake.DiffRuntimeConfigStub != nil {
		return fake.DiffRuntimeConfigStub(name, manifest, noRedact)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.diffRuntimeConfigReturns.result1, fake.diffRuntimeConfigReturns.result2
}

func (fake *FakeDirector) DiffRuntimeConfigCallCount() int {
	fake.diffRuntimeConfigMutex.RLock()
	defer fake.diffRuntimeConfigMutex.RUnlock()
	return len(fake.diffRuntimeConfigArgsForCall)
}

func (fake *FakeDirector) DiffRuntimeConfigArgsForCall(i int) (string, []byte, bool) {
	fake.diffRuntimeConfigMutex.RLock()
	defer fake.diffRuntimeConfigMutex.RUnlock()
	return fake.diffRuntimeConfigArgsForCall[i].name, fake.diffRuntimeConfigArgsForCall[i].manifest, fake.diffRuntimeConfigArgsForCall[i].noRedact
}

func (fake *FakeDirector) DiffRuntimeConfigReturns(result1 director.ConfigDiff, result2 error) {
	fake.DiffRuntimeConfigStub = nil
	fake.diffRuntimeConfigReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffRuntimeConfigReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.DiffRuntimeConfigStub = nil
	if fake.diffRuntimeConfigReturnsOnCall == nil {
		fake.diffRuntimeConfigReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffRuntimeConfigReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindOrphanDisk(arg1 string) (director.OrphanDisk, error) {
	fake.findOrphanDiskMutex.Lock()
	ret, specificReturn := fake.findOrphanDiskReturnsOnCall[len(fake.findOrphanDiskArgsForCall)]
	fake.findOrphanDiskArgsForCall = append(fake.findOrphanDiskArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindOrphanDisk", []interface{}{arg1})
	fake.findOrphanDiskMutex.Unlock()
	if fake.FindOrphanDiskStub != nil {
		return fake.FindOrphanDiskStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findOrphanDiskReturns.result1, fake.findOrphanDiskReturns.result2
}

func (fake *FakeDirector) FindOrphanDiskCallCount() int {
	fake.findOrphanDiskMutex.RLock()
	defer fake.findOrphanDiskMutex.RUnlock()
	return len(fake.findOrphanDiskArgsForCall)
}

func (fake *FakeDirector) FindOrphanDiskArgsForCall(i int) string {
	fake.findOrphanDiskMutex.RLock()
	defer fake.findOrphanDiskMutex.RUnlock()
	return fake.findOrphanDiskArgsForCall[i].arg1
}

func (fake *FakeDirector) FindOrphanDiskReturns(result1 director.OrphanDisk, result2 error) {
	fake.FindOrphanDiskStub = nil
	fake.findOrphanDiskReturns = struct {
		result1 director.OrphanDisk
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindOrphanDiskReturnsOnCall(i int, result1 director.OrphanDisk, result2 error) {
	fake.FindOrphanDiskStub = nil
	if fake.findOrphanDiskReturnsOnCall == nil {
		fake.findOrphanDiskReturnsOnCall = make(map[int]struct {
			result1 director.OrphanDisk
			result2 error
		})
	}
	fake.findOrphanDiskReturnsOnCall[i] = struct {
		result1 director.OrphanDisk
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanDisks() ([]director.OrphanDisk, error) {
	fake.orphanDisksMutex.Lock()
	ret, specificReturn := fake.orphanDisksReturnsOnCall[len(fake.orphanDisksArgsForCall)]
	fake.orphanDisksArgsForCall = append(fake.orphanDisksArgsForCall, struct{}{})
	fake.recordInvocation("OrphanDisks", []interface{}{})
	fake.orphanDisksMutex.Unlock()
	if fake.OrphanDisksStub != nil {
		return fake.OrphanDisksStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.orphanDisksReturns.result1, fake.orphanDisksReturns.result2
}

func (fake *FakeDirector) OrphanDisksCallCount() int {
	fake.orphanDisksMutex.RLock()
	defer fake.orphanDisksMutex.RUnlock()
	return len(fake.orphanDisksArgsForCall)
}

func (fake *FakeDirector) OrphanDisksReturns(result1 []director.OrphanDisk, result2 error) {
	fake.OrphanDisksStub = nil
	fake.orphanDisksReturns = struct {
		result1 []director.OrphanDisk
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanDisksReturnsOnCall(i int, result1 []director.OrphanDisk, result2 error) {
	fake.OrphanDisksStub = nil
	if fake.orphanDisksReturnsOnCall == nil {
		fake.orphanDisksReturnsOnCall = make(map[int]struct {
			result1 []director.OrphanDisk
			result2 error
		})
	}
	fake.orphanDisksReturnsOnCall[i] = struct {
		result1 []director.OrphanDisk
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanDisk(arg1 string) error {
	fake.orphanDiskMutex.Lock()
	ret, specificReturn := fake.orphanDiskReturnsOnCall[len(fake.orphanDiskArgsForCall)]
	fake.orphanDiskArgsForCall = append(fake.orphanDiskArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("OrphanDisk", []interface{}{arg1})
	fake.orphanDiskMutex.Unlock()
	if fake.OrphanDiskStub != nil {
		return fake.OrphanDiskStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.orphanDiskReturns.result1
}

func (fake *FakeDirector) OrphanDiskCallCount() int {
	fake.orphanDiskMutex.RLock()
	defer fake.orphanDiskMutex.RUnlock()
	return len(fake.orphanDiskArgsForCall)
}

func (fake *FakeDirector) OrphanDiskArgsForCall(i int) string {
	fake.orphanDiskMutex.RLock()
	defer fake.orphanDiskMutex.RUnlock()
	return fake.orphanDiskArgsForCall[i].arg1
}

func (fake *FakeDirector) OrphanDiskReturns(result1 error) {
	fake.OrphanDiskStub = nil
	fake.orphanDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) OrphanDiskReturnsOnCall(i int, result1 error) {
	fake.OrphanDiskStub = nil
	if fake.orphanDiskReturnsOnCall == nil {
		fake.orphanDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.orphanDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) EnableResurrection(arg1 bool) error {
	fake.enableResurrectionMutex.Lock()
	ret, specificReturn := fake.enableResurrectionReturnsOnCall[len(fake.enableResurrectionArgsForCall)]
	fake.enableResurrectionArgsForCall = append(fake.enableResurrectionArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("EnableResurrection", []interface{}{arg1})
	fake.enableResurrectionMutex.Unlock()
	if fake.EnableResurrectionStub != nil {
		return fake.EnableResurrectionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.enableResurrectionReturns.result1
}

func (fake *FakeDirector) EnableResurrectionCallCount() int {
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	return len(fake.enableResurrectionArgsForCall)
}

func (fake *FakeDirector) EnableResurrectionArgsForCall(i int) bool {
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	return fake.enableResurrectionArgsForCall[i].arg1
}

func (fake *FakeDirector) EnableResurrectionReturns(result1 error) {
	fake.EnableResurrectionStub = nil
	fake.enableResurrectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) EnableResurrectionReturnsOnCall(i int, result1 error) {
	fake.EnableResurrectionStub = nil
	if fake.enableResurrectionReturnsOnCall == nil {
		fake.enableResurrectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableResurrectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) CleanUp(arg1 bool) error {
	fake.cleanUpMutex.Lock()
	ret, specificReturn := fake.cleanUpReturnsOnCall[len(fake.cleanUpArgsForCall)]
	fake.cleanUpArgsForCall = append(fake.cleanUpArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("CleanUp", []interface{}{arg1})
	fake.cleanUpMutex.Unlock()
	if fake.CleanUpStub != nil {
		return fake.CleanUpStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cleanUpReturns.result1
}

func (fake *FakeDirector) CleanUpCallCount() int {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	return len(fake.cleanUpArgsForCall)
}

func (fake *FakeDirector) CleanUpArgsForCall(i int) bool {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	return fake.cleanUpArgsForCall[i].arg1
}

func (fake *FakeDirector) CleanUpReturns(result1 error) {
	fake.CleanUpStub = nil
	fake.cleanUpReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) CleanUpReturnsOnCall(i int, result1 error) {
	fake.CleanUpStub = nil
	if fake.cleanUpReturnsOnCall == nil {
		fake.cleanUpReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanUpReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) DownloadResourceUnchecked(blobstoreID string, out io.Writer) error {
	fake.downloadResourceUncheckedMutex.Lock()
	ret, specificReturn := fake.downloadResourceUncheckedReturnsOnCall[len(fake.downloadResourceUncheckedArgsForCall)]
	fake.downloadResourceUncheckedArgsForCall = append(fake.downloadResourceUncheckedArgsForCall, struct {
		blobstoreID string
		out         io.Writer
	}{blobstoreID, out})
	fake.recordInvocation("DownloadResourceUnchecked", []interface{}{blobstoreID, out})
	fake.downloadResourceUncheckedMutex.Unlock()
	if fake.DownloadResourceUncheckedStub != nil {
		return fake.DownloadResourceUncheckedStub(blobstoreID, out)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.downloadResourceUncheckedReturns.result1
}

func (fake *FakeDirector) DownloadResourceUncheckedCallCount() int {
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	return len(fake.downloadResourceUncheckedArgsForCall)
}

func (fake *FakeDirector) DownloadResourceUncheckedArgsForCall(i int) (string, io.Writer) {
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	return fake.downloadResourceUncheckedArgsForCall[i].blobstoreID, fake.downloadResourceUncheckedArgsForCall[i].out
}

func (fake *FakeDirector) DownloadResourceUncheckedReturns(result1 error) {
	fake.DownloadResourceUncheckedStub = nil
	fake.downloadResourceUncheckedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) DownloadResourceUncheckedReturnsOnCall(i int, result1 error) {
	fake.DownloadResourceUncheckedStub = nil
	if fake.downloadResourceUncheckedReturnsOnCall == nil {
		fake.downloadResourceUncheckedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadResourceUncheckedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.isAuthenticatedMutex.RLock()
	defer fake.isAuthenticatedMutex.RUnlock()
	fake.withContextMutex.RLock()
	defer fake.withContextMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.locksMutex.RLock()
	defer fake.locksMutex.RUnlock()
	fake.currentTasksMutex.RLock()
	defer fake.currentTasksMutex.RUnlock()
	fake.recentTasksMutex.RLock()
	defer fake.recentTasksMutex.RUnlock()
	fake.findTaskMutex.RLock()
	defer fake.findTaskMutex.RUnlock()
	fake.findTasksByContextIdMutex.RLock()
	defer fake.findTasksByContextIdMutex.RUnlock()
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	fake.eventMutex.RLock()
	defer fake.eventMutex.RUnlock()
	fake.deploymentsMutex.RLock()
	defer fake.deploymentsMutex.RUnlock()
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	fake.releasesMutex.RLock()
	defer fake.releasesMutex.RUnlock()
	fake.hasReleaseMutex.RLock()
	defer fake.hasReleaseMutex.RUnlock()
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	fake.findReleaseSeriesMutex.RLock()
	defer fake.findReleaseSeriesMutex.RUnlock()
	fake.uploadReleaseURLMutex.RLock()
	defer fake.uploadReleaseURLMutex.RUnlock()
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	fake.matchPackagesMutex.RLock()
	defer fake.matchPackagesMutex.RUnlock()
	fake.stemcellsMutex.RLock()
	defer fake.stemcellsMutex.RUnlock()
	fake.hasStemcellMutex.RLock()
	defer fake.hasStemcellMutex.RUnlock()
	fake.stemcellNeedsUploadMutex.RLock()
	defer fake.stemcellNeedsUploadMutex.RUnlock()
	fake.findStemcellMutex.RLock()
	defer fake.findStemcellMutex.RUnlock()
	fake.uploadStemcellURLMutex.RLock()
	defer fake.uploadStemcellURLMutex.RUnlock()
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	fake.latestConfigMutex.RLock()
	defer fake.latestConfigMutex.RUnlock()
	fake.latestConfigByIDMutex.RLock()
	defer fake.latestConfigByIDMutex.RUnlock()
	fake.listConfigsMutex.RLock()
	defer fake.listConfigsMutex.RUnlock()
	fake.updateConfigMutex.RLock()
	defer fake.updateConfigMutex.RUnlock()
	fake.deleteConfigMutex.RLock()
	defer fake.deleteConfigMutex.RUnlock()
	fake.deleteConfigByIDMutex.RLock()
	defer fake.deleteConfigByIDMutex.RUnlock()
	fake.diffConfigMutex.RLock()
	defer fake.diffConfigMutex.RUnlock()
	fake.diffConfigByIDMutex.RLock()
	defer fake.diffConfigByIDMutex.RUnlock()
	fake.latestCloudConfigMutex.RLock()
	defer fake.latestCloudConfigMutex.RUnlock()
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	fake.diffCloudConfigMutex.RLock()
	defer fake.diffCloudConfigMutex.RUnlock()
	fake.latestCPIConfigMutex.RLock()
	defer fake.latestCPIConfigMutex.RUnlock()
	fake.updateCPIConfigMutex.RLock()
	defer fake.updateCPIConfigMutex.RUnlock()
	fake.diffCPIConfigMutex.RLock()
	defer fake.diffCPIConfigMutex.RUnlock()
	fake.latestRuntimeConfigMutex.RLock()
	defer fake.latestRuntimeConfigMutex.RUnlock()
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	fake.diffRuntimeConfigMutex.RLock()
	defer fake.diffRuntimeConfigMutex.RUnlock()
	fake.findOrphanDiskMutex.RLock()
	defer fake.findOrphanDiskMutex.RUnlock()
	fake.orphanDisksMutex.RLock()
	defer fake.orphanDisksMutex.RUnlock()
	fake.orphanDiskMutex.RLock()
	defer fake.orphanDiskMutex.RUnlock()
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDirector) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ director.Director = new(FakeDirector)
