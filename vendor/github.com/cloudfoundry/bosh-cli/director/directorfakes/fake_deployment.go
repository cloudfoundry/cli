// Code generated by counterfeiter. DO NOT EDIT.
package directorfakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-cli/director"
)

type FakeDeployment struct {
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct{}
	nameReturns     struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	ManifestStub        func() (string, error)
	manifestMutex       sync.RWMutex
	manifestArgsForCall []struct{}
	manifestReturns     struct {
		result1 string
		result2 error
	}
	manifestReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CloudConfigStub        func() (string, error)
	cloudConfigMutex       sync.RWMutex
	cloudConfigArgsForCall []struct{}
	cloudConfigReturns     struct {
		result1 string
		result2 error
	}
	cloudConfigReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DiffStub        func([]byte, bool) (director.DeploymentDiff, error)
	diffMutex       sync.RWMutex
	diffArgsForCall []struct {
		arg1 []byte
		arg2 bool
	}
	diffReturns struct {
		result1 director.DeploymentDiff
		result2 error
	}
	diffReturnsOnCall map[int]struct {
		result1 director.DeploymentDiff
		result2 error
	}
	ReleasesStub        func() ([]director.Release, error)
	releasesMutex       sync.RWMutex
	releasesArgsForCall []struct{}
	releasesReturns     struct {
		result1 []director.Release
		result2 error
	}
	releasesReturnsOnCall map[int]struct {
		result1 []director.Release
		result2 error
	}
	ExportReleaseStub        func(director.ReleaseSlug, director.OSVersionSlug, []string) (director.ExportReleaseResult, error)
	exportReleaseMutex       sync.RWMutex
	exportReleaseArgsForCall []struct {
		arg1 director.ReleaseSlug
		arg2 director.OSVersionSlug
		arg3 []string
	}
	exportReleaseReturns struct {
		result1 director.ExportReleaseResult
		result2 error
	}
	exportReleaseReturnsOnCall map[int]struct {
		result1 director.ExportReleaseResult
		result2 error
	}
	TeamsStub        func() ([]string, error)
	teamsMutex       sync.RWMutex
	teamsArgsForCall []struct{}
	teamsReturns     struct {
		result1 []string
		result2 error
	}
	teamsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	StemcellsStub        func() ([]director.Stemcell, error)
	stemcellsMutex       sync.RWMutex
	stemcellsArgsForCall []struct{}
	stemcellsReturns     struct {
		result1 []director.Stemcell
		result2 error
	}
	stemcellsReturnsOnCall map[int]struct {
		result1 []director.Stemcell
		result2 error
	}
	VMInfosStub        func() ([]director.VMInfo, error)
	vMInfosMutex       sync.RWMutex
	vMInfosArgsForCall []struct{}
	vMInfosReturns     struct {
		result1 []director.VMInfo
		result2 error
	}
	vMInfosReturnsOnCall map[int]struct {
		result1 []director.VMInfo
		result2 error
	}
	InstancesStub        func() ([]director.Instance, error)
	instancesMutex       sync.RWMutex
	instancesArgsForCall []struct{}
	instancesReturns     struct {
		result1 []director.Instance
		result2 error
	}
	instancesReturnsOnCall map[int]struct {
		result1 []director.Instance
		result2 error
	}
	InstanceInfosStub        func() ([]director.VMInfo, error)
	instanceInfosMutex       sync.RWMutex
	instanceInfosArgsForCall []struct{}
	instanceInfosReturns     struct {
		result1 []director.VMInfo
		result2 error
	}
	instanceInfosReturnsOnCall map[int]struct {
		result1 []director.VMInfo
		result2 error
	}
	ErrandsStub        func() ([]director.Errand, error)
	errandsMutex       sync.RWMutex
	errandsArgsForCall []struct{}
	errandsReturns     struct {
		result1 []director.Errand
		result2 error
	}
	errandsReturnsOnCall map[int]struct {
		result1 []director.Errand
		result2 error
	}
	RunErrandStub        func(string, bool, bool, []director.InstanceGroupOrInstanceSlug) ([]director.ErrandResult, error)
	runErrandMutex       sync.RWMutex
	runErrandArgsForCall []struct {
		arg1 string
		arg2 bool
		arg3 bool
		arg4 []director.InstanceGroupOrInstanceSlug
	}
	runErrandReturns struct {
		result1 []director.ErrandResult
		result2 error
	}
	runErrandReturnsOnCall map[int]struct {
		result1 []director.ErrandResult
		result2 error
	}
	ScanForProblemsStub        func() ([]director.Problem, error)
	scanForProblemsMutex       sync.RWMutex
	scanForProblemsArgsForCall []struct{}
	scanForProblemsReturns     struct {
		result1 []director.Problem
		result2 error
	}
	scanForProblemsReturnsOnCall map[int]struct {
		result1 []director.Problem
		result2 error
	}
	ResolveProblemsStub        func([]director.ProblemAnswer) error
	resolveProblemsMutex       sync.RWMutex
	resolveProblemsArgsForCall []struct {
		arg1 []director.ProblemAnswer
	}
	resolveProblemsReturns struct {
		result1 error
	}
	resolveProblemsReturnsOnCall map[int]struct {
		result1 error
	}
	SnapshotsStub        func() ([]director.Snapshot, error)
	snapshotsMutex       sync.RWMutex
	snapshotsArgsForCall []struct{}
	snapshotsReturns     struct {
		result1 []director.Snapshot
		result2 error
	}
	snapshotsReturnsOnCall map[int]struct {
		result1 []director.Snapshot
		result2 error
	}
	TakeSnapshotsStub        func() error
	takeSnapshotsMutex       sync.RWMutex
	takeSnapshotsArgsForCall []struct{}
	takeSnapshotsReturns     struct {
		result1 error
	}
	takeSnapshotsReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteSnapshotStub        func(string) error
	deleteSnapshotMutex       sync.RWMutex
	deleteSnapshotArgsForCall []struct {
		arg1 string
	}
	deleteSnapshotReturns struct {
		result1 error
	}
	deleteSnapshotReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteSnapshotsStub        func() error
	deleteSnapshotsMutex       sync.RWMutex
	deleteSnapshotsArgsForCall []struct{}
	deleteSnapshotsReturns     struct {
		result1 error
	}
	deleteSnapshotsReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteVMStub        func(string) error
	deleteVMMutex       sync.RWMutex
	deleteVMArgsForCall []struct {
		arg1 string
	}
	deleteVMReturns struct {
		result1 error
	}
	deleteVMReturnsOnCall map[int]struct {
		result1 error
	}
	VariablesStub        func() ([]director.VariableResult, error)
	variablesMutex       sync.RWMutex
	variablesArgsForCall []struct{}
	variablesReturns     struct {
		result1 []director.VariableResult
		result2 error
	}
	variablesReturnsOnCall map[int]struct {
		result1 []director.VariableResult
		result2 error
	}
	StartStub        func(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.StartOpts) error
	startMutex       sync.RWMutex
	startArgsForCall []struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.StartOpts
	}
	startReturns struct {
		result1 error
	}
	startReturnsOnCall map[int]struct {
		result1 error
	}
	StopStub        func(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.StopOpts) error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.StopOpts
	}
	stopReturns struct {
		result1 error
	}
	stopReturnsOnCall map[int]struct {
		result1 error
	}
	RestartStub        func(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.RestartOpts) error
	restartMutex       sync.RWMutex
	restartArgsForCall []struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.RestartOpts
	}
	restartReturns struct {
		result1 error
	}
	restartReturnsOnCall map[int]struct {
		result1 error
	}
	RecreateStub        func(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.RecreateOpts) error
	recreateMutex       sync.RWMutex
	recreateArgsForCall []struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.RecreateOpts
	}
	recreateReturns struct {
		result1 error
	}
	recreateReturnsOnCall map[int]struct {
		result1 error
	}
	SetUpSSHStub        func(director.AllOrInstanceGroupOrInstanceSlug, director.SSHOpts) (director.SSHResult, error)
	setUpSSHMutex       sync.RWMutex
	setUpSSHArgsForCall []struct {
		arg1 director.AllOrInstanceGroupOrInstanceSlug
		arg2 director.SSHOpts
	}
	setUpSSHReturns struct {
		result1 director.SSHResult
		result2 error
	}
	setUpSSHReturnsOnCall map[int]struct {
		result1 director.SSHResult
		result2 error
	}
	CleanUpSSHStub        func(director.AllOrInstanceGroupOrInstanceSlug, director.SSHOpts) error
	cleanUpSSHMutex       sync.RWMutex
	cleanUpSSHArgsForCall []struct {
		arg1 director.AllOrInstanceGroupOrInstanceSlug
		arg2 director.SSHOpts
	}
	cleanUpSSHReturns struct {
		result1 error
	}
	cleanUpSSHReturnsOnCall map[int]struct {
		result1 error
	}
	FetchLogsStub        func(director.AllOrInstanceGroupOrInstanceSlug, []string, bool) (director.LogsResult, error)
	fetchLogsMutex       sync.RWMutex
	fetchLogsArgsForCall []struct {
		arg1 director.AllOrInstanceGroupOrInstanceSlug
		arg2 []string
		arg3 bool
	}
	fetchLogsReturns struct {
		result1 director.LogsResult
		result2 error
	}
	fetchLogsReturnsOnCall map[int]struct {
		result1 director.LogsResult
		result2 error
	}
	TakeSnapshotStub        func(director.InstanceSlug) error
	takeSnapshotMutex       sync.RWMutex
	takeSnapshotArgsForCall []struct {
		arg1 director.InstanceSlug
	}
	takeSnapshotReturns struct {
		result1 error
	}
	takeSnapshotReturnsOnCall map[int]struct {
		result1 error
	}
	IgnoreStub        func(director.InstanceSlug, bool) error
	ignoreMutex       sync.RWMutex
	ignoreArgsForCall []struct {
		arg1 director.InstanceSlug
		arg2 bool
	}
	ignoreReturns struct {
		result1 error
	}
	ignoreReturnsOnCall map[int]struct {
		result1 error
	}
	EnableResurrectionStub        func(director.InstanceSlug, bool) error
	enableResurrectionMutex       sync.RWMutex
	enableResurrectionArgsForCall []struct {
		arg1 director.InstanceSlug
		arg2 bool
	}
	enableResurrectionReturns struct {
		result1 error
	}
	enableResurrectionReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateStub        func(manifest []byte, opts director.UpdateOpts) error
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		manifest []byte
		opts     director.UpdateOpts
	}
	updateReturns struct {
		result1 error
	}
	updateReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(force bool) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		force bool
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	AttachDiskStub        func(slug director.InstanceSlug, diskCID string) error
	attachDiskMutex       sync.RWMutex
	attachDiskArgsForCall []struct {
		slug    director.InstanceSlug
		diskCID string
	}
	attachDiskReturns struct {
		result1 error
	}
	attachDiskReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDeployment) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct{}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nameReturns.result1
}

func (fake *FakeDeployment) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeDeployment) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeDeployment) NameReturnsOnCall(i int, result1 string) {
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeDeployment) Manifest() (string, error) {
	fake.manifestMutex.Lock()
	ret, specificReturn := fake.manifestReturnsOnCall[len(fake.manifestArgsForCall)]
	fake.manifestArgsForCall = append(fake.manifestArgsForCall, struct{}{})
	fake.recordInvocation("Manifest", []interface{}{})
	fake.manifestMutex.Unlock()
	if fake.ManifestStub != nil {
		return fake.ManifestStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.manifestReturns.result1, fake.manifestReturns.result2
}

func (fake *FakeDeployment) ManifestCallCount() int {
	fake.manifestMutex.RLock()
	defer fake.manifestMutex.RUnlock()
	return len(fake.manifestArgsForCall)
}

func (fake *FakeDeployment) ManifestReturns(result1 string, result2 error) {
	fake.ManifestStub = nil
	fake.manifestReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) ManifestReturnsOnCall(i int, result1 string, result2 error) {
	fake.ManifestStub = nil
	if fake.manifestReturnsOnCall == nil {
		fake.manifestReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.manifestReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) CloudConfig() (string, error) {
	fake.cloudConfigMutex.Lock()
	ret, specificReturn := fake.cloudConfigReturnsOnCall[len(fake.cloudConfigArgsForCall)]
	fake.cloudConfigArgsForCall = append(fake.cloudConfigArgsForCall, struct{}{})
	fake.recordInvocation("CloudConfig", []interface{}{})
	fake.cloudConfigMutex.Unlock()
	if fake.CloudConfigStub != nil {
		return fake.CloudConfigStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.cloudConfigReturns.result1, fake.cloudConfigReturns.result2
}

func (fake *FakeDeployment) CloudConfigCallCount() int {
	fake.cloudConfigMutex.RLock()
	defer fake.cloudConfigMutex.RUnlock()
	return len(fake.cloudConfigArgsForCall)
}

func (fake *FakeDeployment) CloudConfigReturns(result1 string, result2 error) {
	fake.CloudConfigStub = nil
	fake.cloudConfigReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) CloudConfigReturnsOnCall(i int, result1 string, result2 error) {
	fake.CloudConfigStub = nil
	if fake.cloudConfigReturnsOnCall == nil {
		fake.cloudConfigReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.cloudConfigReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Diff(arg1 []byte, arg2 bool) (director.DeploymentDiff, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.diffMutex.Lock()
	ret, specificReturn := fake.diffReturnsOnCall[len(fake.diffArgsForCall)]
	fake.diffArgsForCall = append(fake.diffArgsForCall, struct {
		arg1 []byte
		arg2 bool
	}{arg1Copy, arg2})
	fake.recordInvocation("Diff", []interface{}{arg1Copy, arg2})
	fake.diffMutex.Unlock()
	if fake.DiffStub != nil {
		return fake.DiffStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.diffReturns.result1, fake.diffReturns.result2
}

func (fake *FakeDeployment) DiffCallCount() int {
	fake.diffMutex.RLock()
	defer fake.diffMutex.RUnlock()
	return len(fake.diffArgsForCall)
}

func (fake *FakeDeployment) DiffArgsForCall(i int) ([]byte, bool) {
	fake.diffMutex.RLock()
	defer fake.diffMutex.RUnlock()
	return fake.diffArgsForCall[i].arg1, fake.diffArgsForCall[i].arg2
}

func (fake *FakeDeployment) DiffReturns(result1 director.DeploymentDiff, result2 error) {
	fake.DiffStub = nil
	fake.diffReturns = struct {
		result1 director.DeploymentDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) DiffReturnsOnCall(i int, result1 director.DeploymentDiff, result2 error) {
	fake.DiffStub = nil
	if fake.diffReturnsOnCall == nil {
		fake.diffReturnsOnCall = make(map[int]struct {
			result1 director.DeploymentDiff
			result2 error
		})
	}
	fake.diffReturnsOnCall[i] = struct {
		result1 director.DeploymentDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Releases() ([]director.Release, error) {
	fake.releasesMutex.Lock()
	ret, specificReturn := fake.releasesReturnsOnCall[len(fake.releasesArgsForCall)]
	fake.releasesArgsForCall = append(fake.releasesArgsForCall, struct{}{})
	fake.recordInvocation("Releases", []interface{}{})
	fake.releasesMutex.Unlock()
	if fake.ReleasesStub != nil {
		return fake.ReleasesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.releasesReturns.result1, fake.releasesReturns.result2
}

func (fake *FakeDeployment) ReleasesCallCount() int {
	fake.releasesMutex.RLock()
	defer fake.releasesMutex.RUnlock()
	return len(fake.releasesArgsForCall)
}

func (fake *FakeDeployment) ReleasesReturns(result1 []director.Release, result2 error) {
	fake.ReleasesStub = nil
	fake.releasesReturns = struct {
		result1 []director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) ReleasesReturnsOnCall(i int, result1 []director.Release, result2 error) {
	fake.ReleasesStub = nil
	if fake.releasesReturnsOnCall == nil {
		fake.releasesReturnsOnCall = make(map[int]struct {
			result1 []director.Release
			result2 error
		})
	}
	fake.releasesReturnsOnCall[i] = struct {
		result1 []director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) ExportRelease(arg1 director.ReleaseSlug, arg2 director.OSVersionSlug, arg3 []string) (director.ExportReleaseResult, error) {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.exportReleaseMutex.Lock()
	ret, specificReturn := fake.exportReleaseReturnsOnCall[len(fake.exportReleaseArgsForCall)]
	fake.exportReleaseArgsForCall = append(fake.exportReleaseArgsForCall, struct {
		arg1 director.ReleaseSlug
		arg2 director.OSVersionSlug
		arg3 []string
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("ExportRelease", []interface{}{arg1, arg2, arg3Copy})
	fake.exportReleaseMutex.Unlock()
	if fake.ExportReleaseStub != nil {
		return fake.ExportReleaseStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.exportReleaseReturns.result1, fake.exportReleaseReturns.result2
}

func (fake *FakeDeployment) ExportReleaseCallCount() int {
	fake.exportReleaseMutex.RLock()
	defer fake.exportReleaseMutex.RUnlock()
	return len(fake.exportReleaseArgsForCall)
}

func (fake *FakeDeployment) ExportReleaseArgsForCall(i int) (director.ReleaseSlug, director.OSVersionSlug, []string) {
	fake.exportReleaseMutex.RLock()
	defer fake.exportReleaseMutex.RUnlock()
	return fake.exportReleaseArgsForCall[i].arg1, fake.exportReleaseArgsForCall[i].arg2, fake.exportReleaseArgsForCall[i].arg3
}

func (fake *FakeDeployment) ExportReleaseReturns(result1 director.ExportReleaseResult, result2 error) {
	fake.ExportReleaseStub = nil
	fake.exportReleaseReturns = struct {
		result1 director.ExportReleaseResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) ExportReleaseReturnsOnCall(i int, result1 director.ExportReleaseResult, result2 error) {
	fake.ExportReleaseStub = nil
	if fake.exportReleaseReturnsOnCall == nil {
		fake.exportReleaseReturnsOnCall = make(map[int]struct {
			result1 director.ExportReleaseResult
			result2 error
		})
	}
	fake.exportReleaseReturnsOnCall[i] = struct {
		result1 director.ExportReleaseResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Teams() ([]string, error) {
	fake.teamsMutex.Lock()
	ret, specificReturn := fake.teamsReturnsOnCall[len(fake.teamsArgsForCall)]
	fake.teamsArgsForCall = append(fake.teamsArgsForCall, struct{}{})
	fake.recordInvocation("Teams", []interface{}{})
	fake.teamsMutex.Unlock()
	if fake.TeamsStub != nil {
		return fake.TeamsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.teamsReturns.result1, fake.teamsReturns.result2
}

func (fake *FakeDeployment) TeamsCallCount() int {
	fake.teamsMutex.RLock()
	defer fake.teamsMutex.RUnlock()
	return len(fake.teamsArgsForCall)
}

func (fake *FakeDeployment) TeamsReturns(result1 []string, result2 error) {
	fake.TeamsStub = nil
	fake.teamsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) TeamsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.TeamsStub = nil
	if fake.teamsReturnsOnCall == nil {
		fake.teamsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.teamsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Stemcells() ([]director.Stemcell, error) {
	fake.stemcellsMutex.Lock()
	ret, specificReturn := fake.stemcellsReturnsOnCall[len(fake.stemcellsArgsForCall)]
	fake.stemcellsArgsForCall = append(fake.stemcellsArgsForCall, struct{}{})
	fake.recordInvocation("Stemcells", []interface{}{})
	fake.stemcellsMutex.Unlock()
	if fake.StemcellsStub != nil {
		return fake.StemcellsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.stemcellsReturns.result1, fake.stemcellsReturns.result2
}

func (fake *FakeDeployment) StemcellsCallCount() int {
	fake.stemcellsMutex.RLock()
	defer fake.stemcellsMutex.RUnlock()
	return len(fake.stemcellsArgsForCall)
}

func (fake *FakeDeployment) StemcellsReturns(result1 []director.Stemcell, result2 error) {
	fake.StemcellsStub = nil
	fake.stemcellsReturns = struct {
		result1 []director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) StemcellsReturnsOnCall(i int, result1 []director.Stemcell, result2 error) {
	fake.StemcellsStub = nil
	if fake.stemcellsReturnsOnCall == nil {
		fake.stemcellsReturnsOnCall = make(map[int]struct {
			result1 []director.Stemcell
			result2 error
		})
	}
	fake.stemcellsReturnsOnCall[i] = struct {
		result1 []director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) VMInfos() ([]director.VMInfo, error) {
	fake.vMInfosMutex.Lock()
	ret, specificReturn := fake.vMInfosReturnsOnCall[len(fake.vMInfosArgsForCall)]
	fake.vMInfosArgsForCall = append(fake.vMInfosArgsForCall, struct{}{})
	fake.recordInvocation("VMInfos", []interface{}{})
	fake.vMInfosMutex.Unlock()
	if fake.VMInfosStub != nil {
		return fake.VMInfosStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.vMInfosReturns.result1, fake.vMInfosReturns.result2
}

func (fake *FakeDeployment) VMInfosCallCount() int {
	fake.vMInfosMutex.RLock()
	defer fake.vMInfosMutex.RUnlock()
	return len(fake.vMInfosArgsForCall)
}

func (fake *FakeDeployment) VMInfosReturns(result1 []director.VMInfo, result2 error) {
	fake.VMInfosStub = nil
	fake.vMInfosReturns = struct {
		result1 []director.VMInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) VMInfosReturnsOnCall(i int, result1 []director.VMInfo, result2 error) {
	fake.VMInfosStub = nil
	if fake.vMInfosReturnsOnCall == nil {
		fake.vMInfosReturnsOnCall = make(map[int]struct {
			result1 []director.VMInfo
			result2 error
		})
	}
	fake.vMInfosReturnsOnCall[i] = struct {
		result1 []director.VMInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Instances() ([]director.Instance, error) {
	fake.instancesMutex.Lock()
	ret, specificReturn := fake.instancesReturnsOnCall[len(fake.instancesArgsForCall)]
	fake.instancesArgsForCall = append(fake.instancesArgsForCall, struct{}{})
	fake.recordInvocation("Instances", []interface{}{})
	fake.instancesMutex.Unlock()
	if fake.InstancesStub != nil {
		return fake.InstancesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.instancesReturns.result1, fake.instancesReturns.result2
}

func (fake *FakeDeployment) InstancesCallCount() int {
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	return len(fake.instancesArgsForCall)
}

func (fake *FakeDeployment) InstancesReturns(result1 []director.Instance, result2 error) {
	fake.InstancesStub = nil
	fake.instancesReturns = struct {
		result1 []director.Instance
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) InstancesReturnsOnCall(i int, result1 []director.Instance, result2 error) {
	fake.InstancesStub = nil
	if fake.instancesReturnsOnCall == nil {
		fake.instancesReturnsOnCall = make(map[int]struct {
			result1 []director.Instance
			result2 error
		})
	}
	fake.instancesReturnsOnCall[i] = struct {
		result1 []director.Instance
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) InstanceInfos() ([]director.VMInfo, error) {
	fake.instanceInfosMutex.Lock()
	ret, specificReturn := fake.instanceInfosReturnsOnCall[len(fake.instanceInfosArgsForCall)]
	fake.instanceInfosArgsForCall = append(fake.instanceInfosArgsForCall, struct{}{})
	fake.recordInvocation("InstanceInfos", []interface{}{})
	fake.instanceInfosMutex.Unlock()
	if fake.InstanceInfosStub != nil {
		return fake.InstanceInfosStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.instanceInfosReturns.result1, fake.instanceInfosReturns.result2
}

func (fake *FakeDeployment) InstanceInfosCallCount() int {
	fake.instanceInfosMutex.RLock()
	defer fake.instanceInfosMutex.RUnlock()
	return len(fake.instanceInfosArgsForCall)
}

func (fake *FakeDeployment) InstanceInfosReturns(result1 []director.VMInfo, result2 error) {
	fake.InstanceInfosStub = nil
	fake.instanceInfosReturns = struct {
		result1 []director.VMInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) InstanceInfosReturnsOnCall(i int, result1 []director.VMInfo, result2 error) {
	fake.InstanceInfosStub = nil
	if fake.instanceInfosReturnsOnCall == nil {
		fake.instanceInfosReturnsOnCall = make(map[int]struct {
			result1 []director.VMInfo
			result2 error
		})
	}
	fake.instanceInfosReturnsOnCall[i] = struct {
		result1 []director.VMInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Errands() ([]director.Errand, error) {
	fake.errandsMutex.Lock()
	ret, specificReturn := fake.errandsReturnsOnCall[len(fake.errandsArgsForCall)]
	fake.errandsArgsForCall = append(fake.errandsArgsForCall, struct{}{})
	fake.recordInvocation("Errands", []interface{}{})
	fake.errandsMutex.Unlock()
	if fake.ErrandsStub != nil {
		return fake.ErrandsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.errandsReturns.result1, fake.errandsReturns.result2
}

func (fake *FakeDeployment) ErrandsCallCount() int {
	fake.errandsMutex.RLock()
	defer fake.errandsMutex.RUnlock()
	return len(fake.errandsArgsForCall)
}

func (fake *FakeDeployment) ErrandsReturns(result1 []director.Errand, result2 error) {
	fake.ErrandsStub = nil
	fake.errandsReturns = struct {
		result1 []director.Errand
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) ErrandsReturnsOnCall(i int, result1 []director.Errand, result2 error) {
	fake.ErrandsStub = nil
	if fake.errandsReturnsOnCall == nil {
		fake.errandsReturnsOnCall = make(map[int]struct {
			result1 []director.Errand
			result2 error
		})
	}
	fake.errandsReturnsOnCall[i] = struct {
		result1 []director.Errand
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) RunErrand(arg1 string, arg2 bool, arg3 bool, arg4 []director.InstanceGroupOrInstanceSlug) ([]director.ErrandResult, error) {
	var arg4Copy []director.InstanceGroupOrInstanceSlug
	if arg4 != nil {
		arg4Copy = make([]director.InstanceGroupOrInstanceSlug, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.runErrandMutex.Lock()
	ret, specificReturn := fake.runErrandReturnsOnCall[len(fake.runErrandArgsForCall)]
	fake.runErrandArgsForCall = append(fake.runErrandArgsForCall, struct {
		arg1 string
		arg2 bool
		arg3 bool
		arg4 []director.InstanceGroupOrInstanceSlug
	}{arg1, arg2, arg3, arg4Copy})
	fake.recordInvocation("RunErrand", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.runErrandMutex.Unlock()
	if fake.RunErrandStub != nil {
		return fake.RunErrandStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.runErrandReturns.result1, fake.runErrandReturns.result2
}

func (fake *FakeDeployment) RunErrandCallCount() int {
	fake.runErrandMutex.RLock()
	defer fake.runErrandMutex.RUnlock()
	return len(fake.runErrandArgsForCall)
}

func (fake *FakeDeployment) RunErrandArgsForCall(i int) (string, bool, bool, []director.InstanceGroupOrInstanceSlug) {
	fake.runErrandMutex.RLock()
	defer fake.runErrandMutex.RUnlock()
	return fake.runErrandArgsForCall[i].arg1, fake.runErrandArgsForCall[i].arg2, fake.runErrandArgsForCall[i].arg3, fake.runErrandArgsForCall[i].arg4
}

func (fake *FakeDeployment) RunErrandReturns(result1 []director.ErrandResult, result2 error) {
	fake.RunErrandStub = nil
	fake.runErrandReturns = struct {
		result1 []director.ErrandResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) RunErrandReturnsOnCall(i int, result1 []director.ErrandResult, result2 error) {
	fake.RunErrandStub = nil
	if fake.runErrandReturnsOnCall == nil {
		fake.runErrandReturnsOnCall = make(map[int]struct {
			result1 []director.ErrandResult
			result2 error
		})
	}
	fake.runErrandReturnsOnCall[i] = struct {
		result1 []director.ErrandResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) ScanForProblems() ([]director.Problem, error) {
	fake.scanForProblemsMutex.Lock()
	ret, specificReturn := fake.scanForProblemsReturnsOnCall[len(fake.scanForProblemsArgsForCall)]
	fake.scanForProblemsArgsForCall = append(fake.scanForProblemsArgsForCall, struct{}{})
	fake.recordInvocation("ScanForProblems", []interface{}{})
	fake.scanForProblemsMutex.Unlock()
	if fake.ScanForProblemsStub != nil {
		return fake.ScanForProblemsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.scanForProblemsReturns.result1, fake.scanForProblemsReturns.result2
}

func (fake *FakeDeployment) ScanForProblemsCallCount() int {
	fake.scanForProblemsMutex.RLock()
	defer fake.scanForProblemsMutex.RUnlock()
	return len(fake.scanForProblemsArgsForCall)
}

func (fake *FakeDeployment) ScanForProblemsReturns(result1 []director.Problem, result2 error) {
	fake.ScanForProblemsStub = nil
	fake.scanForProblemsReturns = struct {
		result1 []director.Problem
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) ScanForProblemsReturnsOnCall(i int, result1 []director.Problem, result2 error) {
	fake.ScanForProblemsStub = nil
	if fake.scanForProblemsReturnsOnCall == nil {
		fake.scanForProblemsReturnsOnCall = make(map[int]struct {
			result1 []director.Problem
			result2 error
		})
	}
	fake.scanForProblemsReturnsOnCall[i] = struct {
		result1 []director.Problem
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) ResolveProblems(arg1 []director.ProblemAnswer) error {
	var arg1Copy []director.ProblemAnswer
	if arg1 != nil {
		arg1Copy = make([]director.ProblemAnswer, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.resolveProblemsMutex.Lock()
	ret, specificReturn := fake.resolveProblemsReturnsOnCall[len(fake.resolveProblemsArgsForCall)]
	fake.resolveProblemsArgsForCall = append(fake.resolveProblemsArgsForCall, struct {
		arg1 []director.ProblemAnswer
	}{arg1Copy})
	fake.recordInvocation("ResolveProblems", []interface{}{arg1Copy})
	fake.resolveProblemsMutex.Unlock()
	if fake.ResolveProblemsStub != nil {
		return fake.ResolveProblemsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.resolveProblemsReturns.result1
}

func (fake *FakeDeployment) ResolveProblemsCallCount() int {
	fake.resolveProblemsMutex.RLock()
	defer fake.resolveProblemsMutex.RUnlock()
	return len(fake.resolveProblemsArgsForCall)
}

func (fake *FakeDeployment) ResolveProblemsArgsForCall(i int) []director.ProblemAnswer {
	fake.resolveProblemsMutex.RLock()
	defer fake.resolveProblemsMutex.RUnlock()
	return fake.resolveProblemsArgsForCall[i].arg1
}

func (fake *FakeDeployment) ResolveProblemsReturns(result1 error) {
	fake.ResolveProblemsStub = nil
	fake.resolveProblemsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) ResolveProblemsReturnsOnCall(i int, result1 error) {
	fake.ResolveProblemsStub = nil
	if fake.resolveProblemsReturnsOnCall == nil {
		fake.resolveProblemsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resolveProblemsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Snapshots() ([]director.Snapshot, error) {
	fake.snapshotsMutex.Lock()
	ret, specificReturn := fake.snapshotsReturnsOnCall[len(fake.snapshotsArgsForCall)]
	fake.snapshotsArgsForCall = append(fake.snapshotsArgsForCall, struct{}{})
	fake.recordInvocation("Snapshots", []interface{}{})
	fake.snapshotsMutex.Unlock()
	if fake.SnapshotsStub != nil {
		return fake.SnapshotsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.snapshotsReturns.result1, fake.snapshotsReturns.result2
}

func (fake *FakeDeployment) SnapshotsCallCount() int {
	fake.snapshotsMutex.RLock()
	defer fake.snapshotsMutex.RUnlock()
	return len(fake.snapshotsArgsForCall)
}

func (fake *FakeDeployment) SnapshotsReturns(result1 []director.Snapshot, result2 error) {
	fake.SnapshotsStub = nil
	fake.snapshotsReturns = struct {
		result1 []director.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) SnapshotsReturnsOnCall(i int, result1 []director.Snapshot, result2 error) {
	fake.SnapshotsStub = nil
	if fake.snapshotsReturnsOnCall == nil {
		fake.snapshotsReturnsOnCall = make(map[int]struct {
			result1 []director.Snapshot
			result2 error
		})
	}
	fake.snapshotsReturnsOnCall[i] = struct {
		result1 []director.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) TakeSnapshots() error {
	fake.takeSnapshotsMutex.Lock()
	ret, specificReturn := fake.takeSnapshotsReturnsOnCall[len(fake.takeSnapshotsArgsForCall)]
	fake.takeSnapshotsArgsForCall = append(fake.takeSnapshotsArgsForCall, struct{}{})
	fake.recordInvocation("TakeSnapshots", []interface{}{})
	fake.takeSnapshotsMutex.Unlock()
	if fake.TakeSnapshotsStub != nil {
		return fake.TakeSnapshotsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.takeSnapshotsReturns.result1
}

func (fake *FakeDeployment) TakeSnapshotsCallCount() int {
	fake.takeSnapshotsMutex.RLock()
	defer fake.takeSnapshotsMutex.RUnlock()
	return len(fake.takeSnapshotsArgsForCall)
}

func (fake *FakeDeployment) TakeSnapshotsReturns(result1 error) {
	fake.TakeSnapshotsStub = nil
	fake.takeSnapshotsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) TakeSnapshotsReturnsOnCall(i int, result1 error) {
	fake.TakeSnapshotsStub = nil
	if fake.takeSnapshotsReturnsOnCall == nil {
		fake.takeSnapshotsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.takeSnapshotsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) DeleteSnapshot(arg1 string) error {
	fake.deleteSnapshotMutex.Lock()
	ret, specificReturn := fake.deleteSnapshotReturnsOnCall[len(fake.deleteSnapshotArgsForCall)]
	fake.deleteSnapshotArgsForCall = append(fake.deleteSnapshotArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteSnapshot", []interface{}{arg1})
	fake.deleteSnapshotMutex.Unlock()
	if fake.DeleteSnapshotStub != nil {
		return fake.DeleteSnapshotStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteSnapshotReturns.result1
}

func (fake *FakeDeployment) DeleteSnapshotCallCount() int {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	return len(fake.deleteSnapshotArgsForCall)
}

func (fake *FakeDeployment) DeleteSnapshotArgsForCall(i int) string {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	return fake.deleteSnapshotArgsForCall[i].arg1
}

func (fake *FakeDeployment) DeleteSnapshotReturns(result1 error) {
	fake.DeleteSnapshotStub = nil
	fake.deleteSnapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) DeleteSnapshotReturnsOnCall(i int, result1 error) {
	fake.DeleteSnapshotStub = nil
	if fake.deleteSnapshotReturnsOnCall == nil {
		fake.deleteSnapshotReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSnapshotReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) DeleteSnapshots() error {
	fake.deleteSnapshotsMutex.Lock()
	ret, specificReturn := fake.deleteSnapshotsReturnsOnCall[len(fake.deleteSnapshotsArgsForCall)]
	fake.deleteSnapshotsArgsForCall = append(fake.deleteSnapshotsArgsForCall, struct{}{})
	fake.recordInvocation("DeleteSnapshots", []interface{}{})
	fake.deleteSnapshotsMutex.Unlock()
	if fake.DeleteSnapshotsStub != nil {
		return fake.DeleteSnapshotsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteSnapshotsReturns.result1
}

func (fake *FakeDeployment) DeleteSnapshotsCallCount() int {
	fake.deleteSnapshotsMutex.RLock()
	defer fake.deleteSnapshotsMutex.RUnlock()
	return len(fake.deleteSnapshotsArgsForCall)
}

func (fake *FakeDeployment) DeleteSnapshotsReturns(result1 error) {
	fake.DeleteSnapshotsStub = nil
	fake.deleteSnapshotsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) DeleteSnapshotsReturnsOnCall(i int, result1 error) {
	fake.DeleteSnapshotsStub = nil
	if fake.deleteSnapshotsReturnsOnCall == nil {
		fake.deleteSnapshotsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSnapshotsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) DeleteVM(arg1 string) error {
	fake.deleteVMMutex.Lock()
	ret, specificReturn := fake.deleteVMReturnsOnCall[len(fake.deleteVMArgsForCall)]
	fake.deleteVMArgsForCall = append(fake.deleteVMArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteVM", []interface{}{arg1})
	fake.deleteVMMutex.Unlock()
	if fake.DeleteVMStub != nil {
		return fake.DeleteVMStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteVMReturns.result1
}

func (fake *FakeDeployment) DeleteVMCallCount() int {
	fake.deleteVMMutex.RLock()
	defer fake.deleteVMMutex.RUnlock()
	return len(fake.deleteVMArgsForCall)
}

func (fake *FakeDeployment) DeleteVMArgsForCall(i int) string {
	fake.deleteVMMutex.RLock()
	defer fake.deleteVMMutex.RUnlock()
	return fake.deleteVMArgsForCall[i].arg1
}

func (fake *FakeDeployment) DeleteVMReturns(result1 error) {
	fake.DeleteVMStub = nil
	fake.deleteVMReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) DeleteVMReturnsOnCall(i int, result1 error) {
	fake.DeleteVMStub = nil
	if fake.deleteVMReturnsOnCall == nil {
		fake.deleteVMReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVMReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Variables() ([]director.VariableResult, error) {
	fake.variablesMutex.Lock()
	ret, specificReturn := fake.variablesReturnsOnCall[len(fake.variablesArgsForCall)]
	fake.variablesArgsForCall = append(fake.variablesArgsForCall, struct{}{})
	fake.recordInvocation("Variables", []interface{}{})
	fake.variablesMutex.Unlock()
	if fake.VariablesStub != nil {
		return fake.VariablesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.variablesReturns.result1, fake.variablesReturns.result2
}

func (fake *FakeDeployment) VariablesCallCount() int {
	fake.variablesMutex.RLock()
	defer fake.variablesMutex.RUnlock()
	return len(fake.variablesArgsForCall)
}

func (fake *FakeDeployment) VariablesReturns(result1 []director.VariableResult, result2 error) {
	fake.VariablesStub = nil
	fake.variablesReturns = struct {
		result1 []director.VariableResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) VariablesReturnsOnCall(i int, result1 []director.VariableResult, result2 error) {
	fake.VariablesStub = nil
	if fake.variablesReturnsOnCall == nil {
		fake.variablesReturnsOnCall = make(map[int]struct {
			result1 []director.VariableResult
			result2 error
		})
	}
	fake.variablesReturnsOnCall[i] = struct {
		result1 []director.VariableResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Start(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.StartOpts) error {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.StartOpts
	}{slug, opts})
	fake.recordInvocation("Start", []interface{}{slug, opts})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub(slug, opts)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startReturns.result1
}

func (fake *FakeDeployment) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeDeployment) StartArgsForCall(i int) (director.AllOrInstanceGroupOrInstanceSlug, director.StartOpts) {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return fake.startArgsForCall[i].slug, fake.startArgsForCall[i].opts
}

func (fake *FakeDeployment) StartReturns(result1 error) {
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) StartReturnsOnCall(i int, result1 error) {
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Stop(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.StopOpts) error {
	fake.stopMutex.Lock()
	ret, specificReturn := fake.stopReturnsOnCall[len(fake.stopArgsForCall)]
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.StopOpts
	}{slug, opts})
	fake.recordInvocation("Stop", []interface{}{slug, opts})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		return fake.StopStub(slug, opts)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stopReturns.result1
}

func (fake *FakeDeployment) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeDeployment) StopArgsForCall(i int) (director.AllOrInstanceGroupOrInstanceSlug, director.StopOpts) {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return fake.stopArgsForCall[i].slug, fake.stopArgsForCall[i].opts
}

func (fake *FakeDeployment) StopReturns(result1 error) {
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) StopReturnsOnCall(i int, result1 error) {
	fake.StopStub = nil
	if fake.stopReturnsOnCall == nil {
		fake.stopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Restart(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.RestartOpts) error {
	fake.restartMutex.Lock()
	ret, specificReturn := fake.restartReturnsOnCall[len(fake.restartArgsForCall)]
	fake.restartArgsForCall = append(fake.restartArgsForCall, struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.RestartOpts
	}{slug, opts})
	fake.recordInvocation("Restart", []interface{}{slug, opts})
	fake.restartMutex.Unlock()
	if fake.RestartStub != nil {
		return fake.RestartStub(slug, opts)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.restartReturns.result1
}

func (fake *FakeDeployment) RestartCallCount() int {
	fake.restartMutex.RLock()
	defer fake.restartMutex.RUnlock()
	return len(fake.restartArgsForCall)
}

func (fake *FakeDeployment) RestartArgsForCall(i int) (director.AllOrInstanceGroupOrInstanceSlug, director.RestartOpts) {
	fake.restartMutex.RLock()
	defer fake.restartMutex.RUnlock()
	return fake.restartArgsForCall[i].slug, fake.restartArgsForCall[i].opts
}

func (fake *FakeDeployment) RestartReturns(result1 error) {
	fake.RestartStub = nil
	fake.restartReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) RestartReturnsOnCall(i int, result1 error) {
	fake.RestartStub = nil
	if fake.restartReturnsOnCall == nil {
		fake.restartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.restartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Recreate(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.RecreateOpts) error {
	fake.recreateMutex.Lock()
	ret, specificReturn := fake.recreateReturnsOnCall[len(fake.recreateArgsForCall)]
	fake.recreateArgsForCall = append(fake.recreateArgsForCall, struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.RecreateOpts
	}{slug, opts})
	fake.recordInvocation("Recreate", []interface{}{slug, opts})
	fake.recreateMutex.Unlock()
	if fake.RecreateStub != nil {
		return fake.RecreateStub(slug, opts)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.recreateReturns.result1
}

func (fake *FakeDeployment) RecreateCallCount() int {
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	return len(fake.recreateArgsForCall)
}

func (fake *FakeDeployment) RecreateArgsForCall(i int) (director.AllOrInstanceGroupOrInstanceSlug, director.RecreateOpts) {
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	return fake.recreateArgsForCall[i].slug, fake.recreateArgsForCall[i].opts
}

func (fake *FakeDeployment) RecreateReturns(result1 error) {
	fake.RecreateStub = nil
	fake.recreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) RecreateReturnsOnCall(i int, result1 error) {
	fake.RecreateStub = nil
	if fake.recreateReturnsOnCall == nil {
		fake.recreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.recreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) SetUpSSH(arg1 director.AllOrInstanceGroupOrInstanceSlug, arg2 director.SSHOpts) (director.SSHResult, error) {
	fake.setUpSSHMutex.Lock()
	ret, specificReturn := fake.setUpSSHReturnsOnCall[len(fake.setUpSSHArgsForCall)]
	fake.setUpSSHArgsForCall = append(fake.setUpSSHArgsForCall, struct {
		arg1 director.AllOrInstanceGroupOrInstanceSlug
		arg2 director.SSHOpts
	}{arg1, arg2})
	fake.recordInvocation("SetUpSSH", []interface{}{arg1, arg2})
	fake.setUpSSHMutex.Unlock()
	if fake.SetUpSSHStub != nil {
		return fake.SetUpSSHStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.setUpSSHReturns.result1, fake.setUpSSHReturns.result2
}

func (fake *FakeDeployment) SetUpSSHCallCount() int {
	fake.setUpSSHMutex.RLock()
	defer fake.setUpSSHMutex.RUnlock()
	return len(fake.setUpSSHArgsForCall)
}

func (fake *FakeDeployment) SetUpSSHArgsForCall(i int) (director.AllOrInstanceGroupOrInstanceSlug, director.SSHOpts) {
	fake.setUpSSHMutex.RLock()
	defer fake.setUpSSHMutex.RUnlock()
	return fake.setUpSSHArgsForCall[i].arg1, fake.setUpSSHArgsForCall[i].arg2
}

func (fake *FakeDeployment) SetUpSSHReturns(result1 director.SSHResult, result2 error) {
	fake.SetUpSSHStub = nil
	fake.setUpSSHReturns = struct {
		result1 director.SSHResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) SetUpSSHReturnsOnCall(i int, result1 director.SSHResult, result2 error) {
	fake.SetUpSSHStub = nil
	if fake.setUpSSHReturnsOnCall == nil {
		fake.setUpSSHReturnsOnCall = make(map[int]struct {
			result1 director.SSHResult
			result2 error
		})
	}
	fake.setUpSSHReturnsOnCall[i] = struct {
		result1 director.SSHResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) CleanUpSSH(arg1 director.AllOrInstanceGroupOrInstanceSlug, arg2 director.SSHOpts) error {
	fake.cleanUpSSHMutex.Lock()
	ret, specificReturn := fake.cleanUpSSHReturnsOnCall[len(fake.cleanUpSSHArgsForCall)]
	fake.cleanUpSSHArgsForCall = append(fake.cleanUpSSHArgsForCall, struct {
		arg1 director.AllOrInstanceGroupOrInstanceSlug
		arg2 director.SSHOpts
	}{arg1, arg2})
	fake.recordInvocation("CleanUpSSH", []interface{}{arg1, arg2})
	fake.cleanUpSSHMutex.Unlock()
	if fake.CleanUpSSHStub != nil {
		return fake.CleanUpSSHStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cleanUpSSHReturns.result1
}

func (fake *FakeDeployment) CleanUpSSHCallCount() int {
	fake.cleanUpSSHMutex.RLock()
	defer fake.cleanUpSSHMutex.RUnlock()
	return len(fake.cleanUpSSHArgsForCall)
}

func (fake *FakeDeployment) CleanUpSSHArgsForCall(i int) (director.AllOrInstanceGroupOrInstanceSlug, director.SSHOpts) {
	fake.cleanUpSSHMutex.RLock()
	defer fake.cleanUpSSHMutex.RUnlock()
	return fake.cleanUpSSHArgsForCall[i].arg1, fake.cleanUpSSHArgsForCall[i].arg2
}

func (fake *FakeDeployment) CleanUpSSHReturns(result1 error) {
	fake.CleanUpSSHStub = nil
	fake.cleanUpSSHReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CleanUpSSHReturnsOnCall(i int, result1 error) {
	fake.CleanUpSSHStub = nil
	if fake.cleanUpSSHReturnsOnCall == nil {
		fake.cleanUpSSHReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanUpSSHReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) FetchLogs(arg1 director.AllOrInstanceGroupOrInstanceSlug, arg2 []string, arg3 bool) (director.LogsResult, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.fetchLogsMutex.Lock()
	ret, specificReturn := fake.fetchLogsReturnsOnCall[len(fake.fetchLogsArgsForCall)]
	fake.fetchLogsArgsForCall = append(fake.fetchLogsArgsForCall, struct {
		arg1 director.AllOrInstanceGroupOrInstanceSlug
		arg2 []string
		arg3 bool
	}{arg1, arg2Copy, arg3})
	fake.recordInvocation("FetchLogs", []interface{}{arg1, arg2Copy, arg3})
	fake.fetchLogsMutex.Unlock()
	if fake.FetchLogsStub != nil {
		return fake.FetchLogsStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.fetchLogsReturns.result1, fake.fetchLogsReturns.result2
}

func (fake *FakeDeployment) FetchLogsCallCount() int {
	fake.fetchLogsMutex.RLock()
	defer fake.fetchLogsMutex.RUnlock()
	return len(fake.fetchLogsArgsForCall)
}

func (fake *FakeDeployment) FetchLogsArgsForCall(i int) (director.AllOrInstanceGroupOrInstanceSlug, []string, bool) {
	fake.fetchLogsMutex.RLock()
	defer fake.fetchLogsMutex.RUnlock()
	return fake.fetchLogsArgsForCall[i].arg1, fake.fetchLogsArgsForCall[i].arg2, fake.fetchLogsArgsForCall[i].arg3
}

func (fake *FakeDeployment) FetchLogsReturns(result1 director.LogsResult, result2 error) {
	fake.FetchLogsStub = nil
	fake.fetchLogsReturns = struct {
		result1 director.LogsResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) FetchLogsReturnsOnCall(i int, result1 director.LogsResult, result2 error) {
	fake.FetchLogsStub = nil
	if fake.fetchLogsReturnsOnCall == nil {
		fake.fetchLogsReturnsOnCall = make(map[int]struct {
			result1 director.LogsResult
			result2 error
		})
	}
	fake.fetchLogsReturnsOnCall[i] = struct {
		result1 director.LogsResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) TakeSnapshot(arg1 director.InstanceSlug) error {
	fake.takeSnapshotMutex.Lock()
	ret, specificReturn := fake.takeSnapshotReturnsOnCall[len(fake.takeSnapshotArgsForCall)]
	fake.takeSnapshotArgsForCall = append(fake.takeSnapshotArgsForCall, struct {
		arg1 director.InstanceSlug
	}{arg1})
	fake.recordInvocation("TakeSnapshot", []interface{}{arg1})
	fake.takeSnapshotMutex.Unlock()
	if fake.TakeSnapshotStub != nil {
		return fake.TakeSnapshotStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.takeSnapshotReturns.result1
}

func (fake *FakeDeployment) TakeSnapshotCallCount() int {
	fake.takeSnapshotMutex.RLock()
	defer fake.takeSnapshotMutex.RUnlock()
	return len(fake.takeSnapshotArgsForCall)
}

func (fake *FakeDeployment) TakeSnapshotArgsForCall(i int) director.InstanceSlug {
	fake.takeSnapshotMutex.RLock()
	defer fake.takeSnapshotMutex.RUnlock()
	return fake.takeSnapshotArgsForCall[i].arg1
}

func (fake *FakeDeployment) TakeSnapshotReturns(result1 error) {
	fake.TakeSnapshotStub = nil
	fake.takeSnapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) TakeSnapshotReturnsOnCall(i int, result1 error) {
	fake.TakeSnapshotStub = nil
	if fake.takeSnapshotReturnsOnCall == nil {
		fake.takeSnapshotReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.takeSnapshotReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Ignore(arg1 director.InstanceSlug, arg2 bool) error {
	fake.ignoreMutex.Lock()
	ret, specificReturn := fake.ignoreReturnsOnCall[len(fake.ignoreArgsForCall)]
	fake.ignoreArgsForCall = append(fake.ignoreArgsForCall, struct {
		arg1 director.InstanceSlug
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("Ignore", []interface{}{arg1, arg2})
	fake.ignoreMutex.Unlock()
	if fake.IgnoreStub != nil {
		return fake.IgnoreStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ignoreReturns.result1
}

func (fake *FakeDeployment) IgnoreCallCount() int {
	fake.ignoreMutex.RLock()
	defer fake.ignoreMutex.RUnlock()
	return len(fake.ignoreArgsForCall)
}

func (fake *FakeDeployment) IgnoreArgsForCall(i int) (director.InstanceSlug, bool) {
	fake.ignoreMutex.RLock()
	defer fake.ignoreMutex.RUnlock()
	return fake.ignoreArgsForCall[i].arg1, fake.ignoreArgsForCall[i].arg2
}

func (fake *FakeDeployment) IgnoreReturns(result1 error) {
	fake.IgnoreStub = nil
	fake.ignoreReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) IgnoreReturnsOnCall(i int, result1 error) {
	fake.IgnoreStub = nil
	if fake.ignoreReturnsOnCall == nil {
		fake.ignoreReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ignoreReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) EnableResurrection(arg1 director.InstanceSlug, arg2 bool) error {
	fake.enableResurrectionMutex.Lock()
	ret, specificReturn := fake.enableResurrectionReturnsOnCall[len(fake.enableResurrectionArgsForCall)]
	fake.enableResurrectionArgsForCall = append(fake.enableResurrectionArgsForCall, struct {
		arg1 director.InstanceSlug
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("EnableResurrection", []interface{}{arg1, arg2})
	fake.enableResurrectionMutex.Unlock()
	if fake.EnableResurrectionStub != nil {
		return fake.EnableResurrectionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.enableResurrectionReturns.result1
}

func (fake *FakeDeployment) EnableResurrectionCallCount() int {
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	return len(fake.enableResurrectionArgsForCall)
}

func (fake *FakeDeployment) EnableResurrectionArgsForCall(i int) (director.InstanceSlug, bool) {
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	return fake.enableResurrectionArgsForCall[i].arg1, fake.enableResurrectionArgsForCall[i].arg2
}

func (fake *FakeDeployment) EnableResurrectionReturns(result1 error) {
	fake.EnableResurrectionStub = nil
	fake.enableResurrectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) EnableResurrectionReturnsOnCall(i int, result1 error) {
	fake.EnableResurrectionStub = nil
	if fake.enableResurrectionReturnsOnCall == nil {
		fake.enableResurrectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableResurrectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Update(manifest []byte, opts director.UpdateOpts) error {
	var manifestCopy []byte
	if manifest != nil {
		manifestCopy = make([]byte, len(manifest))
		copy(manifestCopy, manifest)
	}
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		manifest []byte
		opts     director.UpdateOpts
	}{manifestCopy, opts})
	fake.recordInvocation("Update", []interface{}{manifestCopy, opts})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(manifest, opts)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateReturns.result1
}

func (fake *FakeDeployment) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeDeployment) UpdateArgsForCall(i int) ([]byte, director.UpdateOpts) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].manifest, fake.updateArgsForCall[i].opts
}

func (fake *FakeDeployment) UpdateReturns(result1 error) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) UpdateReturnsOnCall(i int, result1 error) {
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Delete(force bool) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		force bool
	}{force})
	fake.recordInvocation("Delete", []interface{}{force})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(force)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteReturns.result1
}

func (fake *FakeDeployment) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeDeployment) DeleteArgsForCall(i int) bool {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].force
}

func (fake *FakeDeployment) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) DeleteReturnsOnCall(i int, result1 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) AttachDisk(slug director.InstanceSlug, diskCID string) error {
	fake.attachDiskMutex.Lock()
	ret, specificReturn := fake.attachDiskReturnsOnCall[len(fake.attachDiskArgsForCall)]
	fake.attachDiskArgsForCall = append(fake.attachDiskArgsForCall, struct {
		slug    director.InstanceSlug
		diskCID string
	}{slug, diskCID})
	fake.recordInvocation("AttachDisk", []interface{}{slug, diskCID})
	fake.attachDiskMutex.Unlock()
	if fake.AttachDiskStub != nil {
		return fake.AttachDiskStub(slug, diskCID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.attachDiskReturns.result1
}

func (fake *FakeDeployment) AttachDiskCallCount() int {
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return len(fake.attachDiskArgsForCall)
}

func (fake *FakeDeployment) AttachDiskArgsForCall(i int) (director.InstanceSlug, string) {
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return fake.attachDiskArgsForCall[i].slug, fake.attachDiskArgsForCall[i].diskCID
}

func (fake *FakeDeployment) AttachDiskReturns(result1 error) {
	fake.AttachDiskStub = nil
	fake.attachDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) AttachDiskReturnsOnCall(i int, result1 error) {
	fake.AttachDiskStub = nil
	if fake.attachDiskReturnsOnCall == nil {
		fake.attachDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.manifestMutex.RLock()
	defer fake.manifestMutex.RUnlock()
	fake.cloudConfigMutex.RLock()
	defer fake.cloudConfigMutex.RUnlock()
	fake.diffMutex.RLock()
	defer fake.diffMutex.RUnlock()
	fake.releasesMutex.RLock()
	defer fake.releasesMutex.RUnlock()
	fake.exportReleaseMutex.RLock()
	defer fake.exportReleaseMutex.RUnlock()
	fake.teamsMutex.RLock()
	defer fake.teamsMutex.RUnlock()
	fake.stemcellsMutex.RLock()
	defer fake.stemcellsMutex.RUnlock()
	fake.vMInfosMutex.RLock()
	defer fake.vMInfosMutex.RUnlock()
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	fake.instanceInfosMutex.RLock()
	defer fake.instanceInfosMutex.RUnlock()
	fake.errandsMutex.RLock()
	defer fake.errandsMutex.RUnlock()
	fake.runErrandMutex.RLock()
	defer fake.runErrandMutex.RUnlock()
	fake.scanForProblemsMutex.RLock()
	defer fake.scanForProblemsMutex.RUnlock()
	fake.resolveProblemsMutex.RLock()
	defer fake.resolveProblemsMutex.RUnlock()
	fake.snapshotsMutex.RLock()
	defer fake.snapshotsMutex.RUnlock()
	fake.takeSnapshotsMutex.RLock()
	defer fake.takeSnapshotsMutex.RUnlock()
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	fake.deleteSnapshotsMutex.RLock()
	defer fake.deleteSnapshotsMutex.RUnlock()
	fake.deleteVMMutex.RLock()
	defer fake.deleteVMMutex.RUnlock()
	fake.variablesMutex.RLock()
	defer fake.variablesMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.restartMutex.RLock()
	defer fake.restartMutex.RUnlock()
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	fake.setUpSSHMutex.RLock()
	defer fake.setUpSSHMutex.RUnlock()
	fake.cleanUpSSHMutex.RLock()
	defer fake.cleanUpSSHMutex.RUnlock()
	fake.fetchLogsMutex.RLock()
	defer fake.fetchLogsMutex.RUnlock()
	fake.takeSnapshotMutex.RLock()
	defer fake.takeSnapshotMutex.RUnlock()
	fake.ignoreMutex.RLock()
	defer fake.ignoreMutex.RUnlock()
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDeployment) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ director.Deployment = new(FakeDeployment)
