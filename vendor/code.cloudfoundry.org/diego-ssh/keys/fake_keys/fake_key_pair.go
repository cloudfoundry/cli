// This file was generated by counterfeiter
package fake_keys

import (
	"sync"

	"code.cloudfoundry.org/diego-ssh/keys"
	"golang.org/x/crypto/ssh"
)

type FakeKeyPair struct {
	PrivateKeyStub        func() ssh.Signer
	privateKeyMutex       sync.RWMutex
	privateKeyArgsForCall []struct{}
	privateKeyReturns     struct {
		result1 ssh.Signer
	}
	PEMEncodedPrivateKeyStub        func() string
	pEMEncodedPrivateKeyMutex       sync.RWMutex
	pEMEncodedPrivateKeyArgsForCall []struct{}
	pEMEncodedPrivateKeyReturns     struct {
		result1 string
	}
	PublicKeyStub        func() ssh.PublicKey
	publicKeyMutex       sync.RWMutex
	publicKeyArgsForCall []struct{}
	publicKeyReturns     struct {
		result1 ssh.PublicKey
	}
	FingerprintStub        func() string
	fingerprintMutex       sync.RWMutex
	fingerprintArgsForCall []struct{}
	fingerprintReturns     struct {
		result1 string
	}
	AuthorizedKeyStub        func() string
	authorizedKeyMutex       sync.RWMutex
	authorizedKeyArgsForCall []struct{}
	authorizedKeyReturns     struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeKeyPair) PrivateKey() ssh.Signer {
	fake.privateKeyMutex.Lock()
	fake.privateKeyArgsForCall = append(fake.privateKeyArgsForCall, struct{}{})
	fake.recordInvocation("PrivateKey", []interface{}{})
	fake.privateKeyMutex.Unlock()
	if fake.PrivateKeyStub != nil {
		return fake.PrivateKeyStub()
	} else {
		return fake.privateKeyReturns.result1
	}
}

func (fake *FakeKeyPair) PrivateKeyCallCount() int {
	fake.privateKeyMutex.RLock()
	defer fake.privateKeyMutex.RUnlock()
	return len(fake.privateKeyArgsForCall)
}

func (fake *FakeKeyPair) PrivateKeyReturns(result1 ssh.Signer) {
	fake.PrivateKeyStub = nil
	fake.privateKeyReturns = struct {
		result1 ssh.Signer
	}{result1}
}

func (fake *FakeKeyPair) PEMEncodedPrivateKey() string {
	fake.pEMEncodedPrivateKeyMutex.Lock()
	fake.pEMEncodedPrivateKeyArgsForCall = append(fake.pEMEncodedPrivateKeyArgsForCall, struct{}{})
	fake.recordInvocation("PEMEncodedPrivateKey", []interface{}{})
	fake.pEMEncodedPrivateKeyMutex.Unlock()
	if fake.PEMEncodedPrivateKeyStub != nil {
		return fake.PEMEncodedPrivateKeyStub()
	} else {
		return fake.pEMEncodedPrivateKeyReturns.result1
	}
}

func (fake *FakeKeyPair) PEMEncodedPrivateKeyCallCount() int {
	fake.pEMEncodedPrivateKeyMutex.RLock()
	defer fake.pEMEncodedPrivateKeyMutex.RUnlock()
	return len(fake.pEMEncodedPrivateKeyArgsForCall)
}

func (fake *FakeKeyPair) PEMEncodedPrivateKeyReturns(result1 string) {
	fake.PEMEncodedPrivateKeyStub = nil
	fake.pEMEncodedPrivateKeyReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKeyPair) PublicKey() ssh.PublicKey {
	fake.publicKeyMutex.Lock()
	fake.publicKeyArgsForCall = append(fake.publicKeyArgsForCall, struct{}{})
	fake.recordInvocation("PublicKey", []interface{}{})
	fake.publicKeyMutex.Unlock()
	if fake.PublicKeyStub != nil {
		return fake.PublicKeyStub()
	} else {
		return fake.publicKeyReturns.result1
	}
}

func (fake *FakeKeyPair) PublicKeyCallCount() int {
	fake.publicKeyMutex.RLock()
	defer fake.publicKeyMutex.RUnlock()
	return len(fake.publicKeyArgsForCall)
}

func (fake *FakeKeyPair) PublicKeyReturns(result1 ssh.PublicKey) {
	fake.PublicKeyStub = nil
	fake.publicKeyReturns = struct {
		result1 ssh.PublicKey
	}{result1}
}

func (fake *FakeKeyPair) Fingerprint() string {
	fake.fingerprintMutex.Lock()
	fake.fingerprintArgsForCall = append(fake.fingerprintArgsForCall, struct{}{})
	fake.recordInvocation("Fingerprint", []interface{}{})
	fake.fingerprintMutex.Unlock()
	if fake.FingerprintStub != nil {
		return fake.FingerprintStub()
	} else {
		return fake.fingerprintReturns.result1
	}
}

func (fake *FakeKeyPair) FingerprintCallCount() int {
	fake.fingerprintMutex.RLock()
	defer fake.fingerprintMutex.RUnlock()
	return len(fake.fingerprintArgsForCall)
}

func (fake *FakeKeyPair) FingerprintReturns(result1 string) {
	fake.FingerprintStub = nil
	fake.fingerprintReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKeyPair) AuthorizedKey() string {
	fake.authorizedKeyMutex.Lock()
	fake.authorizedKeyArgsForCall = append(fake.authorizedKeyArgsForCall, struct{}{})
	fake.recordInvocation("AuthorizedKey", []interface{}{})
	fake.authorizedKeyMutex.Unlock()
	if fake.AuthorizedKeyStub != nil {
		return fake.AuthorizedKeyStub()
	} else {
		return fake.authorizedKeyReturns.result1
	}
}

func (fake *FakeKeyPair) AuthorizedKeyCallCount() int {
	fake.authorizedKeyMutex.RLock()
	defer fake.authorizedKeyMutex.RUnlock()
	return len(fake.authorizedKeyArgsForCall)
}

func (fake *FakeKeyPair) AuthorizedKeyReturns(result1 string) {
	fake.AuthorizedKeyStub = nil
	fake.authorizedKeyReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKeyPair) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.privateKeyMutex.RLock()
	defer fake.privateKeyMutex.RUnlock()
	fake.pEMEncodedPrivateKeyMutex.RLock()
	defer fake.pEMEncodedPrivateKeyMutex.RUnlock()
	fake.publicKeyMutex.RLock()
	defer fake.publicKeyMutex.RUnlock()
	fake.fingerprintMutex.RLock()
	defer fake.fingerprintMutex.RUnlock()
	fake.authorizedKeyMutex.RLock()
	defer fake.authorizedKeyMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeKeyPair) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ keys.KeyPair = new(FakeKeyPair)
